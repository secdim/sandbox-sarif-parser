{"$schema":"https://json.schemastore.org/sarif-2.1.0.json","version":"2.1.0","runs":[{"tool":{"driver":{"name":"CodeQL","organization":"GitHub","semanticVersion":"2.23.0","notifications":[{"id":"cli/expected-extracted-files/python","name":"cli/expected-extracted-files/python","shortDescription":{"text":"Expected extracted files"},"fullDescription":{"text":"Files appearing in the source archive that are expected to be extracted."},"defaultConfiguration":{"enabled":true},"properties":{"tags":["expected-extracted-files","telemetry"],"languageDisplayName":"Python"}},{"id":"cli/platform","name":"cli/platform","shortDescription":{"text":"Platform"},"fullDescription":{"text":"Platform"},"defaultConfiguration":{"enabled":true}},{"id":"codeql-action/bundle-download-telemetry","name":"codeql-action/bundle-download-telemetry","shortDescription":{"text":"CodeQL bundle download telemetry"},"fullDescription":{"text":"CodeQL bundle download telemetry"},"defaultConfiguration":{"enabled":true}}],"rules":[]},"extensions":[{"name":"codeql/python-queries","semanticVersion":"1.6.4+28f02c07d7d744d761520fbfb354f96827a11f6c","notifications":[{"id":"py/diagnostics/extraction-warnings","name":"py/diagnostics/extraction-warnings","shortDescription":{"text":"Python extraction warnings"},"fullDescription":{"text":"List all extraction warnings for Python files in the source code directory."},"defaultConfiguration":{"enabled":true},"properties":{"description":"List all extraction warnings for Python files in the source code directory.","id":"py/diagnostics/extraction-warnings","kind":"diagnostic","name":"Python extraction warnings"}},{"id":"py/diagnostics/successfully-extracted-files","name":"py/diagnostics/successfully-extracted-files","shortDescription":{"text":"Extracted Python files"},"fullDescription":{"text":"Lists all Python files in the source code directory that were extracted."},"defaultConfiguration":{"enabled":true},"properties":{"tags":["successfully-extracted-files"],"description":"Lists all Python files in the source code directory that were extracted.","id":"py/diagnostics/successfully-extracted-files","kind":"diagnostic","name":"Extracted Python files"}}],"rules":[{"id":"py/bad-tag-filter","name":"py/bad-tag-filter","shortDescription":{"text":"Bad HTML filtering regexp"},"fullDescription":{"text":"Matching HTML tags using regular expressions is hard to do right, and can easily lead to security issues."},"defaultConfiguration":{"enabled":true,"level":"warning"},"help":{"text":"# Bad HTML filtering regexp\nIt is possible to match some single HTML tags using regular expressions (parsing general HTML using regular expressions is impossible). However, if the regular expression is not written well it might be possible to circumvent it, which can lead to cross-site scripting or other security issues.\n\nSome of these mistakes are caused by browsers having very forgiving HTML parsers, and will often render invalid HTML containing syntax errors. Regular expressions that attempt to match HTML should also recognize tags containing such syntax errors.\n\n\n## Recommendation\nUse a well-tested sanitization or parser library if at all possible. These libraries are much more likely to handle corner cases correctly than a custom implementation.\n\n\n## Example\nThe following example attempts to filters out all `<script>` tags.\n\n\n```python\nimport re\n\ndef filterScriptTags(content): \n    oldContent = \"\"\n    while oldContent != content:\n        oldContent = content\n        content = re.sub(r'<script.*?>.*?</script>', '', content, flags= re.DOTALL | re.IGNORECASE)\n    return content\n```\nThe above sanitizer does not filter out all `<script>` tags. Browsers will not only accept `</script>` as script end tags, but also tags such as `</script foo=\"bar\">` even though it is a parser error. This means that an attack string such as `<script>alert(1)</script foo=\"bar\">` will not be filtered by the function, and `alert(1)` will be executed by a browser if the string is rendered as HTML.\n\nOther corner cases include that HTML comments can end with `--!>`, and that HTML tag names can contain upper case characters.\n\n\n## References\n* Securitum: [The Curious Case of Copy &amp; Paste](https://research.securitum.com/the-curious-case-of-copy-paste/).\n* stackoverflow.com: [You can't parse \\[X\\]HTML with regex](https://stackoverflow.com/questions/1732348/regex-match-open-tags-except-xhtml-self-contained-tags#answer-1732454).\n* HTML Standard: [Comment end bang state](https://html.spec.whatwg.org/multipage/parsing.html#comment-end-bang-state).\n* stackoverflow.com: [Why aren't browsers strict about HTML?](https://stackoverflow.com/questions/25559999/why-arent-browsers-strict-about-html).\n* Common Weakness Enumeration: [CWE-116](https://cwe.mitre.org/data/definitions/116.html).\n* Common Weakness Enumeration: [CWE-20](https://cwe.mitre.org/data/definitions/20.html).\n* Common Weakness Enumeration: [CWE-185](https://cwe.mitre.org/data/definitions/185.html).\n* Common Weakness Enumeration: [CWE-186](https://cwe.mitre.org/data/definitions/186.html).\n","markdown":"# Bad HTML filtering regexp\nIt is possible to match some single HTML tags using regular expressions (parsing general HTML using regular expressions is impossible). However, if the regular expression is not written well it might be possible to circumvent it, which can lead to cross-site scripting or other security issues.\n\nSome of these mistakes are caused by browsers having very forgiving HTML parsers, and will often render invalid HTML containing syntax errors. Regular expressions that attempt to match HTML should also recognize tags containing such syntax errors.\n\n\n## Recommendation\nUse a well-tested sanitization or parser library if at all possible. These libraries are much more likely to handle corner cases correctly than a custom implementation.\n\n\n## Example\nThe following example attempts to filters out all `<script>` tags.\n\n\n```python\nimport re\n\ndef filterScriptTags(content): \n    oldContent = \"\"\n    while oldContent != content:\n        oldContent = content\n        content = re.sub(r'<script.*?>.*?</script>', '', content, flags= re.DOTALL | re.IGNORECASE)\n    return content\n```\nThe above sanitizer does not filter out all `<script>` tags. Browsers will not only accept `</script>` as script end tags, but also tags such as `</script foo=\"bar\">` even though it is a parser error. This means that an attack string such as `<script>alert(1)</script foo=\"bar\">` will not be filtered by the function, and `alert(1)` will be executed by a browser if the string is rendered as HTML.\n\nOther corner cases include that HTML comments can end with `--!>`, and that HTML tag names can contain upper case characters.\n\n\n## References\n* Securitum: [The Curious Case of Copy &amp; Paste](https://research.securitum.com/the-curious-case-of-copy-paste/).\n* stackoverflow.com: [You can't parse \\[X\\]HTML with regex](https://stackoverflow.com/questions/1732348/regex-match-open-tags-except-xhtml-self-contained-tags#answer-1732454).\n* HTML Standard: [Comment end bang state](https://html.spec.whatwg.org/multipage/parsing.html#comment-end-bang-state).\n* stackoverflow.com: [Why aren't browsers strict about HTML?](https://stackoverflow.com/questions/25559999/why-arent-browsers-strict-about-html).\n* Common Weakness Enumeration: [CWE-116](https://cwe.mitre.org/data/definitions/116.html).\n* Common Weakness Enumeration: [CWE-20](https://cwe.mitre.org/data/definitions/20.html).\n* Common Weakness Enumeration: [CWE-185](https://cwe.mitre.org/data/definitions/185.html).\n* Common Weakness Enumeration: [CWE-186](https://cwe.mitre.org/data/definitions/186.html).\n"},"properties":{"tags":["correctness","security","external/cwe/cwe-116","external/cwe/cwe-020","external/cwe/cwe-185","external/cwe/cwe-186"],"description":"Matching HTML tags using regular expressions is hard to do right, and can easily lead to security issues.","id":"py/bad-tag-filter","kind":"problem","name":"Bad HTML filtering regexp","precision":"high","problem.severity":"warning","security-severity":"7.8"}},{"id":"py/stack-trace-exposure","name":"py/stack-trace-exposure","shortDescription":{"text":"Information exposure through an exception"},"fullDescription":{"text":"Leaking information about an exception, such as messages and stack traces, to an external user can expose implementation details that are useful to an attacker for developing a subsequent exploit."},"defaultConfiguration":{"enabled":true,"level":"error"},"help":{"text":"# Information exposure through an exception\nSoftware developers often add stack traces to error messages, as a debugging aid. Whenever that error message occurs for an end user, the developer can use the stack trace to help identify how to fix the problem. In particular, stack traces can tell the developer more about the sequence of events that led to a failure, as opposed to merely the final state of the software when the error occurred.\n\nUnfortunately, the same information can be useful to an attacker. The sequence of class names in a stack trace can reveal the structure of the application as well as any internal components it relies on. Furthermore, the error message at the top of a stack trace can include information such as server-side file names and SQL code that the application relies on, allowing an attacker to fine-tune a subsequent injection attack.\n\n\n## Recommendation\nSend the user a more generic error message that reveals less information. Either suppress the stack trace entirely, or log it only on the server.\n\n\n## Example\nIn the following example, an exception is handled in two different ways. In the first version, labeled BAD, the exception is sent back to the remote user by returning it from the function. As such, the user is able to see a detailed stack trace, which may contain sensitive information. In the second version, the error message is logged only on the server, and a generic error message is displayed to the user. That way, the developers can still access and use the error log, but remote users will not see the information.\n\n\n```python\nfrom flask import Flask\napp = Flask(__name__)\n\n\nimport traceback\n\ndef do_computation():\n    raise Exception(\"Secret info\")\n\n# BAD\n@app.route('/bad')\ndef server_bad():\n    try:\n        do_computation()\n    except Exception as e:\n        return traceback.format_exc()\n\n# GOOD\n@app.route('/good')\ndef server_good():\n    try:\n        do_computation()\n    except Exception as e:\n        log(traceback.format_exc())\n        return \"An internal error has occurred!\"\n\n```\n\n## References\n* OWASP: [Improper Error Handling](https://owasp.org/www-community/Improper_Error_Handling).\n* Common Weakness Enumeration: [CWE-209](https://cwe.mitre.org/data/definitions/209.html).\n* Common Weakness Enumeration: [CWE-497](https://cwe.mitre.org/data/definitions/497.html).\n","markdown":"# Information exposure through an exception\nSoftware developers often add stack traces to error messages, as a debugging aid. Whenever that error message occurs for an end user, the developer can use the stack trace to help identify how to fix the problem. In particular, stack traces can tell the developer more about the sequence of events that led to a failure, as opposed to merely the final state of the software when the error occurred.\n\nUnfortunately, the same information can be useful to an attacker. The sequence of class names in a stack trace can reveal the structure of the application as well as any internal components it relies on. Furthermore, the error message at the top of a stack trace can include information such as server-side file names and SQL code that the application relies on, allowing an attacker to fine-tune a subsequent injection attack.\n\n\n## Recommendation\nSend the user a more generic error message that reveals less information. Either suppress the stack trace entirely, or log it only on the server.\n\n\n## Example\nIn the following example, an exception is handled in two different ways. In the first version, labeled BAD, the exception is sent back to the remote user by returning it from the function. As such, the user is able to see a detailed stack trace, which may contain sensitive information. In the second version, the error message is logged only on the server, and a generic error message is displayed to the user. That way, the developers can still access and use the error log, but remote users will not see the information.\n\n\n```python\nfrom flask import Flask\napp = Flask(__name__)\n\n\nimport traceback\n\ndef do_computation():\n    raise Exception(\"Secret info\")\n\n# BAD\n@app.route('/bad')\ndef server_bad():\n    try:\n        do_computation()\n    except Exception as e:\n        return traceback.format_exc()\n\n# GOOD\n@app.route('/good')\ndef server_good():\n    try:\n        do_computation()\n    except Exception as e:\n        log(traceback.format_exc())\n        return \"An internal error has occurred!\"\n\n```\n\n## References\n* OWASP: [Improper Error Handling](https://owasp.org/www-community/Improper_Error_Handling).\n* Common Weakness Enumeration: [CWE-209](https://cwe.mitre.org/data/definitions/209.html).\n* Common Weakness Enumeration: [CWE-497](https://cwe.mitre.org/data/definitions/497.html).\n"},"properties":{"tags":["security","external/cwe/cwe-209","external/cwe/cwe-497"],"description":"Leaking information about an exception, such as messages and stack traces, to an\n              external user can expose implementation details that are useful to an attacker for\n              developing a subsequent exploit.","id":"py/stack-trace-exposure","kind":"path-problem","name":"Information exposure through an exception","precision":"high","problem.severity":"error","security-severity":"5.4"}},{"id":"py/ldap-injection","name":"py/ldap-injection","shortDescription":{"text":"LDAP query built from user-controlled sources"},"fullDescription":{"text":"Building an LDAP query from user-controlled sources is vulnerable to insertion of malicious LDAP code by the user."},"defaultConfiguration":{"enabled":true,"level":"error"},"help":{"text":"# LDAP query built from user-controlled sources\nIf an LDAP query or DN is built using string concatenation or string formatting, and the components of the concatenation include user input without any proper sanitization, a user is likely to be able to run malicious LDAP queries.\n\n\n## Recommendation\nIf user input must be included in an LDAP query or DN, it should be escaped to avoid a malicious user providing special characters that change the meaning of the query. In Python2, user input should be escaped with `ldap.dn.escape_dn_chars` or `ldap.filter.escape_filter_chars`, while in Python3, user input should be escaped with `ldap3.utils.dn.escape_rdn` or `ldap3.utils.conv.escape_filter_chars` depending on the component tainted by the user. A good practice is to escape filter characters that could change the meaning of the query (https://tools.ietf.org/search/rfc4515\\#section-3).\n\n\n## Example\nIn the following examples, the code accepts both `username` and `dc` from the user, which it then uses to build a LDAP query and DN.\n\nThe first and the second example uses the unsanitized user input directly in the search filter and DN for the LDAP query. A malicious user could provide special characters to change the meaning of these components, and search for a completely different set of values.\n\n\n```python\nfrom flask import request, Flask\nimport ldap\n\n\n@app.route(\"/normal\")\ndef normal():\n    unsafe_dc = request.args['dc']\n    unsafe_filter = request.args['username']\n\n    dn = \"dc={}\".format(unsafe_dc)\n    search_filter = \"(user={})\".format(unsafe_filter)\n\n    ldap_connection = ldap.initialize(\"ldap://127.0.0.1\")\n    user = ldap_connection.search_s(\n        dn, ldap.SCOPE_SUBTREE, search_filter)\n\n```\n\n```python\nfrom flask import request, Flask\nimport ldap3\n\n\n@app.route(\"/normal\")\ndef normal():\n    unsafe_dc = request.args['dc']\n    unsafe_filter = request.args['username']\n\n    dn = \"dc={}\".format(unsafe_dc)\n    search_filter = \"(user={})\".format(unsafe_filter)\n\n    srv = ldap3.Server('ldap://127.0.0.1')\n    conn = ldap3.Connection(srv, user=dn, auto_bind=True)\n    conn.search(dn, search_filter)\n\n```\nIn the third and fourth example, the input provided by the user is sanitized before it is included in the search filter or DN. This ensures the meaning of the query cannot be changed by a malicious user.\n\n\n```python\nfrom flask import request, Flask\nimport ldap\nimport ldap.filter\nimport ldap.dn\n\n\n@app.route(\"/normal\")\ndef normal():\n    unsafe_dc = request.args['dc']\n    unsafe_filter = request.args['username']\n\n    safe_dc = ldap.dn.escape_dn_chars(unsafe_dc)\n    safe_filter = ldap.filter.escape_filter_chars(unsafe_filter)\n\n    dn = \"dc={}\".format(safe_dc)\n    search_filter = \"(user={})\".format(safe_filter)\n\n    ldap_connection = ldap.initialize(\"ldap://127.0.0.1\")\n    user = ldap_connection.search_s(\n        dn, ldap.SCOPE_SUBTREE, search_filter)\n\n```\n\n```python\nfrom flask import request, Flask\nimport ldap3\nfrom ldap3.utils.dn import escape_rdn\nfrom ldap3.utils.conv import escape_filter_chars\n\n\n@app.route(\"/normal\")\ndef normal():\n    unsafe_dc = request.args['dc']\n    unsafe_filter = request.args['username']\n\n    safe_dc = escape_rdn(unsafe_dc)\n    safe_filter = escape_filter_chars(unsafe_filter)\n\n    dn = \"dc={}\".format(safe_dc)\n    search_filter = \"(user={})\".format(safe_filter)\n\n    srv = ldap3.Server('ldap://127.0.0.1')\n    conn = ldap3.Connection(srv, user=dn, auto_bind=True)\n    conn.search(dn, search_filter)\n\n```\n\n## References\n* OWASP: [LDAP Injection Prevention Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/LDAP_Injection_Prevention_Cheat_Sheet.html).\n* OWASP: [LDAP Injection](https://owasp.org/www-community/attacks/LDAP_Injection).\n* SonarSource: [RSPEC-2078](https://rules.sonarsource.com/python/RSPEC-2078).\n* Python2: [LDAP Documentation](https://www.python-ldap.org/en/python-ldap-3.3.0/reference/ldap.html).\n* Python3: [LDAP Documentation](https://ldap3.readthedocs.io/en/latest/).\n* Wikipedia: [LDAP injection](https://en.wikipedia.org/wiki/LDAP_injection).\n* BlackHat: [LDAP Injection and Blind LDAP Injection](https://www.blackhat.com/presentations/bh-europe-08/Alonso-Parada/Whitepaper/bh-eu-08-alonso-parada-WP.pdf).\n* LDAP: [Understanding and Defending Against LDAP Injection Attacks](https://ldap.com/2018/05/04/understanding-and-defending-against-ldap-injection-attacks/).\n* Common Weakness Enumeration: [CWE-90](https://cwe.mitre.org/data/definitions/90.html).\n","markdown":"# LDAP query built from user-controlled sources\nIf an LDAP query or DN is built using string concatenation or string formatting, and the components of the concatenation include user input without any proper sanitization, a user is likely to be able to run malicious LDAP queries.\n\n\n## Recommendation\nIf user input must be included in an LDAP query or DN, it should be escaped to avoid a malicious user providing special characters that change the meaning of the query. In Python2, user input should be escaped with `ldap.dn.escape_dn_chars` or `ldap.filter.escape_filter_chars`, while in Python3, user input should be escaped with `ldap3.utils.dn.escape_rdn` or `ldap3.utils.conv.escape_filter_chars` depending on the component tainted by the user. A good practice is to escape filter characters that could change the meaning of the query (https://tools.ietf.org/search/rfc4515\\#section-3).\n\n\n## Example\nIn the following examples, the code accepts both `username` and `dc` from the user, which it then uses to build a LDAP query and DN.\n\nThe first and the second example uses the unsanitized user input directly in the search filter and DN for the LDAP query. A malicious user could provide special characters to change the meaning of these components, and search for a completely different set of values.\n\n\n```python\nfrom flask import request, Flask\nimport ldap\n\n\n@app.route(\"/normal\")\ndef normal():\n    unsafe_dc = request.args['dc']\n    unsafe_filter = request.args['username']\n\n    dn = \"dc={}\".format(unsafe_dc)\n    search_filter = \"(user={})\".format(unsafe_filter)\n\n    ldap_connection = ldap.initialize(\"ldap://127.0.0.1\")\n    user = ldap_connection.search_s(\n        dn, ldap.SCOPE_SUBTREE, search_filter)\n\n```\n\n```python\nfrom flask import request, Flask\nimport ldap3\n\n\n@app.route(\"/normal\")\ndef normal():\n    unsafe_dc = request.args['dc']\n    unsafe_filter = request.args['username']\n\n    dn = \"dc={}\".format(unsafe_dc)\n    search_filter = \"(user={})\".format(unsafe_filter)\n\n    srv = ldap3.Server('ldap://127.0.0.1')\n    conn = ldap3.Connection(srv, user=dn, auto_bind=True)\n    conn.search(dn, search_filter)\n\n```\nIn the third and fourth example, the input provided by the user is sanitized before it is included in the search filter or DN. This ensures the meaning of the query cannot be changed by a malicious user.\n\n\n```python\nfrom flask import request, Flask\nimport ldap\nimport ldap.filter\nimport ldap.dn\n\n\n@app.route(\"/normal\")\ndef normal():\n    unsafe_dc = request.args['dc']\n    unsafe_filter = request.args['username']\n\n    safe_dc = ldap.dn.escape_dn_chars(unsafe_dc)\n    safe_filter = ldap.filter.escape_filter_chars(unsafe_filter)\n\n    dn = \"dc={}\".format(safe_dc)\n    search_filter = \"(user={})\".format(safe_filter)\n\n    ldap_connection = ldap.initialize(\"ldap://127.0.0.1\")\n    user = ldap_connection.search_s(\n        dn, ldap.SCOPE_SUBTREE, search_filter)\n\n```\n\n```python\nfrom flask import request, Flask\nimport ldap3\nfrom ldap3.utils.dn import escape_rdn\nfrom ldap3.utils.conv import escape_filter_chars\n\n\n@app.route(\"/normal\")\ndef normal():\n    unsafe_dc = request.args['dc']\n    unsafe_filter = request.args['username']\n\n    safe_dc = escape_rdn(unsafe_dc)\n    safe_filter = escape_filter_chars(unsafe_filter)\n\n    dn = \"dc={}\".format(safe_dc)\n    search_filter = \"(user={})\".format(safe_filter)\n\n    srv = ldap3.Server('ldap://127.0.0.1')\n    conn = ldap3.Connection(srv, user=dn, auto_bind=True)\n    conn.search(dn, search_filter)\n\n```\n\n## References\n* OWASP: [LDAP Injection Prevention Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/LDAP_Injection_Prevention_Cheat_Sheet.html).\n* OWASP: [LDAP Injection](https://owasp.org/www-community/attacks/LDAP_Injection).\n* SonarSource: [RSPEC-2078](https://rules.sonarsource.com/python/RSPEC-2078).\n* Python2: [LDAP Documentation](https://www.python-ldap.org/en/python-ldap-3.3.0/reference/ldap.html).\n* Python3: [LDAP Documentation](https://ldap3.readthedocs.io/en/latest/).\n* Wikipedia: [LDAP injection](https://en.wikipedia.org/wiki/LDAP_injection).\n* BlackHat: [LDAP Injection and Blind LDAP Injection](https://www.blackhat.com/presentations/bh-europe-08/Alonso-Parada/Whitepaper/bh-eu-08-alonso-parada-WP.pdf).\n* LDAP: [Understanding and Defending Against LDAP Injection Attacks](https://ldap.com/2018/05/04/understanding-and-defending-against-ldap-injection-attacks/).\n* Common Weakness Enumeration: [CWE-90](https://cwe.mitre.org/data/definitions/90.html).\n"},"properties":{"tags":["security","external/cwe/cwe-090"],"description":"Building an LDAP query from user-controlled sources is vulnerable to insertion of\n              malicious LDAP code by the user.","id":"py/ldap-injection","kind":"path-problem","name":"LDAP query built from user-controlled sources","precision":"high","problem.severity":"error","security-severity":"9.8"}},{"id":"py/insecure-protocol","name":"py/insecure-protocol","shortDescription":{"text":"Use of insecure SSL/TLS version"},"fullDescription":{"text":"Using an insecure SSL/TLS version may leave the connection vulnerable to attacks."},"defaultConfiguration":{"enabled":true,"level":"warning"},"help":{"text":"# Use of insecure SSL/TLS version\nUsing a broken or weak cryptographic protocol may make a connection vulnerable to interference from an attacker.\n\n\n## Recommendation\nEnsure that a modern, strong protocol is used. All versions of SSL, and TLS versions 1.0 and 1.1 are known to be vulnerable to attacks. Using TLS 1.2 or above is strongly recommended.\n\n\n## Example\nThe following code shows a variety of ways of setting up a connection using SSL or TLS. They are all insecure because of the version specified.\n\n\n```python\nimport ssl\nimport socket\n\n# Using the deprecated ssl.wrap_socket method\nssl.wrap_socket(socket.socket(), ssl_version=ssl.PROTOCOL_SSLv2)\n\n# Using SSLContext\ncontext = ssl.SSLContext(ssl_version=ssl.PROTOCOL_SSLv3)\n\n# Using pyOpenSSL\n\nfrom pyOpenSSL import SSL\n\ncontext = SSL.Context(SSL.TLSv1_METHOD)\n\n\n\n```\nAll cases should be updated to use a secure protocol, such as `PROTOCOL_TLSv1_2`.\n\nNote that `ssl.wrap_socket` has been deprecated in Python 3.7. The recommended alternatives are:\n\n* `ssl.SSLContext` - supported in Python 2.7.9, 3.2, and later versions\n* `ssl.create_default_context` - a convenience function, supported in Python 3.4 and later versions.\nEven when you use these alternatives, you should ensure that a safe protocol is used. The following code illustrates how to use flags (available since Python 3.2) or the \\`minimum_version\\` field (favored since Python 3.7) to restrict the protocols accepted when creating a connection.\n\n\n```python\nimport ssl\n\n# Using flags to restrict the protocol\ncontext = ssl.SSLContext()\ncontext.options |= ssl.OP_NO_TLSv1 | ssl.OP_NO_TLSv1_1\n\n# Declaring a minimum version to restrict the protocol\ncontext = ssl.create_default_context()\ncontext.minimum_version = ssl.TLSVersion.TLSv1_2\n\n```\n\n## References\n* Wikipedia: [ Transport Layer Security](https://en.wikipedia.org/wiki/Transport_Layer_Security).\n* Python 3 documentation: [ class ssl.SSLContext](https://docs.python.org/3/library/ssl.html#ssl.SSLContext).\n* Python 3 documentation: [ ssl.wrap_socket](https://docs.python.org/3/library/ssl.html#ssl.wrap_socket).\n* Python 3 documentation: [ notes on context creation](https://docs.python.org/3/library/ssl.html#functions-constants-and-exceptions).\n* Python 3 documentation: [ notes on security considerations](https://docs.python.org/3/library/ssl.html#ssl-security).\n* pyOpenSSL documentation: [ An interface to the SSL-specific parts of OpenSSL](https://pyopenssl.org/en/stable/api/ssl.html).\n* Common Weakness Enumeration: [CWE-327](https://cwe.mitre.org/data/definitions/327.html).\n","markdown":"# Use of insecure SSL/TLS version\nUsing a broken or weak cryptographic protocol may make a connection vulnerable to interference from an attacker.\n\n\n## Recommendation\nEnsure that a modern, strong protocol is used. All versions of SSL, and TLS versions 1.0 and 1.1 are known to be vulnerable to attacks. Using TLS 1.2 or above is strongly recommended.\n\n\n## Example\nThe following code shows a variety of ways of setting up a connection using SSL or TLS. They are all insecure because of the version specified.\n\n\n```python\nimport ssl\nimport socket\n\n# Using the deprecated ssl.wrap_socket method\nssl.wrap_socket(socket.socket(), ssl_version=ssl.PROTOCOL_SSLv2)\n\n# Using SSLContext\ncontext = ssl.SSLContext(ssl_version=ssl.PROTOCOL_SSLv3)\n\n# Using pyOpenSSL\n\nfrom pyOpenSSL import SSL\n\ncontext = SSL.Context(SSL.TLSv1_METHOD)\n\n\n\n```\nAll cases should be updated to use a secure protocol, such as `PROTOCOL_TLSv1_2`.\n\nNote that `ssl.wrap_socket` has been deprecated in Python 3.7. The recommended alternatives are:\n\n* `ssl.SSLContext` - supported in Python 2.7.9, 3.2, and later versions\n* `ssl.create_default_context` - a convenience function, supported in Python 3.4 and later versions.\nEven when you use these alternatives, you should ensure that a safe protocol is used. The following code illustrates how to use flags (available since Python 3.2) or the \\`minimum_version\\` field (favored since Python 3.7) to restrict the protocols accepted when creating a connection.\n\n\n```python\nimport ssl\n\n# Using flags to restrict the protocol\ncontext = ssl.SSLContext()\ncontext.options |= ssl.OP_NO_TLSv1 | ssl.OP_NO_TLSv1_1\n\n# Declaring a minimum version to restrict the protocol\ncontext = ssl.create_default_context()\ncontext.minimum_version = ssl.TLSVersion.TLSv1_2\n\n```\n\n## References\n* Wikipedia: [ Transport Layer Security](https://en.wikipedia.org/wiki/Transport_Layer_Security).\n* Python 3 documentation: [ class ssl.SSLContext](https://docs.python.org/3/library/ssl.html#ssl.SSLContext).\n* Python 3 documentation: [ ssl.wrap_socket](https://docs.python.org/3/library/ssl.html#ssl.wrap_socket).\n* Python 3 documentation: [ notes on context creation](https://docs.python.org/3/library/ssl.html#functions-constants-and-exceptions).\n* Python 3 documentation: [ notes on security considerations](https://docs.python.org/3/library/ssl.html#ssl-security).\n* pyOpenSSL documentation: [ An interface to the SSL-specific parts of OpenSSL](https://pyopenssl.org/en/stable/api/ssl.html).\n* Common Weakness Enumeration: [CWE-327](https://cwe.mitre.org/data/definitions/327.html).\n"},"properties":{"tags":["security","external/cwe/cwe-327"],"description":"Using an insecure SSL/TLS version may leave the connection vulnerable to attacks.","id":"py/insecure-protocol","kind":"problem","name":"Use of insecure SSL/TLS version","precision":"high","problem.severity":"warning","security-severity":"7.5"}},{"id":"py/weak-sensitive-data-hashing","name":"py/weak-sensitive-data-hashing","shortDescription":{"text":"Use of a broken or weak cryptographic hashing algorithm on sensitive data"},"fullDescription":{"text":"Using broken or weak cryptographic hashing algorithms can compromise security."},"defaultConfiguration":{"enabled":true,"level":"warning"},"help":{"text":"# Use of a broken or weak cryptographic hashing algorithm on sensitive data\nUsing a broken or weak cryptographic hash function can leave data vulnerable, and should not be used in security related code.\n\nA strong cryptographic hash function should be resistant to:\n\n* pre-image attacks: if you know a hash value `h(x)`, you should not be able to easily find the input `x`.\n* collision attacks: if you know a hash value `h(x)`, you should not be able to easily find a different input `y` with the same hash value `h(x) = h(y)`.\nIn cases with a limited input space, such as for passwords, the hash function also needs to be computationally expensive to be resistant to brute-force attacks. Passwords should also have an unique salt applied before hashing, but that is not considered by this query.\n\nAs an example, both MD5 and SHA-1 are known to be vulnerable to collision attacks.\n\nSince it's OK to use a weak cryptographic hash function in a non-security context, this query only alerts when these are used to hash sensitive data (such as passwords, certificates, usernames).\n\nUse of broken or weak cryptographic algorithms that are not hashing algorithms, is handled by the `py/weak-cryptographic-algorithm` query.\n\n\n## Recommendation\nEnsure that you use a strong, modern cryptographic hash function:\n\n* such as Argon2, scrypt, bcrypt, or PBKDF2 for passwords and other data with limited input space.\n* such as SHA-2, or SHA-3 in other cases.\n\n## Example\nThe following example shows two functions for checking whether the hash of a certificate matches a known value -- to prevent tampering. The first function uses MD5 that is known to be vulnerable to collision attacks. The second function uses SHA-256 that is a strong cryptographic hashing function.\n\n\n```python\nimport hashlib\n\ndef certificate_matches_known_hash_bad(certificate, known_hash):\n    hash = hashlib.md5(certificate).hexdigest() # BAD\n    return hash == known_hash\n\ndef certificate_matches_known_hash_good(certificate, known_hash):\n    hash = hashlib.sha256(certificate).hexdigest() # GOOD\n    return hash == known_hash\n\n```\n\n## Example\nThe following example shows two functions for hashing passwords. The first function uses SHA-256 to hash passwords. Although SHA-256 is a strong cryptographic hash function, it is not suitable for password hashing since it is not computationally expensive.\n\n\n```python\nimport hashlib\n\ndef get_password_hash(password: str, salt: str):\n    return hashlib.sha256(password + salt).hexdigest() # BAD\n\n```\nThe second function uses Argon2 (through the `argon2-cffi` PyPI package), which is a strong password hashing algorithm (and includes a per-password salt by default).\n\n\n```python\nfrom argon2 import PasswordHasher\n\ndef get_initial_hash(password: str):\n    ph = PasswordHasher()\n    return ph.hash(password) # GOOD\n\ndef check_password(password: str, known_hash):\n    ph = PasswordHasher()\n    return ph.verify(known_hash, password) # GOOD\n\n```\n\n## References\n* OWASP: [Password Storage Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/Password_Storage_Cheat_Sheet.html)\n* Common Weakness Enumeration: [CWE-327](https://cwe.mitre.org/data/definitions/327.html).\n* Common Weakness Enumeration: [CWE-328](https://cwe.mitre.org/data/definitions/328.html).\n* Common Weakness Enumeration: [CWE-916](https://cwe.mitre.org/data/definitions/916.html).\n","markdown":"# Use of a broken or weak cryptographic hashing algorithm on sensitive data\nUsing a broken or weak cryptographic hash function can leave data vulnerable, and should not be used in security related code.\n\nA strong cryptographic hash function should be resistant to:\n\n* pre-image attacks: if you know a hash value `h(x)`, you should not be able to easily find the input `x`.\n* collision attacks: if you know a hash value `h(x)`, you should not be able to easily find a different input `y` with the same hash value `h(x) = h(y)`.\nIn cases with a limited input space, such as for passwords, the hash function also needs to be computationally expensive to be resistant to brute-force attacks. Passwords should also have an unique salt applied before hashing, but that is not considered by this query.\n\nAs an example, both MD5 and SHA-1 are known to be vulnerable to collision attacks.\n\nSince it's OK to use a weak cryptographic hash function in a non-security context, this query only alerts when these are used to hash sensitive data (such as passwords, certificates, usernames).\n\nUse of broken or weak cryptographic algorithms that are not hashing algorithms, is handled by the `py/weak-cryptographic-algorithm` query.\n\n\n## Recommendation\nEnsure that you use a strong, modern cryptographic hash function:\n\n* such as Argon2, scrypt, bcrypt, or PBKDF2 for passwords and other data with limited input space.\n* such as SHA-2, or SHA-3 in other cases.\n\n## Example\nThe following example shows two functions for checking whether the hash of a certificate matches a known value -- to prevent tampering. The first function uses MD5 that is known to be vulnerable to collision attacks. The second function uses SHA-256 that is a strong cryptographic hashing function.\n\n\n```python\nimport hashlib\n\ndef certificate_matches_known_hash_bad(certificate, known_hash):\n    hash = hashlib.md5(certificate).hexdigest() # BAD\n    return hash == known_hash\n\ndef certificate_matches_known_hash_good(certificate, known_hash):\n    hash = hashlib.sha256(certificate).hexdigest() # GOOD\n    return hash == known_hash\n\n```\n\n## Example\nThe following example shows two functions for hashing passwords. The first function uses SHA-256 to hash passwords. Although SHA-256 is a strong cryptographic hash function, it is not suitable for password hashing since it is not computationally expensive.\n\n\n```python\nimport hashlib\n\ndef get_password_hash(password: str, salt: str):\n    return hashlib.sha256(password + salt).hexdigest() # BAD\n\n```\nThe second function uses Argon2 (through the `argon2-cffi` PyPI package), which is a strong password hashing algorithm (and includes a per-password salt by default).\n\n\n```python\nfrom argon2 import PasswordHasher\n\ndef get_initial_hash(password: str):\n    ph = PasswordHasher()\n    return ph.hash(password) # GOOD\n\ndef check_password(password: str, known_hash):\n    ph = PasswordHasher()\n    return ph.verify(known_hash, password) # GOOD\n\n```\n\n## References\n* OWASP: [Password Storage Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/Password_Storage_Cheat_Sheet.html)\n* Common Weakness Enumeration: [CWE-327](https://cwe.mitre.org/data/definitions/327.html).\n* Common Weakness Enumeration: [CWE-328](https://cwe.mitre.org/data/definitions/328.html).\n* Common Weakness Enumeration: [CWE-916](https://cwe.mitre.org/data/definitions/916.html).\n"},"properties":{"tags":["security","external/cwe/cwe-327","external/cwe/cwe-328","external/cwe/cwe-916"],"description":"Using broken or weak cryptographic hashing algorithms can compromise security.","id":"py/weak-sensitive-data-hashing","kind":"path-problem","name":"Use of a broken or weak cryptographic hashing algorithm on sensitive data","precision":"high","problem.severity":"warning","security-severity":"7.5"}},{"id":"py/insecure-default-protocol","name":"py/insecure-default-protocol","shortDescription":{"text":"Default version of SSL/TLS may be insecure"},"fullDescription":{"text":"Leaving the SSL/TLS version unspecified may result in an insecure default protocol being used."},"defaultConfiguration":{"enabled":true,"level":"warning"},"help":{"text":"# Default version of SSL/TLS may be insecure\nThe `ssl.wrap_socket` function defaults to an insecure version of SSL/TLS when no specific protocol version is specified. This may leave the connection vulnerable to attack.\n\n\n## Recommendation\nEnsure that a modern, strong protocol is used. All versions of SSL, and TLS 1.0 and 1.1 are known to be vulnerable to attacks. Using TLS 1.2 or above is strongly recommended. If no explicit `ssl_version` is specified, the default `PROTOCOL_TLS` is chosen. This protocol is insecure because it allows TLS 1.0 and TLS 1.1 and so should not be used.\n\n\n## Example\nThe following code shows two different ways of setting up a connection using SSL or TLS. They are both potentially insecure because the default version is used.\n\n\n```python\nimport ssl\nimport socket\n\n# Using the deprecated ssl.wrap_socket method\nssl.wrap_socket(socket.socket())\n\n# Using SSLContext\ncontext = ssl.SSLContext()\n\n```\nBoth of the cases above should be updated to use a secure protocol instead, for instance by specifying `ssl_version=PROTOCOL_TLSv1_2` as a keyword argument.\n\nThe latter example can also be made secure by modifying the created context before it is used to create a connection. Therefore it will not be flagged by this query. However, if a connection is created before the context has been secured (for example, by setting the value of `minimum_version`), then the code should be flagged by the query `py/insecure-protocol`.\n\nNote that `ssl.wrap_socket` has been deprecated in Python 3.7. The recommended alternatives are:\n\n* `ssl.SSLContext` - supported in Python 2.7.9, 3.2, and later versions\n* `ssl.create_default_context` - a convenience function, supported in Python 3.4 and later versions.\nEven when you use these alternatives, you should ensure that a safe protocol is used. The following code illustrates how to use flags (available since Python 3.2) or the \\`minimum_version\\` field (favored since Python 3.7) to restrict the protocols accepted when creating a connection.\n\n\n```python\nimport ssl\n\n# Using flags to restrict the protocol\ncontext = ssl.SSLContext()\ncontext.options |= ssl.OP_NO_TLSv1 | ssl.OP_NO_TLSv1_1\n\n# Declaring a minimum version to restrict the protocol\ncontext = ssl.create_default_context()\ncontext.minimum_version = ssl.TLSVersion.TLSv1_2\n\n```\n\n## References\n* Wikipedia: [ Transport Layer Security](https://en.wikipedia.org/wiki/Transport_Layer_Security).\n* Python 3 documentation: [ class ssl.SSLContext](https://docs.python.org/3/library/ssl.html#ssl.SSLContext).\n* Python 3 documentation: [ ssl.wrap_socket](https://docs.python.org/3/library/ssl.html#ssl.wrap_socket).\n* Python 3 documentation: [ notes on context creation](https://docs.python.org/3/library/ssl.html#functions-constants-and-exceptions).\n* Python 3 documentation: [ notes on security considerations](https://docs.python.org/3/library/ssl.html#ssl-security).\n* Common Weakness Enumeration: [CWE-327](https://cwe.mitre.org/data/definitions/327.html).\n","markdown":"# Default version of SSL/TLS may be insecure\nThe `ssl.wrap_socket` function defaults to an insecure version of SSL/TLS when no specific protocol version is specified. This may leave the connection vulnerable to attack.\n\n\n## Recommendation\nEnsure that a modern, strong protocol is used. All versions of SSL, and TLS 1.0 and 1.1 are known to be vulnerable to attacks. Using TLS 1.2 or above is strongly recommended. If no explicit `ssl_version` is specified, the default `PROTOCOL_TLS` is chosen. This protocol is insecure because it allows TLS 1.0 and TLS 1.1 and so should not be used.\n\n\n## Example\nThe following code shows two different ways of setting up a connection using SSL or TLS. They are both potentially insecure because the default version is used.\n\n\n```python\nimport ssl\nimport socket\n\n# Using the deprecated ssl.wrap_socket method\nssl.wrap_socket(socket.socket())\n\n# Using SSLContext\ncontext = ssl.SSLContext()\n\n```\nBoth of the cases above should be updated to use a secure protocol instead, for instance by specifying `ssl_version=PROTOCOL_TLSv1_2` as a keyword argument.\n\nThe latter example can also be made secure by modifying the created context before it is used to create a connection. Therefore it will not be flagged by this query. However, if a connection is created before the context has been secured (for example, by setting the value of `minimum_version`), then the code should be flagged by the query `py/insecure-protocol`.\n\nNote that `ssl.wrap_socket` has been deprecated in Python 3.7. The recommended alternatives are:\n\n* `ssl.SSLContext` - supported in Python 2.7.9, 3.2, and later versions\n* `ssl.create_default_context` - a convenience function, supported in Python 3.4 and later versions.\nEven when you use these alternatives, you should ensure that a safe protocol is used. The following code illustrates how to use flags (available since Python 3.2) or the \\`minimum_version\\` field (favored since Python 3.7) to restrict the protocols accepted when creating a connection.\n\n\n```python\nimport ssl\n\n# Using flags to restrict the protocol\ncontext = ssl.SSLContext()\ncontext.options |= ssl.OP_NO_TLSv1 | ssl.OP_NO_TLSv1_1\n\n# Declaring a minimum version to restrict the protocol\ncontext = ssl.create_default_context()\ncontext.minimum_version = ssl.TLSVersion.TLSv1_2\n\n```\n\n## References\n* Wikipedia: [ Transport Layer Security](https://en.wikipedia.org/wiki/Transport_Layer_Security).\n* Python 3 documentation: [ class ssl.SSLContext](https://docs.python.org/3/library/ssl.html#ssl.SSLContext).\n* Python 3 documentation: [ ssl.wrap_socket](https://docs.python.org/3/library/ssl.html#ssl.wrap_socket).\n* Python 3 documentation: [ notes on context creation](https://docs.python.org/3/library/ssl.html#functions-constants-and-exceptions).\n* Python 3 documentation: [ notes on security considerations](https://docs.python.org/3/library/ssl.html#ssl-security).\n* Common Weakness Enumeration: [CWE-327](https://cwe.mitre.org/data/definitions/327.html).\n"},"properties":{"tags":["security","external/cwe/cwe-327"],"description":"Leaving the SSL/TLS version unspecified may result in an insecure\n              default protocol being used.","id":"py/insecure-default-protocol","kind":"problem","name":"Default version of SSL/TLS may be insecure","precision":"high","problem.severity":"warning","security-severity":"7.5"}},{"id":"py/weak-cryptographic-algorithm","name":"py/weak-cryptographic-algorithm","shortDescription":{"text":"Use of a broken or weak cryptographic algorithm"},"fullDescription":{"text":"Using broken or weak cryptographic algorithms can compromise security."},"defaultConfiguration":{"enabled":true,"level":"warning"},"help":{"text":"# Use of a broken or weak cryptographic algorithm\nUsing broken or weak cryptographic algorithms can leave data vulnerable to being decrypted or forged by an attacker.\n\nMany cryptographic algorithms provided by cryptography libraries are known to be weak, or flawed. Using such an algorithm means that encrypted or hashed data is less secure than it appears to be.\n\nThis query alerts on any use of a weak cryptographic algorithm, that is not a hashing algorithm. Use of broken or weak cryptographic hash functions are handled by the `py/weak-sensitive-data-hashing` query.\n\n\n## Recommendation\nEnsure that you use a strong, modern cryptographic algorithm, such as AES-128 or RSA-2048.\n\n\n## Example\nThe following code uses the `pycryptodome` library to encrypt some secret data. When you create a cipher using `pycryptodome` you must specify the encryption algorithm to use. The first example uses DES, which is an older algorithm that is now considered weak. The second example uses AES, which is a stronger modern algorithm.\n\n\n```python\nfrom Crypto.Cipher import DES, AES\n\ncipher = DES.new(SECRET_KEY)\n\ndef send_encrypted(channel, message):\n    channel.send(cipher.encrypt(message)) # BAD: weak encryption\n\n\ncipher = AES.new(SECRET_KEY)\n\ndef send_encrypted(channel, message):\n    channel.send(cipher.encrypt(message)) # GOOD: strong encryption\n\n\n```\nNOTICE: the original `[pycrypto](https://pypi.org/project/pycrypto/)` PyPI package that provided the `Crypto` module is not longer actively maintained, so you should use the `[pycryptodome](https://pypi.org/project/pycryptodome/)` PyPI package instead (which has a compatible API).\n\n\n## References\n* NIST, FIPS 140 Annex a: [ Approved Security Functions](http://csrc.nist.gov/publications/fips/fips140-2/fips1402annexa.pdf).\n* NIST, SP 800-131A: [ Transitions: Recommendation for Transitioning the Use of Cryptographic Algorithms and Key Lengths](http://nvlpubs.nist.gov/nistpubs/SpecialPublications/NIST.SP.800-131Ar1.pdf).\n* OWASP: [Rule - Use strong approved cryptographic algorithms](https://cheatsheetseries.owasp.org/cheatsheets/Cryptographic_Storage_Cheat_Sheet.html#rule---use-strong-approved-authenticated-encryption).\n* Common Weakness Enumeration: [CWE-327](https://cwe.mitre.org/data/definitions/327.html).\n","markdown":"# Use of a broken or weak cryptographic algorithm\nUsing broken or weak cryptographic algorithms can leave data vulnerable to being decrypted or forged by an attacker.\n\nMany cryptographic algorithms provided by cryptography libraries are known to be weak, or flawed. Using such an algorithm means that encrypted or hashed data is less secure than it appears to be.\n\nThis query alerts on any use of a weak cryptographic algorithm, that is not a hashing algorithm. Use of broken or weak cryptographic hash functions are handled by the `py/weak-sensitive-data-hashing` query.\n\n\n## Recommendation\nEnsure that you use a strong, modern cryptographic algorithm, such as AES-128 or RSA-2048.\n\n\n## Example\nThe following code uses the `pycryptodome` library to encrypt some secret data. When you create a cipher using `pycryptodome` you must specify the encryption algorithm to use. The first example uses DES, which is an older algorithm that is now considered weak. The second example uses AES, which is a stronger modern algorithm.\n\n\n```python\nfrom Crypto.Cipher import DES, AES\n\ncipher = DES.new(SECRET_KEY)\n\ndef send_encrypted(channel, message):\n    channel.send(cipher.encrypt(message)) # BAD: weak encryption\n\n\ncipher = AES.new(SECRET_KEY)\n\ndef send_encrypted(channel, message):\n    channel.send(cipher.encrypt(message)) # GOOD: strong encryption\n\n\n```\nNOTICE: the original `[pycrypto](https://pypi.org/project/pycrypto/)` PyPI package that provided the `Crypto` module is not longer actively maintained, so you should use the `[pycryptodome](https://pypi.org/project/pycryptodome/)` PyPI package instead (which has a compatible API).\n\n\n## References\n* NIST, FIPS 140 Annex a: [ Approved Security Functions](http://csrc.nist.gov/publications/fips/fips140-2/fips1402annexa.pdf).\n* NIST, SP 800-131A: [ Transitions: Recommendation for Transitioning the Use of Cryptographic Algorithms and Key Lengths](http://nvlpubs.nist.gov/nistpubs/SpecialPublications/NIST.SP.800-131Ar1.pdf).\n* OWASP: [Rule - Use strong approved cryptographic algorithms](https://cheatsheetseries.owasp.org/cheatsheets/Cryptographic_Storage_Cheat_Sheet.html#rule---use-strong-approved-authenticated-encryption).\n* Common Weakness Enumeration: [CWE-327](https://cwe.mitre.org/data/definitions/327.html).\n"},"properties":{"tags":["security","external/cwe/cwe-327"],"description":"Using broken or weak cryptographic algorithms can compromise security.","id":"py/weak-cryptographic-algorithm","kind":"problem","name":"Use of a broken or weak cryptographic algorithm","precision":"high","problem.severity":"warning","security-severity":"7.5"}},{"id":"py/template-injection","name":"py/template-injection","shortDescription":{"text":"Server Side Template Injection"},"fullDescription":{"text":"Using user-controlled data to create a template can lead to remote code execution or cross site scripting."},"defaultConfiguration":{"enabled":true,"level":"error"},"help":{"text":"# Server Side Template Injection\nA template from a server templating engine such as Jinja constructed from user input can allow the user to execute arbitrary code using certain template features. It can also allow for cross-site scripting.\n\n\n## Recommendation\nEnsure that an untrusted value is not used to directly construct a template. Jinja also provides `SandboxedEnvironment` that prohibits access to unsafe methods and attributes. This can be used if constructing a template from user input is absolutely necessary.\n\n\n## Example\nIn the following case, `template` is used to generate a Jinja2 template string. This can lead to remote code execution.\n\n\n```python\nfrom django.urls import path\nfrom django.http import HttpResponse\nfrom jinja2 import Template, escape\n\n\ndef a(request):\n    template = request.GET['template']\n\n    # BAD: Template is constructed from user input. \n    t = Template(template)\n\n    name = request.GET['name']\n    html = t.render(name=escape(name))\n    return HttpResponse(html)\n\n\nurlpatterns = [\n    path('a', a),\n]\n```\nThe following is an example of a string that could be used to cause remote code execution when interpreted as a template:\n\n\n```txt\n{% for s in ().__class__.__base__.__subclasses__() %}{% if \"warning\" in s.__name__ %}{{s()._module.__builtins__['__import__']('os').system('cat /etc/passwd') }}{% endif %}{% endfor %}\n\n```\nIn the following case, user input is not used to construct the template. Instead, it is only used as the parameters to render the template, which is safe.\n\n\n```python\nfrom django.urls import path\nfrom django.http import HttpResponse\nfrom jinja2 import Template, escape\n\n\ndef a(request):\n    # GOOD: Template is a constant, not constructed from user input\n    t = Template(\"Hello, {{name}}!\")\n\n    name = request.GET['name']\n    html = t.render(name=escape(name))\n    return HttpResponse(html)\n\n\nurlpatterns = [\n    path('a', a),\n]\n```\nIn the following case, a `SandboxedEnvironment` is used, preventing remote code execution.\n\n\n```python\nfrom django.urls import path\nfrom django.http import HttpResponse\nfrom jinja2 import escape\nfrom jinja2.sandbox import SandboxedEnvironment\n\n\ndef a(request):\n    env = SandboxedEnvironment()\n    template = request.GET['template']\n\n    # GOOD: A sandboxed environment is used to construct the template. \n    t = env.from_string(template)\n\n    name = request.GET['name']\n    html = t.render(name=escape(name))\n    return HttpResponse(html)\n\n\nurlpatterns = [\n    path('a', a),\n]\n```\n\n## References\n* Portswigger: [Server-Side Template Injection](https://portswigger.net/web-security/server-side-template-injection).\n* Common Weakness Enumeration: [CWE-74](https://cwe.mitre.org/data/definitions/74.html).\n","markdown":"# Server Side Template Injection\nA template from a server templating engine such as Jinja constructed from user input can allow the user to execute arbitrary code using certain template features. It can also allow for cross-site scripting.\n\n\n## Recommendation\nEnsure that an untrusted value is not used to directly construct a template. Jinja also provides `SandboxedEnvironment` that prohibits access to unsafe methods and attributes. This can be used if constructing a template from user input is absolutely necessary.\n\n\n## Example\nIn the following case, `template` is used to generate a Jinja2 template string. This can lead to remote code execution.\n\n\n```python\nfrom django.urls import path\nfrom django.http import HttpResponse\nfrom jinja2 import Template, escape\n\n\ndef a(request):\n    template = request.GET['template']\n\n    # BAD: Template is constructed from user input. \n    t = Template(template)\n\n    name = request.GET['name']\n    html = t.render(name=escape(name))\n    return HttpResponse(html)\n\n\nurlpatterns = [\n    path('a', a),\n]\n```\nThe following is an example of a string that could be used to cause remote code execution when interpreted as a template:\n\n\n```txt\n{% for s in ().__class__.__base__.__subclasses__() %}{% if \"warning\" in s.__name__ %}{{s()._module.__builtins__['__import__']('os').system('cat /etc/passwd') }}{% endif %}{% endfor %}\n\n```\nIn the following case, user input is not used to construct the template. Instead, it is only used as the parameters to render the template, which is safe.\n\n\n```python\nfrom django.urls import path\nfrom django.http import HttpResponse\nfrom jinja2 import Template, escape\n\n\ndef a(request):\n    # GOOD: Template is a constant, not constructed from user input\n    t = Template(\"Hello, {{name}}!\")\n\n    name = request.GET['name']\n    html = t.render(name=escape(name))\n    return HttpResponse(html)\n\n\nurlpatterns = [\n    path('a', a),\n]\n```\nIn the following case, a `SandboxedEnvironment` is used, preventing remote code execution.\n\n\n```python\nfrom django.urls import path\nfrom django.http import HttpResponse\nfrom jinja2 import escape\nfrom jinja2.sandbox import SandboxedEnvironment\n\n\ndef a(request):\n    env = SandboxedEnvironment()\n    template = request.GET['template']\n\n    # GOOD: A sandboxed environment is used to construct the template. \n    t = env.from_string(template)\n\n    name = request.GET['name']\n    html = t.render(name=escape(name))\n    return HttpResponse(html)\n\n\nurlpatterns = [\n    path('a', a),\n]\n```\n\n## References\n* Portswigger: [Server-Side Template Injection](https://portswigger.net/web-security/server-side-template-injection).\n* Common Weakness Enumeration: [CWE-74](https://cwe.mitre.org/data/definitions/74.html).\n"},"properties":{"tags":["security","external/cwe/cwe-074"],"description":"Using user-controlled data to create a template can lead to remote code execution or cross site scripting.","id":"py/template-injection","kind":"path-problem","name":"Server Side Template Injection","precision":"high","problem.severity":"error","security-severity":"9.3"}},{"id":"py/xpath-injection","name":"py/xpath-injection","shortDescription":{"text":"XPath query built from user-controlled sources"},"fullDescription":{"text":"Building a XPath query from user-controlled sources is vulnerable to insertion of malicious Xpath code by the user."},"defaultConfiguration":{"enabled":true,"level":"error"},"help":{"text":"# XPath query built from user-controlled sources\nIf an XPath expression is built using string concatenation, and the components of the concatenation include user input, it makes it very easy for a user to create a malicious XPath expression.\n\n\n## Recommendation\nIf user input must be included in an XPath expression, either sanitize the data or use variable references to safely embed it without altering the structure of the expression.\n\n\n## Example\nIn the example below, the xpath query is controlled by the user and hence leads to a vulnerability.\n\n\n```python\nfrom lxml import etree\nfrom io import StringIO\n\nfrom django.urls import path\nfrom django.http import HttpResponse\nfrom django.template import Template, Context, Engine, engines\n\n\ndef a(request):\n    value = request.GET['xpath']\n    f = StringIO('<foo><bar></bar></foo>')\n    tree = etree.parse(f)\n    r = tree.xpath(\"/tag[@id='%s']\" % value)\n\n\nurlpatterns = [\n    path('a', a)\n]\n\n```\nThis can be fixed by using a parameterized query as shown below.\n\n\n```python\nfrom lxml import etree\nfrom io import StringIO\n\nfrom django.urls import path\nfrom django.http import HttpResponse\nfrom django.template import Template, Context, Engine, engines\n\n\ndef a(request):\n    value = request.GET['xpath']\n    f = StringIO('<foo><bar></bar></foo>')\n    tree = etree.parse(f)\n    r = tree.xpath(\"/tag[@id=$tagid]\", tagid=value)\n\n\nurlpatterns = [\n    path('a', a)\n]\n\n```\n\n## References\n* OWASP XPath injection : [](https://owasp.org/www-community/attacks/XPATH_Injection)/&gt;&gt;\n* Common Weakness Enumeration: [CWE-643](https://cwe.mitre.org/data/definitions/643.html).\n","markdown":"# XPath query built from user-controlled sources\nIf an XPath expression is built using string concatenation, and the components of the concatenation include user input, it makes it very easy for a user to create a malicious XPath expression.\n\n\n## Recommendation\nIf user input must be included in an XPath expression, either sanitize the data or use variable references to safely embed it without altering the structure of the expression.\n\n\n## Example\nIn the example below, the xpath query is controlled by the user and hence leads to a vulnerability.\n\n\n```python\nfrom lxml import etree\nfrom io import StringIO\n\nfrom django.urls import path\nfrom django.http import HttpResponse\nfrom django.template import Template, Context, Engine, engines\n\n\ndef a(request):\n    value = request.GET['xpath']\n    f = StringIO('<foo><bar></bar></foo>')\n    tree = etree.parse(f)\n    r = tree.xpath(\"/tag[@id='%s']\" % value)\n\n\nurlpatterns = [\n    path('a', a)\n]\n\n```\nThis can be fixed by using a parameterized query as shown below.\n\n\n```python\nfrom lxml import etree\nfrom io import StringIO\n\nfrom django.urls import path\nfrom django.http import HttpResponse\nfrom django.template import Template, Context, Engine, engines\n\n\ndef a(request):\n    value = request.GET['xpath']\n    f = StringIO('<foo><bar></bar></foo>')\n    tree = etree.parse(f)\n    r = tree.xpath(\"/tag[@id=$tagid]\", tagid=value)\n\n\nurlpatterns = [\n    path('a', a)\n]\n\n```\n\n## References\n* OWASP XPath injection : [](https://owasp.org/www-community/attacks/XPATH_Injection)/&gt;&gt;\n* Common Weakness Enumeration: [CWE-643](https://cwe.mitre.org/data/definitions/643.html).\n"},"properties":{"tags":["security","external/cwe/cwe-643"],"description":"Building a XPath query from user-controlled sources is vulnerable to insertion of\n              malicious Xpath code by the user.","id":"py/xpath-injection","kind":"path-problem","name":"XPath query built from user-controlled sources","precision":"high","problem.severity":"error","security-severity":"9.8"}},{"id":"py/xml-bomb","name":"py/xml-bomb","shortDescription":{"text":"XML internal entity expansion"},"fullDescription":{"text":"Parsing user input as an XML document with arbitrary internal entity expansion is vulnerable to denial-of-service attacks."},"defaultConfiguration":{"enabled":true,"level":"warning"},"help":{"text":"# XML internal entity expansion\nParsing untrusted XML files with a weakly configured XML parser may be vulnerable to denial-of-service (DoS) attacks exploiting uncontrolled internal entity expansion.\n\nIn XML, so-called *internal entities* are a mechanism for introducing an abbreviation for a piece of text or part of a document. When a parser that has been configured to expand entities encounters a reference to an internal entity, it replaces the entity by the data it represents. The replacement text may itself contain other entity references, which are expanded recursively. This means that entity expansion can increase document size dramatically.\n\nIf untrusted XML is parsed with entity expansion enabled, a malicious attacker could submit a document that contains very deeply nested entity definitions, causing the parser to take a very long time or use large amounts of memory. This is sometimes called an *XML bomb* attack.\n\n\n## Recommendation\nThe safest way to prevent XML bomb attacks is to disable entity expansion when parsing untrusted data. Whether this can be done depends on the library being used. Note that some libraries, such as `lxml`, have measures enabled by default to prevent such DoS XML attacks, so unless you have explicitly set `huge_tree` to `True`, no further action is needed.\n\nWe recommend using the [defusedxml](https://pypi.org/project/defusedxml/) PyPI package, which has been created to prevent XML attacks (both XXE and XML bombs).\n\n\n## Example\nThe following example uses the `xml.etree` XML parser provided by the Python standard library to parse a string `xml_src`. That string is from an untrusted source, so this code is vulnerable to a DoS attack, since the `xml.etree` XML parser expands internal entities by default:\n\n\n```python\nfrom flask import Flask, request\nimport xml.etree.ElementTree as ET\n\napp = Flask(__name__)\n\n@app.post(\"/upload\")\ndef upload():\n    xml_src = request.get_data()\n    doc = ET.fromstring(xml_src)\n    return ET.tostring(doc)\n\n```\nIt is not possible to guard against internal entity expansion with `xml.etree`, so to guard against these attacks, the following example uses the [defusedxml](https://pypi.org/project/defusedxml/) PyPI package instead, which is not exposed to such internal entity expansion attacks.\n\n\n```python\nfrom flask import Flask, request\nimport defusedxml.ElementTree as ET\n\napp = Flask(__name__)\n\n@app.post(\"/upload\")\ndef upload():\n    xml_src = request.get_data()\n    doc = ET.fromstring(xml_src)\n    return ET.tostring(doc)\n\n```\n\n## References\n* Wikipedia: [Billion Laughs](https://en.wikipedia.org/wiki/Billion_laughs).\n* Bryan Sullivan: [Security Briefs - XML Denial of Service Attacks and Defenses](https://msdn.microsoft.com/en-us/magazine/ee335713.aspx).\n* Python 3 standard library: [XML Vulnerabilities](https://docs.python.org/3/library/xml.html#xml-vulnerabilities).\n* Python 2 standard library: [XML Vulnerabilities](https://docs.python.org/2/library/xml.html#xml-vulnerabilities).\n* Common Weakness Enumeration: [CWE-776](https://cwe.mitre.org/data/definitions/776.html).\n* Common Weakness Enumeration: [CWE-400](https://cwe.mitre.org/data/definitions/400.html).\n","markdown":"# XML internal entity expansion\nParsing untrusted XML files with a weakly configured XML parser may be vulnerable to denial-of-service (DoS) attacks exploiting uncontrolled internal entity expansion.\n\nIn XML, so-called *internal entities* are a mechanism for introducing an abbreviation for a piece of text or part of a document. When a parser that has been configured to expand entities encounters a reference to an internal entity, it replaces the entity by the data it represents. The replacement text may itself contain other entity references, which are expanded recursively. This means that entity expansion can increase document size dramatically.\n\nIf untrusted XML is parsed with entity expansion enabled, a malicious attacker could submit a document that contains very deeply nested entity definitions, causing the parser to take a very long time or use large amounts of memory. This is sometimes called an *XML bomb* attack.\n\n\n## Recommendation\nThe safest way to prevent XML bomb attacks is to disable entity expansion when parsing untrusted data. Whether this can be done depends on the library being used. Note that some libraries, such as `lxml`, have measures enabled by default to prevent such DoS XML attacks, so unless you have explicitly set `huge_tree` to `True`, no further action is needed.\n\nWe recommend using the [defusedxml](https://pypi.org/project/defusedxml/) PyPI package, which has been created to prevent XML attacks (both XXE and XML bombs).\n\n\n## Example\nThe following example uses the `xml.etree` XML parser provided by the Python standard library to parse a string `xml_src`. That string is from an untrusted source, so this code is vulnerable to a DoS attack, since the `xml.etree` XML parser expands internal entities by default:\n\n\n```python\nfrom flask import Flask, request\nimport xml.etree.ElementTree as ET\n\napp = Flask(__name__)\n\n@app.post(\"/upload\")\ndef upload():\n    xml_src = request.get_data()\n    doc = ET.fromstring(xml_src)\n    return ET.tostring(doc)\n\n```\nIt is not possible to guard against internal entity expansion with `xml.etree`, so to guard against these attacks, the following example uses the [defusedxml](https://pypi.org/project/defusedxml/) PyPI package instead, which is not exposed to such internal entity expansion attacks.\n\n\n```python\nfrom flask import Flask, request\nimport defusedxml.ElementTree as ET\n\napp = Flask(__name__)\n\n@app.post(\"/upload\")\ndef upload():\n    xml_src = request.get_data()\n    doc = ET.fromstring(xml_src)\n    return ET.tostring(doc)\n\n```\n\n## References\n* Wikipedia: [Billion Laughs](https://en.wikipedia.org/wiki/Billion_laughs).\n* Bryan Sullivan: [Security Briefs - XML Denial of Service Attacks and Defenses](https://msdn.microsoft.com/en-us/magazine/ee335713.aspx).\n* Python 3 standard library: [XML Vulnerabilities](https://docs.python.org/3/library/xml.html#xml-vulnerabilities).\n* Python 2 standard library: [XML Vulnerabilities](https://docs.python.org/2/library/xml.html#xml-vulnerabilities).\n* Common Weakness Enumeration: [CWE-776](https://cwe.mitre.org/data/definitions/776.html).\n* Common Weakness Enumeration: [CWE-400](https://cwe.mitre.org/data/definitions/400.html).\n"},"properties":{"tags":["security","external/cwe/cwe-776","external/cwe/cwe-400"],"description":"Parsing user input as an XML document with arbitrary internal\n              entity expansion is vulnerable to denial-of-service attacks.","id":"py/xml-bomb","kind":"path-problem","name":"XML internal entity expansion","precision":"high","problem.severity":"warning","security-severity":"7.5"}},{"id":"py/bind-socket-all-network-interfaces","name":"py/bind-socket-all-network-interfaces","shortDescription":{"text":"Binding a socket to all network interfaces"},"fullDescription":{"text":"Binding a socket to all interfaces opens it up to traffic from any IPv4 address and is therefore associated with security risks."},"defaultConfiguration":{"enabled":true,"level":"error"},"help":{"text":"# Binding a socket to all network interfaces\nSockets can be used to communicate with other machines on a network. You can use the (IP address, port) pair to define the access restrictions for the socket you create. When using the built-in Python `socket` module (for instance, when building a message sender service or an FTP server data transmitter), one has to bind the port to some interface. When you bind the port to all interfaces using `0.0.0.0` as the IP address, you essentially allow it to accept connections from any IPv4 address provided that it can get to the socket via routing. Binding to all interfaces is therefore associated with security risks.\n\n\n## Recommendation\nBind your service incoming traffic only to a dedicated interface. If you need to bind more than one interface using the built-in `socket` module, create multiple sockets (instead of binding to one socket to all interfaces).\n\n\n## Example\nIn this example, two sockets are insecure because they are bound to all interfaces; one through the `0.0.0.0` notation and another one through an empty string `''`.\n\n\n```python\nimport socket\n\n# binds to all interfaces, insecure\ns = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\ns.bind(('0.0.0.0', 31137))\n\n# binds to all interfaces, insecure\ns = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\ns.bind(('', 4040))\n\n# binds only to a dedicated interface, secure\ns = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\ns.bind(('84.68.10.12', 8080))\n\n```\n\n## References\n* Python reference: [ Socket families](https://docs.python.org/3/library/socket.html#socket-families).\n* Python reference: [ Socket Programming HOWTO](https://docs.python.org/3.7/howto/sockets.html).\n* Common Vulnerabilities and Exposures: [ CVE-2018-1281 Detail](https://nvd.nist.gov/vuln/detail/CVE-2018-1281).\n* Common Weakness Enumeration: [CWE-200](https://cwe.mitre.org/data/definitions/200.html).\n","markdown":"# Binding a socket to all network interfaces\nSockets can be used to communicate with other machines on a network. You can use the (IP address, port) pair to define the access restrictions for the socket you create. When using the built-in Python `socket` module (for instance, when building a message sender service or an FTP server data transmitter), one has to bind the port to some interface. When you bind the port to all interfaces using `0.0.0.0` as the IP address, you essentially allow it to accept connections from any IPv4 address provided that it can get to the socket via routing. Binding to all interfaces is therefore associated with security risks.\n\n\n## Recommendation\nBind your service incoming traffic only to a dedicated interface. If you need to bind more than one interface using the built-in `socket` module, create multiple sockets (instead of binding to one socket to all interfaces).\n\n\n## Example\nIn this example, two sockets are insecure because they are bound to all interfaces; one through the `0.0.0.0` notation and another one through an empty string `''`.\n\n\n```python\nimport socket\n\n# binds to all interfaces, insecure\ns = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\ns.bind(('0.0.0.0', 31137))\n\n# binds to all interfaces, insecure\ns = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\ns.bind(('', 4040))\n\n# binds only to a dedicated interface, secure\ns = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\ns.bind(('84.68.10.12', 8080))\n\n```\n\n## References\n* Python reference: [ Socket families](https://docs.python.org/3/library/socket.html#socket-families).\n* Python reference: [ Socket Programming HOWTO](https://docs.python.org/3.7/howto/sockets.html).\n* Common Vulnerabilities and Exposures: [ CVE-2018-1281 Detail](https://nvd.nist.gov/vuln/detail/CVE-2018-1281).\n* Common Weakness Enumeration: [CWE-200](https://cwe.mitre.org/data/definitions/200.html).\n"},"properties":{"tags":["security","external/cwe/cwe-200"],"description":"Binding a socket to all interfaces opens it up to traffic from any IPv4 address\n and is therefore associated with security risks.","id":"py/bind-socket-all-network-interfaces","kind":"problem","name":"Binding a socket to all network interfaces","precision":"high","problem.severity":"error","security-severity":"6.5","sub-severity":"low"}},{"id":"py/csrf-protection-disabled","name":"py/csrf-protection-disabled","shortDescription":{"text":"CSRF protection weakened or disabled"},"fullDescription":{"text":"Disabling or weakening CSRF protection may make the application vulnerable to a Cross-Site Request Forgery (CSRF) attack."},"defaultConfiguration":{"enabled":true,"level":"warning"},"help":{"text":"# CSRF protection weakened or disabled\nCross-site request forgery (CSRF) is a type of vulnerability in which an attacker is able to force a user to carry out an action that the user did not intend.\n\nThe attacker tricks an authenticated user into submitting a request to the web application. Typically this request will result in a state change on the server, such as changing the user's password. The request can be initiated when the user visits a site controlled by the attacker. If the web application relies only on cookies for authentication, or on other credentials that are automatically included in the request, then this request will appear as legitimate to the server.\n\nA common countermeasure for CSRF is to generate a unique token to be included in the HTML sent from the server to a user. This token can be used as a hidden field to be sent back with requests to the server, where the server can then check that the token is valid and associated with the relevant user session.\n\n\n## Recommendation\nIn many web frameworks, CSRF protection is enabled by default. In these cases, using the default configuration is sufficient to guard against most CSRF attacks.\n\n\n## Example\nThe following example shows a case where CSRF protection is disabled by overriding the default middleware stack and not including the one protecting against CSRF.\n\n\n```python\nMIDDLEWARE = [\n    'django.middleware.security.SecurityMiddleware',\n    'django.contrib.sessions.middleware.SessionMiddleware',\n    'django.middleware.common.CommonMiddleware',\n    # 'django.middleware.csrf.CsrfViewMiddleware',\n    'django.contrib.auth.middleware.AuthenticationMiddleware',\n    'django.contrib.messages.middleware.MessageMiddleware',\n    'django.middleware.clickjacking.XFrameOptionsMiddleware',\n]\n\n```\nThe protecting middleware was probably commented out during a testing phase, when server-side token generation was not set up. Simply commenting it back in will enable CSRF protection.\n\n\n## References\n* Wikipedia: [Cross-site request forgery](https://en.wikipedia.org/wiki/Cross-site_request_forgery)\n* OWASP: [Cross-site request forgery](https://owasp.org/www-community/attacks/csrf)\n* Common Weakness Enumeration: [CWE-352](https://cwe.mitre.org/data/definitions/352.html).\n","markdown":"# CSRF protection weakened or disabled\nCross-site request forgery (CSRF) is a type of vulnerability in which an attacker is able to force a user to carry out an action that the user did not intend.\n\nThe attacker tricks an authenticated user into submitting a request to the web application. Typically this request will result in a state change on the server, such as changing the user's password. The request can be initiated when the user visits a site controlled by the attacker. If the web application relies only on cookies for authentication, or on other credentials that are automatically included in the request, then this request will appear as legitimate to the server.\n\nA common countermeasure for CSRF is to generate a unique token to be included in the HTML sent from the server to a user. This token can be used as a hidden field to be sent back with requests to the server, where the server can then check that the token is valid and associated with the relevant user session.\n\n\n## Recommendation\nIn many web frameworks, CSRF protection is enabled by default. In these cases, using the default configuration is sufficient to guard against most CSRF attacks.\n\n\n## Example\nThe following example shows a case where CSRF protection is disabled by overriding the default middleware stack and not including the one protecting against CSRF.\n\n\n```python\nMIDDLEWARE = [\n    'django.middleware.security.SecurityMiddleware',\n    'django.contrib.sessions.middleware.SessionMiddleware',\n    'django.middleware.common.CommonMiddleware',\n    # 'django.middleware.csrf.CsrfViewMiddleware',\n    'django.contrib.auth.middleware.AuthenticationMiddleware',\n    'django.contrib.messages.middleware.MessageMiddleware',\n    'django.middleware.clickjacking.XFrameOptionsMiddleware',\n]\n\n```\nThe protecting middleware was probably commented out during a testing phase, when server-side token generation was not set up. Simply commenting it back in will enable CSRF protection.\n\n\n## References\n* Wikipedia: [Cross-site request forgery](https://en.wikipedia.org/wiki/Cross-site_request_forgery)\n* OWASP: [Cross-site request forgery](https://owasp.org/www-community/attacks/csrf)\n* Common Weakness Enumeration: [CWE-352](https://cwe.mitre.org/data/definitions/352.html).\n"},"properties":{"tags":["security","external/cwe/cwe-352"],"description":"Disabling or weakening CSRF protection may make the application\n              vulnerable to a Cross-Site Request Forgery (CSRF) attack.","id":"py/csrf-protection-disabled","kind":"problem","name":"CSRF protection weakened or disabled","precision":"high","problem.severity":"warning","security-severity":"8.8"}},{"id":"py/paramiko-missing-host-key-validation","name":"py/paramiko-missing-host-key-validation","shortDescription":{"text":"Accepting unknown SSH host keys when using Paramiko"},"fullDescription":{"text":"Accepting unknown host keys can allow man-in-the-middle attacks."},"defaultConfiguration":{"enabled":true,"level":"error"},"help":{"text":"# Accepting unknown SSH host keys when using Paramiko\nIn the Secure Shell (SSH) protocol, host keys are used to verify the identity of remote hosts. Accepting unknown host keys may leave the connection open to man-in-the-middle attacks.\n\n\n## Recommendation\nDo not accept unknown host keys. In particular, do not set the default missing host key policy for the Paramiko library to either `AutoAddPolicy` or `WarningPolicy`. Both of these policies continue even when the host key is unknown. The default setting of `RejectPolicy` is secure because it throws an exception when it encounters an unknown host key.\n\n\n## Example\nThe following example shows two ways of opening an SSH connection to `example.com`. The first function sets the missing host key policy to `AutoAddPolicy`. If the host key verification fails, the client will continue to interact with the server, even though the connection may be compromised. The second function sets the host key policy to `RejectPolicy`, and will throw an exception if the host key verification fails.\n\n\n```python\nfrom paramiko.client import SSHClient, AutoAddPolicy, RejectPolicy\n\ndef unsafe_connect():\n    client = SSHClient()\n    client.set_missing_host_key_policy(AutoAddPolicy)\n    client.connect(\"example.com\")\n\n    # ... interaction with server\n\n    client.close()\n\ndef safe_connect():\n    client = SSHClient()\n    client.set_missing_host_key_policy(RejectPolicy)\n    client.connect(\"example.com\")\n\n    # ... interaction with server\n\n    client.close()\n\n```\n\n## References\n* Paramiko documentation: [set_missing_host_key_policy](http://docs.paramiko.org/en/2.4/api/client.html?highlight=set_missing_host_key_policy#paramiko.client.SSHClient.set_missing_host_key_policy).\n* Common Weakness Enumeration: [CWE-295](https://cwe.mitre.org/data/definitions/295.html).\n","markdown":"# Accepting unknown SSH host keys when using Paramiko\nIn the Secure Shell (SSH) protocol, host keys are used to verify the identity of remote hosts. Accepting unknown host keys may leave the connection open to man-in-the-middle attacks.\n\n\n## Recommendation\nDo not accept unknown host keys. In particular, do not set the default missing host key policy for the Paramiko library to either `AutoAddPolicy` or `WarningPolicy`. Both of these policies continue even when the host key is unknown. The default setting of `RejectPolicy` is secure because it throws an exception when it encounters an unknown host key.\n\n\n## Example\nThe following example shows two ways of opening an SSH connection to `example.com`. The first function sets the missing host key policy to `AutoAddPolicy`. If the host key verification fails, the client will continue to interact with the server, even though the connection may be compromised. The second function sets the host key policy to `RejectPolicy`, and will throw an exception if the host key verification fails.\n\n\n```python\nfrom paramiko.client import SSHClient, AutoAddPolicy, RejectPolicy\n\ndef unsafe_connect():\n    client = SSHClient()\n    client.set_missing_host_key_policy(AutoAddPolicy)\n    client.connect(\"example.com\")\n\n    # ... interaction with server\n\n    client.close()\n\ndef safe_connect():\n    client = SSHClient()\n    client.set_missing_host_key_policy(RejectPolicy)\n    client.connect(\"example.com\")\n\n    # ... interaction with server\n\n    client.close()\n\n```\n\n## References\n* Paramiko documentation: [set_missing_host_key_policy](http://docs.paramiko.org/en/2.4/api/client.html?highlight=set_missing_host_key_policy#paramiko.client.SSHClient.set_missing_host_key_policy).\n* Common Weakness Enumeration: [CWE-295](https://cwe.mitre.org/data/definitions/295.html).\n"},"properties":{"tags":["security","external/cwe/cwe-295"],"description":"Accepting unknown host keys can allow man-in-the-middle attacks.","id":"py/paramiko-missing-host-key-validation","kind":"problem","name":"Accepting unknown SSH host keys when using Paramiko","precision":"high","problem.severity":"error","security-severity":"7.5"}},{"id":"py/code-injection","name":"py/code-injection","shortDescription":{"text":"Code injection"},"fullDescription":{"text":"Interpreting unsanitized user input as code allows a malicious user to perform arbitrary code execution."},"defaultConfiguration":{"enabled":true,"level":"error"},"help":{"text":"# Code injection\nDirectly evaluating user input (for example, an HTTP request parameter) as code without properly sanitizing the input first allows an attacker arbitrary code execution. This can occur when user input is passed to code that interprets it as an expression to be evaluated, such as `eval` or `exec`.\n\n\n## Recommendation\nAvoid including user input in any expression that may be dynamically evaluated. If user input must be included, use context-specific escaping before including it. It is important that the correct escaping is used for the type of evaluation that will occur.\n\n\n## Example\nThe following example shows two functions setting a name from a request. The first function uses `exec` to execute the `setname` function. This is dangerous as it can allow a malicious user to execute arbitrary code on the server. For example, the user could supply the value `\"' + subprocess.call('rm -rf') + '\"` to destroy the server's file system. The second function calls the `setname` function directly and is thus safe.\n\n\n```python\n\nurlpatterns = [\n    # Route to code_execution\n    url(r'^code-ex1$', code_execution_bad, name='code-execution-bad'),\n    url(r'^code-ex2$', code_execution_good, name='code-execution-good')\n]\n\ndef code_execution(request):\n    if request.method == 'POST':\n        first_name = base64.decodestring(request.POST.get('first_name', ''))\n        #BAD -- Allow user to define code to be run.\n        exec(\"setname('%s')\" % first_name)\n\ndef code_execution(request):\n    if request.method == 'POST':\n        first_name = base64.decodestring(request.POST.get('first_name', ''))\n        #GOOD --Call code directly\n        setname(first_name)\n\n```\n\n## References\n* OWASP: [Code Injection](https://www.owasp.org/index.php/Code_Injection).\n* Wikipedia: [Code Injection](https://en.wikipedia.org/wiki/Code_injection).\n* Common Weakness Enumeration: [CWE-94](https://cwe.mitre.org/data/definitions/94.html).\n* Common Weakness Enumeration: [CWE-95](https://cwe.mitre.org/data/definitions/95.html).\n* Common Weakness Enumeration: [CWE-116](https://cwe.mitre.org/data/definitions/116.html).\n","markdown":"# Code injection\nDirectly evaluating user input (for example, an HTTP request parameter) as code without properly sanitizing the input first allows an attacker arbitrary code execution. This can occur when user input is passed to code that interprets it as an expression to be evaluated, such as `eval` or `exec`.\n\n\n## Recommendation\nAvoid including user input in any expression that may be dynamically evaluated. If user input must be included, use context-specific escaping before including it. It is important that the correct escaping is used for the type of evaluation that will occur.\n\n\n## Example\nThe following example shows two functions setting a name from a request. The first function uses `exec` to execute the `setname` function. This is dangerous as it can allow a malicious user to execute arbitrary code on the server. For example, the user could supply the value `\"' + subprocess.call('rm -rf') + '\"` to destroy the server's file system. The second function calls the `setname` function directly and is thus safe.\n\n\n```python\n\nurlpatterns = [\n    # Route to code_execution\n    url(r'^code-ex1$', code_execution_bad, name='code-execution-bad'),\n    url(r'^code-ex2$', code_execution_good, name='code-execution-good')\n]\n\ndef code_execution(request):\n    if request.method == 'POST':\n        first_name = base64.decodestring(request.POST.get('first_name', ''))\n        #BAD -- Allow user to define code to be run.\n        exec(\"setname('%s')\" % first_name)\n\ndef code_execution(request):\n    if request.method == 'POST':\n        first_name = base64.decodestring(request.POST.get('first_name', ''))\n        #GOOD --Call code directly\n        setname(first_name)\n\n```\n\n## References\n* OWASP: [Code Injection](https://www.owasp.org/index.php/Code_Injection).\n* Wikipedia: [Code Injection](https://en.wikipedia.org/wiki/Code_injection).\n* Common Weakness Enumeration: [CWE-94](https://cwe.mitre.org/data/definitions/94.html).\n* Common Weakness Enumeration: [CWE-95](https://cwe.mitre.org/data/definitions/95.html).\n* Common Weakness Enumeration: [CWE-116](https://cwe.mitre.org/data/definitions/116.html).\n"},"properties":{"tags":["security","external/cwe/cwe-094","external/cwe/cwe-095","external/cwe/cwe-116"],"description":"Interpreting unsanitized user input as code allows a malicious user to perform arbitrary\n              code execution.","id":"py/code-injection","kind":"path-problem","name":"Code injection","precision":"high","problem.severity":"error","security-severity":"9.3","sub-severity":"high"}},{"id":"py/full-ssrf","name":"py/full-ssrf","shortDescription":{"text":"Full server-side request forgery"},"fullDescription":{"text":"Making a network request to a URL that is fully user-controlled allows for request forgery attacks."},"defaultConfiguration":{"enabled":true,"level":"error"},"help":{"text":"# Full server-side request forgery\nDirectly incorporating user input into an HTTP request without validating the input can facilitate server-side request forgery (SSRF) attacks. In these attacks, the request may be changed, directed at a different server, or via a different protocol. This can allow the attacker to obtain sensitive information or perform actions with escalated privilege.\n\nWe make a distinctions between how much of the URL an attacker can control:\n\n* **Full SSRF**: where the full URL can be controlled.\n* **Partial SSRF**: where only part of the URL can be controlled, such as the path component of a URL to a hardcoded domain.\n\n\nPartial control of a URL is often much harder to exploit. Therefore we have created a separate query for each of these.\n\nThis query covers full SSRF, to find partial SSRF use the `py/partial-ssrf` query.\n\n\n## Recommendation\nTo guard against SSRF attacks you should avoid putting user-provided input directly into a request URL. On the application level, maintain a list of authorized URLs on the server and choose from that list based on the input provided. If that is not possible, one should verify the IP address for all user-controlled requests to ensure they are not private. This requires saving the verified IP address of each domain, then utilizing a custom HTTP adapter to ensure that future requests to that domain use the verified IP address. On the network level, you can segment the vulnerable application into its own LAN or block access to specific devices.\n\n\n## Example\nThe following example shows code vulnerable to a full SSRF attack, because it uses untrusted input (HTTP request parameter) directly to construct a URL. By using `evil.com#` as the `target` value, the requested URL will be `https://evil.com#.example.com/data/`. It also shows how to remedy the problem by using the user input select a known fixed string.\n\n\n```python\nimport requests\nfrom flask import Flask, request\n\napp = Flask(__name__)\n\n@app.route(\"/full_ssrf\")\ndef full_ssrf():\n    target = request.args[\"target\"]\n\n    # BAD: user has full control of URL\n    resp = requests.get(\"https://\" + target + \".example.com/data/\")\n\n    # GOOD: `subdomain` is controlled by the server.\n    subdomain = \"europe\" if target == \"EU\" else \"world\"\n    resp = requests.get(\"https://\" + subdomain + \".example.com/data/\")\n\n```\n\n## Example\nThe following example shows code vulnerable to a partial SSRF attack, because it uses untrusted input (HTTP request parameter) directly to construct a URL. By using `../transfer-funds-to/123?amount=456` as the `user_id` value, the requested URL will be `https://api.example.com/transfer-funds-to/123?amount=456`. It also shows how to remedy the problem by validating the input.\n\n\n```python\nimport requests\nfrom flask import Flask, request\n\napp = Flask(__name__)\n\n@app.route(\"/partial_ssrf\")\ndef partial_ssrf():\n    user_id = request.args[\"user_id\"]\n\n    # BAD: user can fully control the path component of the URL\n    resp = requests.get(\"https://api.example.com/user_info/\" + user_id)\n\n    if user_id.isalnum():\n        # GOOD: user_id is restricted to be alpha-numeric, and cannot alter path component of URL\n        resp = requests.get(\"https://api.example.com/user_info/\" + user_id)\n\n```\n\n## References\n* [OWASP SSRF article](https://owasp.org/www-community/attacks/Server_Side_Request_Forgery)\n* [PortSwigger SSRF article](https://portswigger.net/web-security/ssrf)\n* Common Weakness Enumeration: [CWE-918](https://cwe.mitre.org/data/definitions/918.html).\n","markdown":"# Full server-side request forgery\nDirectly incorporating user input into an HTTP request without validating the input can facilitate server-side request forgery (SSRF) attacks. In these attacks, the request may be changed, directed at a different server, or via a different protocol. This can allow the attacker to obtain sensitive information or perform actions with escalated privilege.\n\nWe make a distinctions between how much of the URL an attacker can control:\n\n* **Full SSRF**: where the full URL can be controlled.\n* **Partial SSRF**: where only part of the URL can be controlled, such as the path component of a URL to a hardcoded domain.\n\n\nPartial control of a URL is often much harder to exploit. Therefore we have created a separate query for each of these.\n\nThis query covers full SSRF, to find partial SSRF use the `py/partial-ssrf` query.\n\n\n## Recommendation\nTo guard against SSRF attacks you should avoid putting user-provided input directly into a request URL. On the application level, maintain a list of authorized URLs on the server and choose from that list based on the input provided. If that is not possible, one should verify the IP address for all user-controlled requests to ensure they are not private. This requires saving the verified IP address of each domain, then utilizing a custom HTTP adapter to ensure that future requests to that domain use the verified IP address. On the network level, you can segment the vulnerable application into its own LAN or block access to specific devices.\n\n\n## Example\nThe following example shows code vulnerable to a full SSRF attack, because it uses untrusted input (HTTP request parameter) directly to construct a URL. By using `evil.com#` as the `target` value, the requested URL will be `https://evil.com#.example.com/data/`. It also shows how to remedy the problem by using the user input select a known fixed string.\n\n\n```python\nimport requests\nfrom flask import Flask, request\n\napp = Flask(__name__)\n\n@app.route(\"/full_ssrf\")\ndef full_ssrf():\n    target = request.args[\"target\"]\n\n    # BAD: user has full control of URL\n    resp = requests.get(\"https://\" + target + \".example.com/data/\")\n\n    # GOOD: `subdomain` is controlled by the server.\n    subdomain = \"europe\" if target == \"EU\" else \"world\"\n    resp = requests.get(\"https://\" + subdomain + \".example.com/data/\")\n\n```\n\n## Example\nThe following example shows code vulnerable to a partial SSRF attack, because it uses untrusted input (HTTP request parameter) directly to construct a URL. By using `../transfer-funds-to/123?amount=456` as the `user_id` value, the requested URL will be `https://api.example.com/transfer-funds-to/123?amount=456`. It also shows how to remedy the problem by validating the input.\n\n\n```python\nimport requests\nfrom flask import Flask, request\n\napp = Flask(__name__)\n\n@app.route(\"/partial_ssrf\")\ndef partial_ssrf():\n    user_id = request.args[\"user_id\"]\n\n    # BAD: user can fully control the path component of the URL\n    resp = requests.get(\"https://api.example.com/user_info/\" + user_id)\n\n    if user_id.isalnum():\n        # GOOD: user_id is restricted to be alpha-numeric, and cannot alter path component of URL\n        resp = requests.get(\"https://api.example.com/user_info/\" + user_id)\n\n```\n\n## References\n* [OWASP SSRF article](https://owasp.org/www-community/attacks/Server_Side_Request_Forgery)\n* [PortSwigger SSRF article](https://portswigger.net/web-security/ssrf)\n* Common Weakness Enumeration: [CWE-918](https://cwe.mitre.org/data/definitions/918.html).\n"},"properties":{"tags":["security","external/cwe/cwe-918"],"description":"Making a network request to a URL that is fully user-controlled allows for request forgery attacks.","id":"py/full-ssrf","kind":"path-problem","name":"Full server-side request forgery","precision":"high","problem.severity":"error","security-severity":"9.1"}},{"id":"py/polynomial-redos","name":"py/polynomial-redos","shortDescription":{"text":"Polynomial regular expression used on uncontrolled data"},"fullDescription":{"text":"A regular expression that can require polynomial time to match may be vulnerable to denial-of-service attacks."},"defaultConfiguration":{"enabled":true,"level":"warning"},"help":{"text":"# Polynomial regular expression used on uncontrolled data\nSome regular expressions take a long time to match certain input strings to the point where the time it takes to match a string of length *n* is proportional to *n<sup>k</sup>* or even *2<sup>n</sup>*. Such regular expressions can negatively affect performance, or even allow a malicious user to perform a Denial of Service (\"DoS\") attack by crafting an expensive input string for the regular expression to match.\n\nThe regular expression engine provided by Python uses a backtracking non-deterministic finite automata to implement regular expression matching. While this approach is space-efficient and allows supporting advanced features like capture groups, it is not time-efficient in general. The worst-case time complexity of such an automaton can be polynomial or even exponential, meaning that for strings of a certain shape, increasing the input length by ten characters may make the automaton about 1000 times slower.\n\nTypically, a regular expression is affected by this problem if it contains a repetition of the form `r*` or `r+` where the sub-expression `r` is ambiguous in the sense that it can match some string in multiple ways. More information about the precise circumstances can be found in the references.\n\n\n## Recommendation\nModify the regular expression to remove the ambiguity, or ensure that the strings matched with the regular expression are short enough that the time-complexity does not matter.\n\n\n## Example\nConsider this use of a regular expression, which removes all leading and trailing whitespace in a string:\n\n```python\n\nre.sub(r\"^\\s+|\\s+$\", \"\", text) # BAD\n```\nThe sub-expression `\"\\s+$\"` will match the whitespace characters in `text` from left to right, but it can start matching anywhere within a whitespace sequence. This is problematic for strings that do **not** end with a whitespace character. Such a string will force the regular expression engine to process each whitespace sequence once per whitespace character in the sequence.\n\nThis ultimately means that the time cost of trimming a string is quadratic in the length of the string. So a string like `\"a b\"` will take milliseconds to process, but a similar string with a million spaces instead of just one will take several minutes.\n\nAvoid this problem by rewriting the regular expression to not contain the ambiguity about when to start matching whitespace sequences. For instance, by using a negative look-behind (`^\\s+|(?<!\\s)\\s+$`), or just by using the built-in strip method (`text.strip()`).\n\nNote that the sub-expression `\"^\\s+\"` is **not** problematic as the `^` anchor restricts when that sub-expression can start matching, and as the regular expression engine matches from left to right.\n\n\n## Example\nAs a similar, but slightly subtler problem, consider the regular expression that matches lines with numbers, possibly written using scientific notation:\n\n```python\n\n^0\\.\\d+E?\\d+$ # BAD\n```\nThe problem with this regular expression is in the sub-expression `\\d+E?\\d+` because the second `\\d+` can start matching digits anywhere after the first match of the first `\\d+` if there is no `E` in the input string.\n\nThis is problematic for strings that do **not** end with a digit. Such a string will force the regular expression engine to process each digit sequence once per digit in the sequence, again leading to a quadratic time complexity.\n\nTo make the processing faster, the regular expression should be rewritten such that the two `\\d+` sub-expressions do not have overlapping matches: `^0\\.\\d+(E\\d+)?$`.\n\n\n## Example\nSometimes it is unclear how a regular expression can be rewritten to avoid the problem. In such cases, it often suffices to limit the length of the input string. For instance, the following regular expression is used to match numbers, and on some non-number inputs it can have quadratic time complexity:\n\n```python\n\nmatch = re.search(r'^(\\+|-)?(\\d+|(\\d*\\.\\d*))?(E|e)?([-+])?(\\d+)?$', str) \n```\nIt is not immediately obvious how to rewrite this regular expression to avoid the problem. However, you can mitigate performance issues by limiting the length to 1000 characters, which will always finish in a reasonable amount of time.\n\n```python\n\nif len(str) > 1000:\n    raise ValueError(\"Input too long\")\n\nmatch = re.search(r'^(\\+|-)?(\\d+|(\\d*\\.\\d*))?(E|e)?([-+])?(\\d+)?$', str) \n```\n\n## References\n* OWASP: [Regular expression Denial of Service - ReDoS](https://www.owasp.org/index.php/Regular_expression_Denial_of_Service_-_ReDoS).\n* Wikipedia: [ReDoS](https://en.wikipedia.org/wiki/ReDoS).\n* Wikipedia: [Time complexity](https://en.wikipedia.org/wiki/Time_complexity).\n* James Kirrage, Asiri Rathnayake, Hayo Thielecke: [Static Analysis for Regular Expression Denial-of-Service Attack](https://arxiv.org/abs/1301.0849).\n* Common Weakness Enumeration: [CWE-1333](https://cwe.mitre.org/data/definitions/1333.html).\n* Common Weakness Enumeration: [CWE-730](https://cwe.mitre.org/data/definitions/730.html).\n* Common Weakness Enumeration: [CWE-400](https://cwe.mitre.org/data/definitions/400.html).\n","markdown":"# Polynomial regular expression used on uncontrolled data\nSome regular expressions take a long time to match certain input strings to the point where the time it takes to match a string of length *n* is proportional to *n<sup>k</sup>* or even *2<sup>n</sup>*. Such regular expressions can negatively affect performance, or even allow a malicious user to perform a Denial of Service (\"DoS\") attack by crafting an expensive input string for the regular expression to match.\n\nThe regular expression engine provided by Python uses a backtracking non-deterministic finite automata to implement regular expression matching. While this approach is space-efficient and allows supporting advanced features like capture groups, it is not time-efficient in general. The worst-case time complexity of such an automaton can be polynomial or even exponential, meaning that for strings of a certain shape, increasing the input length by ten characters may make the automaton about 1000 times slower.\n\nTypically, a regular expression is affected by this problem if it contains a repetition of the form `r*` or `r+` where the sub-expression `r` is ambiguous in the sense that it can match some string in multiple ways. More information about the precise circumstances can be found in the references.\n\n\n## Recommendation\nModify the regular expression to remove the ambiguity, or ensure that the strings matched with the regular expression are short enough that the time-complexity does not matter.\n\n\n## Example\nConsider this use of a regular expression, which removes all leading and trailing whitespace in a string:\n\n```python\n\nre.sub(r\"^\\s+|\\s+$\", \"\", text) # BAD\n```\nThe sub-expression `\"\\s+$\"` will match the whitespace characters in `text` from left to right, but it can start matching anywhere within a whitespace sequence. This is problematic for strings that do **not** end with a whitespace character. Such a string will force the regular expression engine to process each whitespace sequence once per whitespace character in the sequence.\n\nThis ultimately means that the time cost of trimming a string is quadratic in the length of the string. So a string like `\"a b\"` will take milliseconds to process, but a similar string with a million spaces instead of just one will take several minutes.\n\nAvoid this problem by rewriting the regular expression to not contain the ambiguity about when to start matching whitespace sequences. For instance, by using a negative look-behind (`^\\s+|(?<!\\s)\\s+$`), or just by using the built-in strip method (`text.strip()`).\n\nNote that the sub-expression `\"^\\s+\"` is **not** problematic as the `^` anchor restricts when that sub-expression can start matching, and as the regular expression engine matches from left to right.\n\n\n## Example\nAs a similar, but slightly subtler problem, consider the regular expression that matches lines with numbers, possibly written using scientific notation:\n\n```python\n\n^0\\.\\d+E?\\d+$ # BAD\n```\nThe problem with this regular expression is in the sub-expression `\\d+E?\\d+` because the second `\\d+` can start matching digits anywhere after the first match of the first `\\d+` if there is no `E` in the input string.\n\nThis is problematic for strings that do **not** end with a digit. Such a string will force the regular expression engine to process each digit sequence once per digit in the sequence, again leading to a quadratic time complexity.\n\nTo make the processing faster, the regular expression should be rewritten such that the two `\\d+` sub-expressions do not have overlapping matches: `^0\\.\\d+(E\\d+)?$`.\n\n\n## Example\nSometimes it is unclear how a regular expression can be rewritten to avoid the problem. In such cases, it often suffices to limit the length of the input string. For instance, the following regular expression is used to match numbers, and on some non-number inputs it can have quadratic time complexity:\n\n```python\n\nmatch = re.search(r'^(\\+|-)?(\\d+|(\\d*\\.\\d*))?(E|e)?([-+])?(\\d+)?$', str) \n```\nIt is not immediately obvious how to rewrite this regular expression to avoid the problem. However, you can mitigate performance issues by limiting the length to 1000 characters, which will always finish in a reasonable amount of time.\n\n```python\n\nif len(str) > 1000:\n    raise ValueError(\"Input too long\")\n\nmatch = re.search(r'^(\\+|-)?(\\d+|(\\d*\\.\\d*))?(E|e)?([-+])?(\\d+)?$', str) \n```\n\n## References\n* OWASP: [Regular expression Denial of Service - ReDoS](https://www.owasp.org/index.php/Regular_expression_Denial_of_Service_-_ReDoS).\n* Wikipedia: [ReDoS](https://en.wikipedia.org/wiki/ReDoS).\n* Wikipedia: [Time complexity](https://en.wikipedia.org/wiki/Time_complexity).\n* James Kirrage, Asiri Rathnayake, Hayo Thielecke: [Static Analysis for Regular Expression Denial-of-Service Attack](https://arxiv.org/abs/1301.0849).\n* Common Weakness Enumeration: [CWE-1333](https://cwe.mitre.org/data/definitions/1333.html).\n* Common Weakness Enumeration: [CWE-730](https://cwe.mitre.org/data/definitions/730.html).\n* Common Weakness Enumeration: [CWE-400](https://cwe.mitre.org/data/definitions/400.html).\n"},"properties":{"tags":["security","external/cwe/cwe-1333","external/cwe/cwe-730","external/cwe/cwe-400"],"description":"A regular expression that can require polynomial time\n              to match may be vulnerable to denial-of-service attacks.","id":"py/polynomial-redos","kind":"path-problem","name":"Polynomial regular expression used on uncontrolled data","precision":"high","problem.severity":"warning","security-severity":"7.5"}},{"id":"py/regex-injection","name":"py/regex-injection","shortDescription":{"text":"Regular expression injection"},"fullDescription":{"text":"User input should not be used in regular expressions without first being escaped, otherwise a malicious user may be able to inject an expression that could require exponential time on certain inputs."},"defaultConfiguration":{"enabled":true,"level":"error"},"help":{"text":"# Regular expression injection\nConstructing a regular expression with unsanitized user input is dangerous as a malicious user may be able to modify the meaning of the expression. In particular, such a user may be able to provide a regular expression fragment that takes exponential time in the worst case, and use that to perform a Denial of Service attack.\n\n\n## Recommendation\nBefore embedding user input into a regular expression, use a sanitization function such as `re.escape` to escape meta-characters that have a special meaning regarding regular expressions' syntax.\n\n\n## Example\nThe following examples are based on a simple Flask web server environment.\n\nThe following example shows a HTTP request parameter that is used to construct a regular expression without sanitizing it first:\n\n\n```python\nfrom flask import request, Flask\nimport re\n\n\n@app.route(\"/direct\")\ndef direct():\n    unsafe_pattern = request.args[\"pattern\"]\n    re.search(unsafe_pattern, \"\")\n\n\n@app.route(\"/compile\")\ndef compile():\n    unsafe_pattern = request.args[\"pattern\"]\n    compiled_pattern = re.compile(unsafe_pattern)\n    compiled_pattern.search(\"\")\n\n```\nInstead, the request parameter should be sanitized first, for example using the function `re.escape`. This ensures that the user cannot insert characters which have a special meaning in regular expressions.\n\n\n```python\nfrom flask import request, Flask\nimport re\n\n\n@app.route(\"/direct\")\ndef direct():\n    unsafe_pattern = request.args['pattern']\n    safe_pattern = re.escape(unsafe_pattern)\n    re.search(safe_pattern, \"\")\n\n\n@app.route(\"/compile\")\ndef compile():\n    unsafe_pattern = request.args['pattern']\n    safe_pattern = re.escape(unsafe_pattern)\n    compiled_pattern = re.compile(safe_pattern)\n    compiled_pattern.search(\"\")\n\n```\n\n## References\n* OWASP: [Regular expression Denial of Service - ReDoS](https://www.owasp.org/index.php/Regular_expression_Denial_of_Service_-_ReDoS).\n* Wikipedia: [ReDoS](https://en.wikipedia.org/wiki/ReDoS).\n* Python docs: [re](https://docs.python.org/3/library/re.html).\n* SonarSource: [RSPEC-2631](https://rules.sonarsource.com/python/type/Vulnerability/RSPEC-2631).\n* Common Weakness Enumeration: [CWE-730](https://cwe.mitre.org/data/definitions/730.html).\n* Common Weakness Enumeration: [CWE-400](https://cwe.mitre.org/data/definitions/400.html).\n","markdown":"# Regular expression injection\nConstructing a regular expression with unsanitized user input is dangerous as a malicious user may be able to modify the meaning of the expression. In particular, such a user may be able to provide a regular expression fragment that takes exponential time in the worst case, and use that to perform a Denial of Service attack.\n\n\n## Recommendation\nBefore embedding user input into a regular expression, use a sanitization function such as `re.escape` to escape meta-characters that have a special meaning regarding regular expressions' syntax.\n\n\n## Example\nThe following examples are based on a simple Flask web server environment.\n\nThe following example shows a HTTP request parameter that is used to construct a regular expression without sanitizing it first:\n\n\n```python\nfrom flask import request, Flask\nimport re\n\n\n@app.route(\"/direct\")\ndef direct():\n    unsafe_pattern = request.args[\"pattern\"]\n    re.search(unsafe_pattern, \"\")\n\n\n@app.route(\"/compile\")\ndef compile():\n    unsafe_pattern = request.args[\"pattern\"]\n    compiled_pattern = re.compile(unsafe_pattern)\n    compiled_pattern.search(\"\")\n\n```\nInstead, the request parameter should be sanitized first, for example using the function `re.escape`. This ensures that the user cannot insert characters which have a special meaning in regular expressions.\n\n\n```python\nfrom flask import request, Flask\nimport re\n\n\n@app.route(\"/direct\")\ndef direct():\n    unsafe_pattern = request.args['pattern']\n    safe_pattern = re.escape(unsafe_pattern)\n    re.search(safe_pattern, \"\")\n\n\n@app.route(\"/compile\")\ndef compile():\n    unsafe_pattern = request.args['pattern']\n    safe_pattern = re.escape(unsafe_pattern)\n    compiled_pattern = re.compile(safe_pattern)\n    compiled_pattern.search(\"\")\n\n```\n\n## References\n* OWASP: [Regular expression Denial of Service - ReDoS](https://www.owasp.org/index.php/Regular_expression_Denial_of_Service_-_ReDoS).\n* Wikipedia: [ReDoS](https://en.wikipedia.org/wiki/ReDoS).\n* Python docs: [re](https://docs.python.org/3/library/re.html).\n* SonarSource: [RSPEC-2631](https://rules.sonarsource.com/python/type/Vulnerability/RSPEC-2631).\n* Common Weakness Enumeration: [CWE-730](https://cwe.mitre.org/data/definitions/730.html).\n* Common Weakness Enumeration: [CWE-400](https://cwe.mitre.org/data/definitions/400.html).\n"},"properties":{"tags":["security","external/cwe/cwe-730","external/cwe/cwe-400"],"description":"User input should not be used in regular expressions without first being escaped,\n              otherwise a malicious user may be able to inject an expression that could require\n              exponential time on certain inputs.","id":"py/regex-injection","kind":"path-problem","name":"Regular expression injection","precision":"high","problem.severity":"error","security-severity":"7.5"}},{"id":"py/redos","name":"py/redos","shortDescription":{"text":"Inefficient regular expression"},"fullDescription":{"text":"A regular expression that requires exponential time to match certain inputs can be a performance bottleneck, and may be vulnerable to denial-of-service attacks."},"defaultConfiguration":{"enabled":true,"level":"error"},"help":{"text":"# Inefficient regular expression\nSome regular expressions take a long time to match certain input strings to the point where the time it takes to match a string of length *n* is proportional to *n<sup>k</sup>* or even *2<sup>n</sup>*. Such regular expressions can negatively affect performance, or even allow a malicious user to perform a Denial of Service (\"DoS\") attack by crafting an expensive input string for the regular expression to match.\n\nThe regular expression engine provided by Python uses a backtracking non-deterministic finite automata to implement regular expression matching. While this approach is space-efficient and allows supporting advanced features like capture groups, it is not time-efficient in general. The worst-case time complexity of such an automaton can be polynomial or even exponential, meaning that for strings of a certain shape, increasing the input length by ten characters may make the automaton about 1000 times slower.\n\nTypically, a regular expression is affected by this problem if it contains a repetition of the form `r*` or `r+` where the sub-expression `r` is ambiguous in the sense that it can match some string in multiple ways. More information about the precise circumstances can be found in the references.\n\n\n## Recommendation\nModify the regular expression to remove the ambiguity, or ensure that the strings matched with the regular expression are short enough that the time-complexity does not matter.\n\n\n## Example\nConsider this regular expression:\n\n```python\n\n^_(__|.)+_$\n```\nIts sub-expression `\"(__|.)+?\"` can match the string `\"__\"` either by the first alternative `\"__\"` to the left of the `\"|\"` operator, or by two repetitions of the second alternative `\".\"` to the right. Thus, a string consisting of an odd number of underscores followed by some other character will cause the regular expression engine to run for an exponential amount of time before rejecting the input.\n\nThis problem can be avoided by rewriting the regular expression to remove the ambiguity between the two branches of the alternative inside the repetition:\n\n```python\n\n^_(__|[^_])+_$\n```\n\n## References\n* OWASP: [Regular expression Denial of Service - ReDoS](https://www.owasp.org/index.php/Regular_expression_Denial_of_Service_-_ReDoS).\n* Wikipedia: [ReDoS](https://en.wikipedia.org/wiki/ReDoS).\n* Wikipedia: [Time complexity](https://en.wikipedia.org/wiki/Time_complexity).\n* James Kirrage, Asiri Rathnayake, Hayo Thielecke: [Static Analysis for Regular Expression Denial-of-Service Attack](https://arxiv.org/abs/1301.0849).\n* Common Weakness Enumeration: [CWE-1333](https://cwe.mitre.org/data/definitions/1333.html).\n* Common Weakness Enumeration: [CWE-730](https://cwe.mitre.org/data/definitions/730.html).\n* Common Weakness Enumeration: [CWE-400](https://cwe.mitre.org/data/definitions/400.html).\n","markdown":"# Inefficient regular expression\nSome regular expressions take a long time to match certain input strings to the point where the time it takes to match a string of length *n* is proportional to *n<sup>k</sup>* or even *2<sup>n</sup>*. Such regular expressions can negatively affect performance, or even allow a malicious user to perform a Denial of Service (\"DoS\") attack by crafting an expensive input string for the regular expression to match.\n\nThe regular expression engine provided by Python uses a backtracking non-deterministic finite automata to implement regular expression matching. While this approach is space-efficient and allows supporting advanced features like capture groups, it is not time-efficient in general. The worst-case time complexity of such an automaton can be polynomial or even exponential, meaning that for strings of a certain shape, increasing the input length by ten characters may make the automaton about 1000 times slower.\n\nTypically, a regular expression is affected by this problem if it contains a repetition of the form `r*` or `r+` where the sub-expression `r` is ambiguous in the sense that it can match some string in multiple ways. More information about the precise circumstances can be found in the references.\n\n\n## Recommendation\nModify the regular expression to remove the ambiguity, or ensure that the strings matched with the regular expression are short enough that the time-complexity does not matter.\n\n\n## Example\nConsider this regular expression:\n\n```python\n\n^_(__|.)+_$\n```\nIts sub-expression `\"(__|.)+?\"` can match the string `\"__\"` either by the first alternative `\"__\"` to the left of the `\"|\"` operator, or by two repetitions of the second alternative `\".\"` to the right. Thus, a string consisting of an odd number of underscores followed by some other character will cause the regular expression engine to run for an exponential amount of time before rejecting the input.\n\nThis problem can be avoided by rewriting the regular expression to remove the ambiguity between the two branches of the alternative inside the repetition:\n\n```python\n\n^_(__|[^_])+_$\n```\n\n## References\n* OWASP: [Regular expression Denial of Service - ReDoS](https://www.owasp.org/index.php/Regular_expression_Denial_of_Service_-_ReDoS).\n* Wikipedia: [ReDoS](https://en.wikipedia.org/wiki/ReDoS).\n* Wikipedia: [Time complexity](https://en.wikipedia.org/wiki/Time_complexity).\n* James Kirrage, Asiri Rathnayake, Hayo Thielecke: [Static Analysis for Regular Expression Denial-of-Service Attack](https://arxiv.org/abs/1301.0849).\n* Common Weakness Enumeration: [CWE-1333](https://cwe.mitre.org/data/definitions/1333.html).\n* Common Weakness Enumeration: [CWE-730](https://cwe.mitre.org/data/definitions/730.html).\n* Common Weakness Enumeration: [CWE-400](https://cwe.mitre.org/data/definitions/400.html).\n"},"properties":{"tags":["security","external/cwe/cwe-1333","external/cwe/cwe-730","external/cwe/cwe-400"],"description":"A regular expression that requires exponential time to match certain inputs\n              can be a performance bottleneck, and may be vulnerable to denial-of-service\n              attacks.","id":"py/redos","kind":"problem","name":"Inefficient regular expression","precision":"high","problem.severity":"error","security-severity":"7.5"}},{"id":"py/unsafe-deserialization","name":"py/unsafe-deserialization","shortDescription":{"text":"Deserialization of user-controlled data"},"fullDescription":{"text":"Deserializing user-controlled data may allow attackers to execute arbitrary code."},"defaultConfiguration":{"enabled":true,"level":"error"},"help":{"text":"# Deserialization of user-controlled data\nDeserializing untrusted data using any deserialization framework that allows the construction of arbitrary serializable objects is easily exploitable and in many cases allows an attacker to execute arbitrary code. Even before a deserialized object is returned to the caller of a deserialization method a lot of code may have been executed, including static initializers, constructors, and finalizers. Automatic deserialization of fields means that an attacker may craft a nested combination of objects on which the executed initialization code may have unforeseen effects, such as the execution of arbitrary code.\n\nThere are many different serialization frameworks. This query currently supports Pickle, Marshal and Yaml.\n\n\n## Recommendation\nAvoid deserialization of untrusted data if at all possible. If the architecture permits it then use other formats instead of serialized objects, for example JSON.\n\nIf you need to use YAML, use the `yaml.safe_load` function.\n\n\n## Example\nThe following example calls `pickle.loads` directly on a value provided by an incoming HTTP request. Pickle then creates a new value from untrusted data, and is therefore inherently unsafe.\n\n\n```python\n\nfrom django.conf.urls import url\nimport pickle\n\ndef unsafe(pickled):\n    return pickle.loads(pickled)\n\nurlpatterns = [\n    url(r'^(?P<object>.*)$', unsafe)\n]\n```\nChanging the code to use `json.loads` instead of `pickle.loads` removes the vulnerability.\n\n\n```python\n\nfrom django.conf.urls import url\nimport json\n\ndef safe(pickled):\n    return json.loads(pickled)\n\nurlpatterns = [\n    url(r'^(?P<object>.*)$', safe)\n]\n\n```\n\n## References\n* OWASP vulnerability description: [Deserialization of untrusted data](https://www.owasp.org/index.php/Deserialization_of_untrusted_data).\n* OWASP guidance on deserializing objects: [Deserialization Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/Deserialization_Cheat_Sheet.html).\n* Talks by Chris Frohoff &amp; Gabriel Lawrence: [ AppSecCali 2015: Marshalling Pickles - how deserializing objects will ruin your day](http://frohoff.github.io/appseccali-marshalling-pickles/)\n* Common Weakness Enumeration: [CWE-502](https://cwe.mitre.org/data/definitions/502.html).\n","markdown":"# Deserialization of user-controlled data\nDeserializing untrusted data using any deserialization framework that allows the construction of arbitrary serializable objects is easily exploitable and in many cases allows an attacker to execute arbitrary code. Even before a deserialized object is returned to the caller of a deserialization method a lot of code may have been executed, including static initializers, constructors, and finalizers. Automatic deserialization of fields means that an attacker may craft a nested combination of objects on which the executed initialization code may have unforeseen effects, such as the execution of arbitrary code.\n\nThere are many different serialization frameworks. This query currently supports Pickle, Marshal and Yaml.\n\n\n## Recommendation\nAvoid deserialization of untrusted data if at all possible. If the architecture permits it then use other formats instead of serialized objects, for example JSON.\n\nIf you need to use YAML, use the `yaml.safe_load` function.\n\n\n## Example\nThe following example calls `pickle.loads` directly on a value provided by an incoming HTTP request. Pickle then creates a new value from untrusted data, and is therefore inherently unsafe.\n\n\n```python\n\nfrom django.conf.urls import url\nimport pickle\n\ndef unsafe(pickled):\n    return pickle.loads(pickled)\n\nurlpatterns = [\n    url(r'^(?P<object>.*)$', unsafe)\n]\n```\nChanging the code to use `json.loads` instead of `pickle.loads` removes the vulnerability.\n\n\n```python\n\nfrom django.conf.urls import url\nimport json\n\ndef safe(pickled):\n    return json.loads(pickled)\n\nurlpatterns = [\n    url(r'^(?P<object>.*)$', safe)\n]\n\n```\n\n## References\n* OWASP vulnerability description: [Deserialization of untrusted data](https://www.owasp.org/index.php/Deserialization_of_untrusted_data).\n* OWASP guidance on deserializing objects: [Deserialization Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/Deserialization_Cheat_Sheet.html).\n* Talks by Chris Frohoff &amp; Gabriel Lawrence: [ AppSecCali 2015: Marshalling Pickles - how deserializing objects will ruin your day](http://frohoff.github.io/appseccali-marshalling-pickles/)\n* Common Weakness Enumeration: [CWE-502](https://cwe.mitre.org/data/definitions/502.html).\n"},"properties":{"tags":["external/cwe/cwe-502","security","serialization"],"description":"Deserializing user-controlled data may allow attackers to execute arbitrary code.","id":"py/unsafe-deserialization","kind":"path-problem","name":"Deserialization of user-controlled data","precision":"high","problem.severity":"error","security-severity":"9.8","sub-severity":"high"}},{"id":"py/insecure-cookie","name":"py/insecure-cookie","shortDescription":{"text":"Failure to use secure cookies"},"fullDescription":{"text":"Insecure cookies may be sent in cleartext, which makes them vulnerable to interception."},"defaultConfiguration":{"enabled":true,"level":"warning"},"help":{"text":"# Failure to use secure cookies\nCookies without the `Secure` flag set may be transmitted using HTTP instead of HTTPS, which leaves them vulnerable to reading by a third party.\n\nCookies without the `HttpOnly` flag set are accessible to JavaScript running in the same origin. In case of a Cross-Site Scripting (XSS) vulnerability, the cookie can be stolen by a malicious script.\n\nCookies with the `SameSite` attribute set to `'None'` will be sent with cross-origin requests, which can be controlled by third-party JavaScript code and allow for Cross-Site Request Forgery (CSRF) attacks.\n\n\n## Recommendation\nAlways set `secure` to `True` or add \"; Secure;\" to the cookie's raw value.\n\nAlways set `httponly` to `True` or add \"; HttpOnly;\" to the cookie's raw value.\n\nAlways set `samesite` to `Lax` or `Strict`, or add \"; SameSite=Lax;\", or \"; Samesite=Strict;\" to the cookie's raw header value.\n\n\n## Example\nIn the following examples, the cases marked GOOD show secure cookie attributes being set; whereas in the cases marked BAD they are not set.\n\n\n```python\nfrom flask import Flask, request, make_response, Response\n\n\n@app.route(\"/good1\")\ndef good1():\n    resp = make_response()\n    resp.set_cookie(\"name\", value=\"value\", secure=True, httponly=True, samesite='Strict') # GOOD: Attributes are securely set\n    return resp\n\n\n@app.route(\"/good2\")\ndef good2():\n    resp = make_response()\n    resp.headers['Set-Cookie'] = \"name=value; Secure; HttpOnly; SameSite=Strict\" # GOOD: Attributes are securely set \n    return resp\n\n@app.route(\"/bad1\")\n    resp = make_response()\n    resp.set_cookie(\"name\", value=\"value\", samesite='None') # BAD: the SameSite attribute is set to 'None' and the 'Secure' and 'HttpOnly' attributes are set to False by default.\n    return resp\n```\n\n## References\n* Detectify: [Cookie lack Secure flag](https://support.detectify.com/support/solutions/articles/48001048982-cookie-lack-secure-flag).\n* PortSwigger: [TLS cookie without secure flag set](https://portswigger.net/kb/issues/00500200_tls-cookie-without-secure-flag-set).\n* Common Weakness Enumeration: [CWE-614](https://cwe.mitre.org/data/definitions/614.html).\n* Common Weakness Enumeration: [CWE-1004](https://cwe.mitre.org/data/definitions/1004.html).\n* Common Weakness Enumeration: [CWE-1275](https://cwe.mitre.org/data/definitions/1275.html).\n","markdown":"# Failure to use secure cookies\nCookies without the `Secure` flag set may be transmitted using HTTP instead of HTTPS, which leaves them vulnerable to reading by a third party.\n\nCookies without the `HttpOnly` flag set are accessible to JavaScript running in the same origin. In case of a Cross-Site Scripting (XSS) vulnerability, the cookie can be stolen by a malicious script.\n\nCookies with the `SameSite` attribute set to `'None'` will be sent with cross-origin requests, which can be controlled by third-party JavaScript code and allow for Cross-Site Request Forgery (CSRF) attacks.\n\n\n## Recommendation\nAlways set `secure` to `True` or add \"; Secure;\" to the cookie's raw value.\n\nAlways set `httponly` to `True` or add \"; HttpOnly;\" to the cookie's raw value.\n\nAlways set `samesite` to `Lax` or `Strict`, or add \"; SameSite=Lax;\", or \"; Samesite=Strict;\" to the cookie's raw header value.\n\n\n## Example\nIn the following examples, the cases marked GOOD show secure cookie attributes being set; whereas in the cases marked BAD they are not set.\n\n\n```python\nfrom flask import Flask, request, make_response, Response\n\n\n@app.route(\"/good1\")\ndef good1():\n    resp = make_response()\n    resp.set_cookie(\"name\", value=\"value\", secure=True, httponly=True, samesite='Strict') # GOOD: Attributes are securely set\n    return resp\n\n\n@app.route(\"/good2\")\ndef good2():\n    resp = make_response()\n    resp.headers['Set-Cookie'] = \"name=value; Secure; HttpOnly; SameSite=Strict\" # GOOD: Attributes are securely set \n    return resp\n\n@app.route(\"/bad1\")\n    resp = make_response()\n    resp.set_cookie(\"name\", value=\"value\", samesite='None') # BAD: the SameSite attribute is set to 'None' and the 'Secure' and 'HttpOnly' attributes are set to False by default.\n    return resp\n```\n\n## References\n* Detectify: [Cookie lack Secure flag](https://support.detectify.com/support/solutions/articles/48001048982-cookie-lack-secure-flag).\n* PortSwigger: [TLS cookie without secure flag set](https://portswigger.net/kb/issues/00500200_tls-cookie-without-secure-flag-set).\n* Common Weakness Enumeration: [CWE-614](https://cwe.mitre.org/data/definitions/614.html).\n* Common Weakness Enumeration: [CWE-1004](https://cwe.mitre.org/data/definitions/1004.html).\n* Common Weakness Enumeration: [CWE-1275](https://cwe.mitre.org/data/definitions/1275.html).\n"},"properties":{"tags":["security","external/cwe/cwe-614","external/cwe/cwe-1004","external/cwe/cwe-1275"],"description":"Insecure cookies may be sent in cleartext, which makes them vulnerable to\n              interception.","id":"py/insecure-cookie","kind":"problem","name":"Failure to use secure cookies","precision":"high","problem.severity":"warning","security-severity":"5.0"}},{"id":"py/command-line-injection","name":"py/command-line-injection","shortDescription":{"text":"Uncontrolled command line"},"fullDescription":{"text":"Using externally controlled strings in a command line may allow a malicious user to change the meaning of the command."},"defaultConfiguration":{"enabled":true,"level":"error"},"help":{"text":"# Uncontrolled command line\nCode that passes user input directly to `exec`, `eval`, or some other library routine that executes a command, allows the user to execute malicious code.\n\n\n## Recommendation\nIf possible, use hard-coded string literals to specify the command to run or the library to load. Instead of passing the user input directly to the process or library function, examine the user input and then choose among hard-coded string literals.\n\nIf the applicable libraries or commands cannot be determined at compile time, then add code to verify that the user input string is safe before using it.\n\n\n## Example\nThe following example shows two functions. The first is unsafe as it takes a shell script that can be changed by a user, and passes it straight to `subprocess.call()` without examining it first. The second is safe as it selects the command from a predefined allowlist.\n\n\n```python\n\nurlpatterns = [\n    # Route to command_execution\n    url(r'^command-ex1$', command_execution_unsafe, name='command-execution-unsafe'),\n    url(r'^command-ex2$', command_execution_safe, name='command-execution-safe')\n]\n\nCOMMANDS = {\n    \"list\" :\"ls\",\n    \"stat\" : \"stat\"\n}\n\ndef command_execution_unsafe(request):\n    if request.method == 'POST':\n        action = request.POST.get('action', '')\n        #BAD -- No sanitizing of input\n        subprocess.call([\"application\", action])\n\ndef command_execution_safe(request):\n    if request.method == 'POST':\n        action = request.POST.get('action', '')\n        #GOOD -- Use an allowlist\n        subprocess.call([\"application\", COMMANDS[action]])\n\n```\n\n## References\n* OWASP: [Command Injection](https://www.owasp.org/index.php/Command_Injection).\n* Common Weakness Enumeration: [CWE-78](https://cwe.mitre.org/data/definitions/78.html).\n* Common Weakness Enumeration: [CWE-88](https://cwe.mitre.org/data/definitions/88.html).\n","markdown":"# Uncontrolled command line\nCode that passes user input directly to `exec`, `eval`, or some other library routine that executes a command, allows the user to execute malicious code.\n\n\n## Recommendation\nIf possible, use hard-coded string literals to specify the command to run or the library to load. Instead of passing the user input directly to the process or library function, examine the user input and then choose among hard-coded string literals.\n\nIf the applicable libraries or commands cannot be determined at compile time, then add code to verify that the user input string is safe before using it.\n\n\n## Example\nThe following example shows two functions. The first is unsafe as it takes a shell script that can be changed by a user, and passes it straight to `subprocess.call()` without examining it first. The second is safe as it selects the command from a predefined allowlist.\n\n\n```python\n\nurlpatterns = [\n    # Route to command_execution\n    url(r'^command-ex1$', command_execution_unsafe, name='command-execution-unsafe'),\n    url(r'^command-ex2$', command_execution_safe, name='command-execution-safe')\n]\n\nCOMMANDS = {\n    \"list\" :\"ls\",\n    \"stat\" : \"stat\"\n}\n\ndef command_execution_unsafe(request):\n    if request.method == 'POST':\n        action = request.POST.get('action', '')\n        #BAD -- No sanitizing of input\n        subprocess.call([\"application\", action])\n\ndef command_execution_safe(request):\n    if request.method == 'POST':\n        action = request.POST.get('action', '')\n        #GOOD -- Use an allowlist\n        subprocess.call([\"application\", COMMANDS[action]])\n\n```\n\n## References\n* OWASP: [Command Injection](https://www.owasp.org/index.php/Command_Injection).\n* Common Weakness Enumeration: [CWE-78](https://cwe.mitre.org/data/definitions/78.html).\n* Common Weakness Enumeration: [CWE-88](https://cwe.mitre.org/data/definitions/88.html).\n"},"properties":{"tags":["correctness","security","external/cwe/cwe-078","external/cwe/cwe-088"],"description":"Using externally controlled strings in a command line may allow a malicious\n              user to change the meaning of the command.","id":"py/command-line-injection","kind":"path-problem","name":"Uncontrolled command line","precision":"high","problem.severity":"error","security-severity":"9.8","sub-severity":"high"}},{"id":"py/clear-text-storage-sensitive-data","name":"py/clear-text-storage-sensitive-data","shortDescription":{"text":"Clear-text storage of sensitive information"},"fullDescription":{"text":"Sensitive information stored without encryption or hashing can expose it to an attacker."},"defaultConfiguration":{"enabled":true,"level":"error"},"help":{"text":"# Clear-text storage of sensitive information\nSensitive information that is stored unencrypted is accessible to an attacker who gains access to the storage. This is particularly important for cookies, which are stored on the machine of the end-user.\n\n\n## Recommendation\nEnsure that sensitive information is always encrypted before being stored. If possible, avoid placing sensitive information in cookies altogether. Instead, prefer storing, in the cookie, a key that can be used to look up the sensitive information.\n\nIn general, decrypt sensitive information only at the point where it is necessary for it to be used in cleartext.\n\nBe aware that external processes often store the `standard out` and `standard error` streams of the application, causing logged sensitive information to be stored as well.\n\n\n## Example\nThe following example code stores user credentials (in this case, their password) in a cookie in plain text:\n\n\n```python\nfrom flask import Flask, make_response, request\n\napp = Flask(\"Leak password\")\n\n@app.route('/')\ndef index():\n    password = request.args.get(\"password\")\n    resp = make_response(render_template(...))\n    resp.set_cookie(\"password\", password)\n    return resp\n\n```\nInstead, the credentials should be encrypted, for instance by using the `cryptography` module, or not stored at all.\n\n\n## References\n* M. Dowd, J. McDonald and J. Schuhm, *The Art of Software Security Assessment*, 1st Edition, Chapter 2 - 'Common Vulnerabilities of Encryption', p. 43. Addison Wesley, 2006.\n* M. Howard and D. LeBlanc, *Writing Secure Code*, 2nd Edition, Chapter 9 - 'Protecting Secret Data', p. 299. Microsoft, 2002.\n* Common Weakness Enumeration: [CWE-312](https://cwe.mitre.org/data/definitions/312.html).\n* Common Weakness Enumeration: [CWE-315](https://cwe.mitre.org/data/definitions/315.html).\n* Common Weakness Enumeration: [CWE-359](https://cwe.mitre.org/data/definitions/359.html).\n","markdown":"# Clear-text storage of sensitive information\nSensitive information that is stored unencrypted is accessible to an attacker who gains access to the storage. This is particularly important for cookies, which are stored on the machine of the end-user.\n\n\n## Recommendation\nEnsure that sensitive information is always encrypted before being stored. If possible, avoid placing sensitive information in cookies altogether. Instead, prefer storing, in the cookie, a key that can be used to look up the sensitive information.\n\nIn general, decrypt sensitive information only at the point where it is necessary for it to be used in cleartext.\n\nBe aware that external processes often store the `standard out` and `standard error` streams of the application, causing logged sensitive information to be stored as well.\n\n\n## Example\nThe following example code stores user credentials (in this case, their password) in a cookie in plain text:\n\n\n```python\nfrom flask import Flask, make_response, request\n\napp = Flask(\"Leak password\")\n\n@app.route('/')\ndef index():\n    password = request.args.get(\"password\")\n    resp = make_response(render_template(...))\n    resp.set_cookie(\"password\", password)\n    return resp\n\n```\nInstead, the credentials should be encrypted, for instance by using the `cryptography` module, or not stored at all.\n\n\n## References\n* M. Dowd, J. McDonald and J. Schuhm, *The Art of Software Security Assessment*, 1st Edition, Chapter 2 - 'Common Vulnerabilities of Encryption', p. 43. Addison Wesley, 2006.\n* M. Howard and D. LeBlanc, *Writing Secure Code*, 2nd Edition, Chapter 9 - 'Protecting Secret Data', p. 299. Microsoft, 2002.\n* Common Weakness Enumeration: [CWE-312](https://cwe.mitre.org/data/definitions/312.html).\n* Common Weakness Enumeration: [CWE-315](https://cwe.mitre.org/data/definitions/315.html).\n* Common Weakness Enumeration: [CWE-359](https://cwe.mitre.org/data/definitions/359.html).\n"},"properties":{"tags":["security","external/cwe/cwe-312","external/cwe/cwe-315","external/cwe/cwe-359"],"description":"Sensitive information stored without encryption or hashing can expose it to an\n              attacker.","id":"py/clear-text-storage-sensitive-data","kind":"path-problem","name":"Clear-text storage of sensitive information","precision":"high","problem.severity":"error","security-severity":"7.5"}},{"id":"py/clear-text-logging-sensitive-data","name":"py/clear-text-logging-sensitive-data","shortDescription":{"text":"Clear-text logging of sensitive information"},"fullDescription":{"text":"Logging sensitive information without encryption or hashing can expose it to an attacker."},"defaultConfiguration":{"enabled":true,"level":"error"},"help":{"text":"# Clear-text logging of sensitive information\nIf sensitive data is written to a log entry it could be exposed to an attacker who gains access to the logs.\n\nPotential attackers can obtain sensitive user data when the log output is displayed. Additionally that data may expose system information such as full path names, system information, and sometimes usernames and passwords.\n\n\n## Recommendation\nSensitive data should not be logged.\n\n\n## Example\nIn the example the entire process environment is logged using \\`print\\`. Regular users of the production deployed application should not have access to this much information about the environment configuration.\n\n\n```python\n# BAD: Logging cleartext sensitive data\nimport os\nprint(f\"[INFO] Environment: {os.environ}\")\n```\nIn the second example the data that is logged is not sensitive.\n\n\n```python\nnot_sensitive_data = {'a': 1, 'b': 2}\n# GOOD: it is fine to log data that is not sensitive\nprint(f\"[INFO] Some object contains: {not_sensitive_data}\")\n```\n\n## References\n* OWASP: [Insertion of Sensitive Information into Log File](https://owasp.org/Top10/A09_2021-Security_Logging_and_Monitoring_Failures/).\n* Common Weakness Enumeration: [CWE-312](https://cwe.mitre.org/data/definitions/312.html).\n* Common Weakness Enumeration: [CWE-359](https://cwe.mitre.org/data/definitions/359.html).\n* Common Weakness Enumeration: [CWE-532](https://cwe.mitre.org/data/definitions/532.html).\n","markdown":"# Clear-text logging of sensitive information\nIf sensitive data is written to a log entry it could be exposed to an attacker who gains access to the logs.\n\nPotential attackers can obtain sensitive user data when the log output is displayed. Additionally that data may expose system information such as full path names, system information, and sometimes usernames and passwords.\n\n\n## Recommendation\nSensitive data should not be logged.\n\n\n## Example\nIn the example the entire process environment is logged using \\`print\\`. Regular users of the production deployed application should not have access to this much information about the environment configuration.\n\n\n```python\n# BAD: Logging cleartext sensitive data\nimport os\nprint(f\"[INFO] Environment: {os.environ}\")\n```\nIn the second example the data that is logged is not sensitive.\n\n\n```python\nnot_sensitive_data = {'a': 1, 'b': 2}\n# GOOD: it is fine to log data that is not sensitive\nprint(f\"[INFO] Some object contains: {not_sensitive_data}\")\n```\n\n## References\n* OWASP: [Insertion of Sensitive Information into Log File](https://owasp.org/Top10/A09_2021-Security_Logging_and_Monitoring_Failures/).\n* Common Weakness Enumeration: [CWE-312](https://cwe.mitre.org/data/definitions/312.html).\n* Common Weakness Enumeration: [CWE-359](https://cwe.mitre.org/data/definitions/359.html).\n* Common Weakness Enumeration: [CWE-532](https://cwe.mitre.org/data/definitions/532.html).\n"},"properties":{"tags":["security","external/cwe/cwe-312","external/cwe/cwe-359","external/cwe/cwe-532"],"description":"Logging sensitive information without encryption or hashing can\n              expose it to an attacker.","id":"py/clear-text-logging-sensitive-data","kind":"path-problem","name":"Clear-text logging of sensitive information","precision":"high","problem.severity":"error","security-severity":"7.5"}},{"id":"py/weak-crypto-key","name":"py/weak-crypto-key","shortDescription":{"text":"Use of weak cryptographic key"},"fullDescription":{"text":"Use of a cryptographic key that is too small may allow the encryption to be broken."},"defaultConfiguration":{"enabled":true,"level":"error"},"help":{"text":"# Use of weak cryptographic key\nModern encryption relies on it being computationally infeasible to break the cipher and decode a message without the key. As computational power increases, the ability to break ciphers grows and keys need to become larger.\n\nThe three main asymmetric key algorithms currently in use are Rivest–Shamir–Adleman (RSA) cryptography, Digital Signature Algorithm (DSA), and Elliptic-curve cryptography (ECC). With current technology, key sizes of 2048 bits for RSA and DSA, or 256 bits for ECC, are regarded as unbreakable.\n\n\n## Recommendation\nIncrease the key size to the recommended amount or larger. For RSA or DSA this is at least 2048 bits, for ECC this is at least 256 bits.\n\n\n## References\n* Wikipedia: [Digital Signature Algorithm](https://en.wikipedia.org/wiki/Digital_Signature_Algorithm).\n* Wikipedia: [RSA cryptosystem](https://en.wikipedia.org/wiki/RSA_(cryptosystem)).\n* Wikipedia: [Elliptic-curve cryptography](https://en.wikipedia.org/wiki/Elliptic-curve_cryptography).\n* Python cryptography module: [cryptography.io](https://cryptography.io/en/latest/).\n* NIST: [ Recommendation for Transitioning the Use of Cryptographic Algorithms and Key Lengths](https://nvlpubs.nist.gov/nistpubs/SpecialPublications/NIST.SP.800-131Ar1.pdf).\n* Common Weakness Enumeration: [CWE-326](https://cwe.mitre.org/data/definitions/326.html).\n","markdown":"# Use of weak cryptographic key\nModern encryption relies on it being computationally infeasible to break the cipher and decode a message without the key. As computational power increases, the ability to break ciphers grows and keys need to become larger.\n\nThe three main asymmetric key algorithms currently in use are Rivest–Shamir–Adleman (RSA) cryptography, Digital Signature Algorithm (DSA), and Elliptic-curve cryptography (ECC). With current technology, key sizes of 2048 bits for RSA and DSA, or 256 bits for ECC, are regarded as unbreakable.\n\n\n## Recommendation\nIncrease the key size to the recommended amount or larger. For RSA or DSA this is at least 2048 bits, for ECC this is at least 256 bits.\n\n\n## References\n* Wikipedia: [Digital Signature Algorithm](https://en.wikipedia.org/wiki/Digital_Signature_Algorithm).\n* Wikipedia: [RSA cryptosystem](https://en.wikipedia.org/wiki/RSA_(cryptosystem)).\n* Wikipedia: [Elliptic-curve cryptography](https://en.wikipedia.org/wiki/Elliptic-curve_cryptography).\n* Python cryptography module: [cryptography.io](https://cryptography.io/en/latest/).\n* NIST: [ Recommendation for Transitioning the Use of Cryptographic Algorithms and Key Lengths](https://nvlpubs.nist.gov/nistpubs/SpecialPublications/NIST.SP.800-131Ar1.pdf).\n* Common Weakness Enumeration: [CWE-326](https://cwe.mitre.org/data/definitions/326.html).\n"},"properties":{"tags":["security","external/cwe/cwe-326"],"description":"Use of a cryptographic key that is too small may allow the encryption to be broken.","id":"py/weak-crypto-key","kind":"problem","name":"Use of weak cryptographic key","precision":"high","problem.severity":"error","security-severity":"7.5"}},{"id":"py/http-response-splitting","name":"py/http-response-splitting","shortDescription":{"text":"HTTP Response Splitting"},"fullDescription":{"text":"Writing user input directly to an HTTP header makes code vulnerable to attack by header splitting."},"defaultConfiguration":{"enabled":true,"level":"error"},"help":{"text":"# HTTP Response Splitting\nDirectly writing user input (for example, an HTTP request parameter) to an HTTP header can lead to an HTTP response-splitting vulnerability.\n\nIf user-controlled input is used in an HTTP header that allows line break characters, an attacker can inject additional headers or control the response body, leading to vulnerabilities such as XSS or cache poisoning.\n\n\n## Recommendation\nEnsure that user input containing line break characters is not written to an HTTP header.\n\n\n## Example\nIn the following example, the case marked BAD writes user input to the header name. In the GOOD case, input is first escaped to not contain any line break characters.\n\n\n```python\n@app.route(\"/example_bad\")\ndef example_bad():\n    rfs_header = request.args[\"rfs_header\"]\n    response = Response()\n    custom_header = \"X-MyHeader-\" + rfs_header\n    # BAD: User input is used as part of the header name.\n    response.headers[custom_header] = \"HeaderValue\" \n    return response\n\n@app.route(\"/example_good\")\ndef example_bad():\n    rfs_header = request.args[\"rfs_header\"]\n    response = Response()\n    custom_header = \"X-MyHeader-\" + rfs_header.replace(\"\\n\", \"\").replace(\"\\r\",\"\").replace(\":\",\"\")\n    # GOOD: Line break characters are removed from the input.\n    response.headers[custom_header] = \"HeaderValue\" \n    return response\n```\n\n## References\n* SecLists.org: [HTTP response splitting](https://seclists.org/bugtraq/2005/Apr/187).\n* OWASP: [HTTP Response Splitting](https://www.owasp.org/index.php/HTTP_Response_Splitting).\n* Wikipedia: [HTTP response splitting](http://en.wikipedia.org/wiki/HTTP_response_splitting).\n* CAPEC: [CAPEC-105: HTTP Request Splitting](https://capec.mitre.org/data/definitions/105.html)\n* Common Weakness Enumeration: [CWE-113](https://cwe.mitre.org/data/definitions/113.html).\n* Common Weakness Enumeration: [CWE-79](https://cwe.mitre.org/data/definitions/79.html).\n","markdown":"# HTTP Response Splitting\nDirectly writing user input (for example, an HTTP request parameter) to an HTTP header can lead to an HTTP response-splitting vulnerability.\n\nIf user-controlled input is used in an HTTP header that allows line break characters, an attacker can inject additional headers or control the response body, leading to vulnerabilities such as XSS or cache poisoning.\n\n\n## Recommendation\nEnsure that user input containing line break characters is not written to an HTTP header.\n\n\n## Example\nIn the following example, the case marked BAD writes user input to the header name. In the GOOD case, input is first escaped to not contain any line break characters.\n\n\n```python\n@app.route(\"/example_bad\")\ndef example_bad():\n    rfs_header = request.args[\"rfs_header\"]\n    response = Response()\n    custom_header = \"X-MyHeader-\" + rfs_header\n    # BAD: User input is used as part of the header name.\n    response.headers[custom_header] = \"HeaderValue\" \n    return response\n\n@app.route(\"/example_good\")\ndef example_bad():\n    rfs_header = request.args[\"rfs_header\"]\n    response = Response()\n    custom_header = \"X-MyHeader-\" + rfs_header.replace(\"\\n\", \"\").replace(\"\\r\",\"\").replace(\":\",\"\")\n    # GOOD: Line break characters are removed from the input.\n    response.headers[custom_header] = \"HeaderValue\" \n    return response\n```\n\n## References\n* SecLists.org: [HTTP response splitting](https://seclists.org/bugtraq/2005/Apr/187).\n* OWASP: [HTTP Response Splitting](https://www.owasp.org/index.php/HTTP_Response_Splitting).\n* Wikipedia: [HTTP response splitting](http://en.wikipedia.org/wiki/HTTP_response_splitting).\n* CAPEC: [CAPEC-105: HTTP Request Splitting](https://capec.mitre.org/data/definitions/105.html)\n* Common Weakness Enumeration: [CWE-113](https://cwe.mitre.org/data/definitions/113.html).\n* Common Weakness Enumeration: [CWE-79](https://cwe.mitre.org/data/definitions/79.html).\n"},"properties":{"tags":["security","external/cwe/cwe-113","external/cwe/cwe-079"],"description":"Writing user input directly to an HTTP header\n              makes code vulnerable to attack by header splitting.","id":"py/http-response-splitting","kind":"path-problem","name":"HTTP Response Splitting","precision":"high","problem.severity":"error","security-severity":"6.1"}},{"id":"py/insecure-temporary-file","name":"py/insecure-temporary-file","shortDescription":{"text":"Insecure temporary file"},"fullDescription":{"text":"Creating a temporary file using this method may be insecure."},"defaultConfiguration":{"enabled":true,"level":"error"},"help":{"text":"# Insecure temporary file\nFunctions that create temporary file names (such as `tempfile.mktemp` and `os.tempnam`) are fundamentally insecure, as they do not ensure exclusive access to a file with the temporary name they return. The file name returned by these functions is guaranteed to be unique on creation but the file must be opened in a separate operation. There is no guarantee that the creation and open operations will happen atomically. This provides an opportunity for an attacker to interfere with the file before it is opened.\n\nNote that `mktemp` has been deprecated since Python 2.3.\n\n\n## Recommendation\nReplace the use of `mktemp` with some of the more secure functions in the `tempfile` module, such as `TemporaryFile`. If the file is intended to be accessed from other processes, consider using the `NamedTemporaryFile` function.\n\n\n## Example\nThe following piece of code opens a temporary file and writes a set of results to it. Because the file name is created using `mktemp`, another process may access this file before it is opened using `open`.\n\n\n```python\nfrom tempfile import mktemp\n\ndef write_results(results):\n    filename = mktemp()\n    with open(filename, \"w+\") as f:\n        f.write(results)\n    print(\"Results written to\", filename)\n\n```\nBy changing the code to use `NamedTemporaryFile` instead, the file is opened immediately.\n\n\n```python\nfrom tempfile import NamedTemporaryFile\n\ndef write_results(results):\n    with NamedTemporaryFile(mode=\"w+\", delete=False) as f:\n        f.write(results)\n    print(\"Results written to\", f.name)\n\n```\n\n## References\n* Python Standard Library: [tempfile.mktemp](https://docs.python.org/3/library/tempfile.html#tempfile.mktemp).\n* Common Weakness Enumeration: [CWE-377](https://cwe.mitre.org/data/definitions/377.html).\n","markdown":"# Insecure temporary file\nFunctions that create temporary file names (such as `tempfile.mktemp` and `os.tempnam`) are fundamentally insecure, as they do not ensure exclusive access to a file with the temporary name they return. The file name returned by these functions is guaranteed to be unique on creation but the file must be opened in a separate operation. There is no guarantee that the creation and open operations will happen atomically. This provides an opportunity for an attacker to interfere with the file before it is opened.\n\nNote that `mktemp` has been deprecated since Python 2.3.\n\n\n## Recommendation\nReplace the use of `mktemp` with some of the more secure functions in the `tempfile` module, such as `TemporaryFile`. If the file is intended to be accessed from other processes, consider using the `NamedTemporaryFile` function.\n\n\n## Example\nThe following piece of code opens a temporary file and writes a set of results to it. Because the file name is created using `mktemp`, another process may access this file before it is opened using `open`.\n\n\n```python\nfrom tempfile import mktemp\n\ndef write_results(results):\n    filename = mktemp()\n    with open(filename, \"w+\") as f:\n        f.write(results)\n    print(\"Results written to\", filename)\n\n```\nBy changing the code to use `NamedTemporaryFile` instead, the file is opened immediately.\n\n\n```python\nfrom tempfile import NamedTemporaryFile\n\ndef write_results(results):\n    with NamedTemporaryFile(mode=\"w+\", delete=False) as f:\n        f.write(results)\n    print(\"Results written to\", f.name)\n\n```\n\n## References\n* Python Standard Library: [tempfile.mktemp](https://docs.python.org/3/library/tempfile.html#tempfile.mktemp).\n* Common Weakness Enumeration: [CWE-377](https://cwe.mitre.org/data/definitions/377.html).\n"},"properties":{"tags":["external/cwe/cwe-377","security"],"description":"Creating a temporary file using this method may be insecure.","id":"py/insecure-temporary-file","kind":"problem","name":"Insecure temporary file","precision":"high","problem.severity":"error","security-severity":"7.0","sub-severity":"high"}},{"id":"py/nosql-injection","name":"py/nosql-injection","shortDescription":{"text":"NoSQL Injection"},"fullDescription":{"text":"Building a NoSQL query from user-controlled sources is vulnerable to insertion of malicious NoSQL code by the user."},"defaultConfiguration":{"enabled":true,"level":"error"},"help":{"text":"# NoSQL Injection\nPassing user-controlled sources into NoSQL queries can result in a NoSQL injection flaw. This tainted NoSQL query containing a user-controlled source can then execute a malicious query in a NoSQL database such as MongoDB. In order for the user-controlled source to taint the NoSQL query, the user-controller source must be converted into a Python object using something like `json.loads` or `xmltodict.parse`.\n\nBecause a user-controlled source is passed into the query, the malicious user can have complete control over the query itself. When the tainted query is executed, the malicious user can commit malicious actions such as bypassing role restrictions or accessing and modifying restricted data in the NoSQL database.\n\n\n## Recommendation\nNoSQL injections can be prevented by escaping user-input's special characters that are passed into the NoSQL query from the user-supplied source. Alternatively, using a sanitize library such as MongoSanitizer will ensure that user-supplied sources can not act as a malicious query.\n\n\n## Example\nIn the example below, the user-supplied source is passed to a MongoDB function that queries the MongoDB database.\n\n\n```python\nfrom flask import Flask, request\nfrom flask_pymongo import PyMongo\nimport json\n\nmongo = PyMongo(app)\n\n\n@app.route(\"/\")\ndef home_page():\n    unsanitized_search = request.args['search']\n    json_search = json.loads(unsanitized_search)\n\n    result = mongo.db.user.find({'name': json_search})\n\n```\nThis can be fixed by using a sanitizer library like MongoSanitizer as shown in this annotated code version below.\n\n\n```python\nfrom flask import Flask, request\nfrom flask_pymongo import PyMongo\nfrom mongosanitizer.sanitizer import sanitize\nimport json\n\nmongo = PyMongo(app)\n\n\n@app.route(\"/\")\ndef home_page():\n    unsafe_search = request.args['search']\n    json_search = json.loads(unsafe_search)\n    safe_search = sanitize(unsanitized_search)\n\n    result = client.db.collection.find_one({'data': safe_search})\n\n```\n\n## References\n* Mongoengine: [Documentation](http://mongoengine.org/).\n* Flask-Mongoengine: [Documentation](http://docs.mongoengine.org/projects/flask-mongoengine/en/latest/).\n* PyMongo: [Documentation](https://pypi.org/project/pymongo/).\n* Flask-PyMongo: [Documentation](https://flask-pymongo.readthedocs.io/en/latest/).\n* OWASP: [NoSQL Injection](https://owasp.org/www-pdf-archive/GOD16-NOSQL.pdf).\n* Security Stack Exchange Discussion: [Question 83231](https://security.stackexchange.com/questions/83231/mongodb-nosql-injection-in-python-code).\n* Common Weakness Enumeration: [CWE-943](https://cwe.mitre.org/data/definitions/943.html).\n","markdown":"# NoSQL Injection\nPassing user-controlled sources into NoSQL queries can result in a NoSQL injection flaw. This tainted NoSQL query containing a user-controlled source can then execute a malicious query in a NoSQL database such as MongoDB. In order for the user-controlled source to taint the NoSQL query, the user-controller source must be converted into a Python object using something like `json.loads` or `xmltodict.parse`.\n\nBecause a user-controlled source is passed into the query, the malicious user can have complete control over the query itself. When the tainted query is executed, the malicious user can commit malicious actions such as bypassing role restrictions or accessing and modifying restricted data in the NoSQL database.\n\n\n## Recommendation\nNoSQL injections can be prevented by escaping user-input's special characters that are passed into the NoSQL query from the user-supplied source. Alternatively, using a sanitize library such as MongoSanitizer will ensure that user-supplied sources can not act as a malicious query.\n\n\n## Example\nIn the example below, the user-supplied source is passed to a MongoDB function that queries the MongoDB database.\n\n\n```python\nfrom flask import Flask, request\nfrom flask_pymongo import PyMongo\nimport json\n\nmongo = PyMongo(app)\n\n\n@app.route(\"/\")\ndef home_page():\n    unsanitized_search = request.args['search']\n    json_search = json.loads(unsanitized_search)\n\n    result = mongo.db.user.find({'name': json_search})\n\n```\nThis can be fixed by using a sanitizer library like MongoSanitizer as shown in this annotated code version below.\n\n\n```python\nfrom flask import Flask, request\nfrom flask_pymongo import PyMongo\nfrom mongosanitizer.sanitizer import sanitize\nimport json\n\nmongo = PyMongo(app)\n\n\n@app.route(\"/\")\ndef home_page():\n    unsafe_search = request.args['search']\n    json_search = json.loads(unsafe_search)\n    safe_search = sanitize(unsanitized_search)\n\n    result = client.db.collection.find_one({'data': safe_search})\n\n```\n\n## References\n* Mongoengine: [Documentation](http://mongoengine.org/).\n* Flask-Mongoengine: [Documentation](http://docs.mongoengine.org/projects/flask-mongoengine/en/latest/).\n* PyMongo: [Documentation](https://pypi.org/project/pymongo/).\n* Flask-PyMongo: [Documentation](https://flask-pymongo.readthedocs.io/en/latest/).\n* OWASP: [NoSQL Injection](https://owasp.org/www-pdf-archive/GOD16-NOSQL.pdf).\n* Security Stack Exchange Discussion: [Question 83231](https://security.stackexchange.com/questions/83231/mongodb-nosql-injection-in-python-code).\n* Common Weakness Enumeration: [CWE-943](https://cwe.mitre.org/data/definitions/943.html).\n"},"properties":{"tags":["security","external/cwe/cwe-943"],"description":"Building a NoSQL query from user-controlled sources is vulnerable to insertion of\n              malicious NoSQL code by the user.","id":"py/nosql-injection","kind":"path-problem","name":"NoSQL Injection","precision":"high","problem.severity":"error","security-severity":"8.8"}},{"id":"py/incomplete-url-substring-sanitization","name":"py/incomplete-url-substring-sanitization","shortDescription":{"text":"Incomplete URL substring sanitization"},"fullDescription":{"text":"Security checks on the substrings of an unparsed URL are often vulnerable to bypassing."},"defaultConfiguration":{"enabled":true,"level":"warning"},"help":{"text":"# Incomplete URL substring sanitization\nSanitizing untrusted URLs is a common technique for preventing attacks such as request forgeries and malicious redirections. Usually, this is done by checking that the host of a URL is in a set of allowed hosts.\n\nHowever, treating the URL as a string and checking if one of the allowed hosts is a substring of the URL is very prone to errors. Malicious URLs can bypass such security checks by embedding one of the allowed hosts in an unexpected location.\n\nEven if the substring check is not used in a security-critical context, the incomplete check may still cause undesirable behaviors when the check succeeds accidentally.\n\n\n## Recommendation\nParse a URL before performing a check on its host value, and ensure that the check handles arbitrary subdomain sequences correctly.\n\n\n## Example\nThe following example code checks that a URL redirection will reach the `example.com` domain.\n\n\n```python\nfrom flask import Flask, request, redirect\nfrom urllib.parse import urlparse\n\napp = Flask(__name__)\n\n# Not safe, as \"evil-example.net/example.com\" would be accepted\n\n@app.route('/some/path/bad1')\ndef unsafe1(request):\n    target = request.args.get('target', '')\n    if \"example.com\" in target:\n        return redirect(target)\n\n# Not safe, as \"benign-looking-prefix-example.com\" would be accepted\n\n@app.route('/some/path/bad2')\ndef unsafe2(request):\n    target = request.args.get('target', '')\n    if target.endswith(\"example.com\"):\n        return redirect(target)\n\n\n\n#Simplest and safest approach is to use an allowlist\n\n@app.route('/some/path/good1')\ndef safe1(request):\n    allowlist = [\n        \"example.com/home\",\n        \"example.com/login\",\n    ]\n    target = request.args.get('target', '')\n    if target in allowlist:\n        return redirect(target)\n\n#More complex example allowing sub-domains.\n\n@app.route('/some/path/good2')\ndef safe2(request):\n    target = request.args.get('target', '')\n    host = urlparse(target).hostname\n    #Note the '.' preceding example.com\n    if host and host.endswith(\".example.com\"):\n        return redirect(target)\n\n\n```\nThe first two examples show unsafe checks that are easily bypassed. In `unsafe1` the attacker can simply add `example.com` anywhere in the url. For example, `http://evil-example.net/example.com`.\n\nIn `unsafe2` the attacker must use a hostname ending in `example.com`, but that is easy to do. For example, `http://benign-looking-prefix-example.com`.\n\nThe second two examples show safe checks. In `safe1`, an allowlist is used. Although fairly inflexible, this is easy to get right and is most likely to be safe.\n\nIn `safe2`, `urlparse` is used to parse the URL, then the hostname is checked to make sure it ends with `.example.com`.\n\n\n## References\n* OWASP: [SSRF](https://www.owasp.org/index.php/Server_Side_Request_Forgery)\n* OWASP: [XSS Unvalidated Redirects and Forwards Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/Unvalidated_Redirects_and_Forwards_Cheat_Sheet.html).\n* Common Weakness Enumeration: [CWE-20](https://cwe.mitre.org/data/definitions/20.html).\n","markdown":"# Incomplete URL substring sanitization\nSanitizing untrusted URLs is a common technique for preventing attacks such as request forgeries and malicious redirections. Usually, this is done by checking that the host of a URL is in a set of allowed hosts.\n\nHowever, treating the URL as a string and checking if one of the allowed hosts is a substring of the URL is very prone to errors. Malicious URLs can bypass such security checks by embedding one of the allowed hosts in an unexpected location.\n\nEven if the substring check is not used in a security-critical context, the incomplete check may still cause undesirable behaviors when the check succeeds accidentally.\n\n\n## Recommendation\nParse a URL before performing a check on its host value, and ensure that the check handles arbitrary subdomain sequences correctly.\n\n\n## Example\nThe following example code checks that a URL redirection will reach the `example.com` domain.\n\n\n```python\nfrom flask import Flask, request, redirect\nfrom urllib.parse import urlparse\n\napp = Flask(__name__)\n\n# Not safe, as \"evil-example.net/example.com\" would be accepted\n\n@app.route('/some/path/bad1')\ndef unsafe1(request):\n    target = request.args.get('target', '')\n    if \"example.com\" in target:\n        return redirect(target)\n\n# Not safe, as \"benign-looking-prefix-example.com\" would be accepted\n\n@app.route('/some/path/bad2')\ndef unsafe2(request):\n    target = request.args.get('target', '')\n    if target.endswith(\"example.com\"):\n        return redirect(target)\n\n\n\n#Simplest and safest approach is to use an allowlist\n\n@app.route('/some/path/good1')\ndef safe1(request):\n    allowlist = [\n        \"example.com/home\",\n        \"example.com/login\",\n    ]\n    target = request.args.get('target', '')\n    if target in allowlist:\n        return redirect(target)\n\n#More complex example allowing sub-domains.\n\n@app.route('/some/path/good2')\ndef safe2(request):\n    target = request.args.get('target', '')\n    host = urlparse(target).hostname\n    #Note the '.' preceding example.com\n    if host and host.endswith(\".example.com\"):\n        return redirect(target)\n\n\n```\nThe first two examples show unsafe checks that are easily bypassed. In `unsafe1` the attacker can simply add `example.com` anywhere in the url. For example, `http://evil-example.net/example.com`.\n\nIn `unsafe2` the attacker must use a hostname ending in `example.com`, but that is easy to do. For example, `http://benign-looking-prefix-example.com`.\n\nThe second two examples show safe checks. In `safe1`, an allowlist is used. Although fairly inflexible, this is easy to get right and is most likely to be safe.\n\nIn `safe2`, `urlparse` is used to parse the URL, then the hostname is checked to make sure it ends with `.example.com`.\n\n\n## References\n* OWASP: [SSRF](https://www.owasp.org/index.php/Server_Side_Request_Forgery)\n* OWASP: [XSS Unvalidated Redirects and Forwards Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/Unvalidated_Redirects_and_Forwards_Cheat_Sheet.html).\n* Common Weakness Enumeration: [CWE-20](https://cwe.mitre.org/data/definitions/20.html).\n"},"properties":{"tags":["correctness","security","external/cwe/cwe-020"],"description":"Security checks on the substrings of an unparsed URL are often vulnerable to bypassing.","id":"py/incomplete-url-substring-sanitization","kind":"problem","name":"Incomplete URL substring sanitization","precision":"high","problem.severity":"warning","security-severity":"7.8"}},{"id":"py/overly-large-range","name":"py/overly-large-range","shortDescription":{"text":"Overly permissive regular expression range"},"fullDescription":{"text":"Overly permissive regular expression ranges match a wider range of characters than intended. This may allow an attacker to bypass a filter or sanitizer."},"defaultConfiguration":{"enabled":true,"level":"warning"},"help":{"text":"# Overly permissive regular expression range\nIt's easy to write a regular expression range that matches a wider range of characters than you intended. For example, `/[a-zA-z]/` matches all lowercase and all uppercase letters, as you would expect, but it also matches the characters: `` [ \\ ] ^ _ ` ``.\n\nAnother common problem is failing to escape the dash character in a regular expression. An unescaped dash is interpreted as part of a range. For example, in the character class `[a-zA-Z0-9%=.,-_]` the last character range matches the 55 characters between `,` and `_` (both included), which overlaps with the range `[0-9]` and is clearly not intended by the writer.\n\n\n## Recommendation\nAvoid any confusion about which characters are included in the range by writing unambiguous regular expressions. Always check that character ranges match only the expected characters.\n\n\n## Example\nThe following example code is intended to check whether a string is a valid 6 digit hex color.\n\n```python\n\nimport re\ndef is_valid_hex_color(color):\n    return re.match(r'^#[0-9a-fA-f]{6}$', color) is not None\n\n```\nHowever, the `A-f` range is overly large and matches every uppercase character. It would parse a \"color\" like `#XXYYZZ` as valid.\n\nThe fix is to use an uppercase `A-F` range instead.\n\n```python\n\nimport re\ndef is_valid_hex_color(color):\n    return re.match(r'^#[0-9a-fA-F]{6}$', color) is not None\n\n```\n\n## References\n* GitHub Advisory Database: [CVE-2021-42740: Improper Neutralization of Special Elements used in a Command in Shell-quote](https://github.com/advisories/GHSA-g4rg-993r-mgx7)\n* wh0.github.io: [Exploiting CVE-2021-42740](https://wh0.github.io/2021/10/28/shell-quote-rce-exploiting.html)\n* Yosuke Ota: [no-obscure-range](https://ota-meshi.github.io/eslint-plugin-regexp/rules/no-obscure-range.html)\n* Paul Boyd: [The regex \\[,-.\\]](https://pboyd.io/posts/comma-dash-dot/)\n* Common Weakness Enumeration: [CWE-20](https://cwe.mitre.org/data/definitions/20.html).\n","markdown":"# Overly permissive regular expression range\nIt's easy to write a regular expression range that matches a wider range of characters than you intended. For example, `/[a-zA-z]/` matches all lowercase and all uppercase letters, as you would expect, but it also matches the characters: `` [ \\ ] ^ _ ` ``.\n\nAnother common problem is failing to escape the dash character in a regular expression. An unescaped dash is interpreted as part of a range. For example, in the character class `[a-zA-Z0-9%=.,-_]` the last character range matches the 55 characters between `,` and `_` (both included), which overlaps with the range `[0-9]` and is clearly not intended by the writer.\n\n\n## Recommendation\nAvoid any confusion about which characters are included in the range by writing unambiguous regular expressions. Always check that character ranges match only the expected characters.\n\n\n## Example\nThe following example code is intended to check whether a string is a valid 6 digit hex color.\n\n```python\n\nimport re\ndef is_valid_hex_color(color):\n    return re.match(r'^#[0-9a-fA-f]{6}$', color) is not None\n\n```\nHowever, the `A-f` range is overly large and matches every uppercase character. It would parse a \"color\" like `#XXYYZZ` as valid.\n\nThe fix is to use an uppercase `A-F` range instead.\n\n```python\n\nimport re\ndef is_valid_hex_color(color):\n    return re.match(r'^#[0-9a-fA-F]{6}$', color) is not None\n\n```\n\n## References\n* GitHub Advisory Database: [CVE-2021-42740: Improper Neutralization of Special Elements used in a Command in Shell-quote](https://github.com/advisories/GHSA-g4rg-993r-mgx7)\n* wh0.github.io: [Exploiting CVE-2021-42740](https://wh0.github.io/2021/10/28/shell-quote-rce-exploiting.html)\n* Yosuke Ota: [no-obscure-range](https://ota-meshi.github.io/eslint-plugin-regexp/rules/no-obscure-range.html)\n* Paul Boyd: [The regex \\[,-.\\]](https://pboyd.io/posts/comma-dash-dot/)\n* Common Weakness Enumeration: [CWE-20](https://cwe.mitre.org/data/definitions/20.html).\n"},"properties":{"tags":["correctness","security","external/cwe/cwe-020"],"description":"Overly permissive regular expression ranges match a wider range of characters than intended.\n              This may allow an attacker to bypass a filter or sanitizer.","id":"py/overly-large-range","kind":"problem","name":"Overly permissive regular expression range","precision":"high","problem.severity":"warning","security-severity":"5.0"}},{"id":"py/cookie-injection","name":"py/cookie-injection","shortDescription":{"text":"Construction of a cookie using user-supplied input"},"fullDescription":{"text":"Constructing cookies from user input may allow an attacker to perform a Cookie Poisoning attack."},"defaultConfiguration":{"enabled":true,"level":"warning"},"help":{"text":"# Construction of a cookie using user-supplied input\nConstructing cookies from user input can allow an attacker to control a user's cookie. This may lead to a session fixation attack. Additionally, client code may not expect a cookie to contain attacker-controlled data, and fail to sanitize it for common vulnerabilities such as Cross Site Scripting (XSS). An attacker manipulating the raw cookie header may additionally be able to set cookie attributes such as `HttpOnly` to insecure values.\n\n\n## Recommendation\nDo not use raw user input to construct cookies.\n\n\n## Example\nIn the following cases, a cookie is constructed for a Flask response using user input. The first uses `set_cookie`, and the second sets a cookie's raw value through the `set-cookie` header.\n\n\n```python\nfrom flask import request, make_response\n\n\n@app.route(\"/1\")\ndef set_cookie():\n    resp = make_response()\n    resp.set_cookie(request.args[\"name\"], # BAD: User input is used to set the cookie's name and value\n                    value=request.args[\"name\"])\n    return resp\n\n\n@app.route(\"/2\")\ndef set_cookie_header():\n    resp = make_response()\n    resp.headers['Set-Cookie'] = f\"{request.args['name']}={request.args['name']};\" # BAD: User input is used to set the raw cookie header.\n    return resp\n\n```\n\n## References\n* Wikipedia - [Session Fixation](https://en.wikipedia.org/wiki/Session_fixation).\n* Common Weakness Enumeration: [CWE-20](https://cwe.mitre.org/data/definitions/20.html).\n","markdown":"# Construction of a cookie using user-supplied input\nConstructing cookies from user input can allow an attacker to control a user's cookie. This may lead to a session fixation attack. Additionally, client code may not expect a cookie to contain attacker-controlled data, and fail to sanitize it for common vulnerabilities such as Cross Site Scripting (XSS). An attacker manipulating the raw cookie header may additionally be able to set cookie attributes such as `HttpOnly` to insecure values.\n\n\n## Recommendation\nDo not use raw user input to construct cookies.\n\n\n## Example\nIn the following cases, a cookie is constructed for a Flask response using user input. The first uses `set_cookie`, and the second sets a cookie's raw value through the `set-cookie` header.\n\n\n```python\nfrom flask import request, make_response\n\n\n@app.route(\"/1\")\ndef set_cookie():\n    resp = make_response()\n    resp.set_cookie(request.args[\"name\"], # BAD: User input is used to set the cookie's name and value\n                    value=request.args[\"name\"])\n    return resp\n\n\n@app.route(\"/2\")\ndef set_cookie_header():\n    resp = make_response()\n    resp.headers['Set-Cookie'] = f\"{request.args['name']}={request.args['name']};\" # BAD: User input is used to set the raw cookie header.\n    return resp\n\n```\n\n## References\n* Wikipedia - [Session Fixation](https://en.wikipedia.org/wiki/Session_fixation).\n* Common Weakness Enumeration: [CWE-20](https://cwe.mitre.org/data/definitions/20.html).\n"},"properties":{"tags":["security","external/cwe/cwe-020"],"description":"Constructing cookies from user input may allow an attacker to perform a Cookie Poisoning attack.","id":"py/cookie-injection","kind":"path-problem","name":"Construction of a cookie using user-supplied input","precision":"high","problem.severity":"warning","security-severity":"5.0"}},{"id":"py/incomplete-hostname-regexp","name":"py/incomplete-hostname-regexp","shortDescription":{"text":"Incomplete regular expression for hostnames"},"fullDescription":{"text":"Matching a URL or hostname against a regular expression that contains an unescaped dot as part of the hostname might match more hostnames than expected."},"defaultConfiguration":{"enabled":true,"level":"warning"},"help":{"text":"# Incomplete regular expression for hostnames\nSanitizing untrusted URLs is a common technique for preventing attacks such as request forgeries and malicious redirections. Often, this is done by checking that the host of a URL is in a set of allowed hosts.\n\nIf a regular expression implements such a check, it is easy to accidentally make the check too permissive by not escaping the `.` meta-characters appropriately. Even if the check is not used in a security-critical context, the incomplete check may still cause undesirable behaviors when it accidentally succeeds.\n\n\n## Recommendation\nEscape all meta-characters appropriately when constructing regular expressions for security checks, and pay special attention to the `.` meta-character.\n\n\n## Example\nThe following example code checks that a URL redirection will reach the `example.com` domain, or one of its subdomains.\n\n\n```python\nfrom flask import Flask, request, redirect\nimport re\n\napp = Flask(__name__)\n\nUNSAFE_REGEX = re.compile(\"(www|beta).example.com/\")\nSAFE_REGEX = re.compile(r\"(www|beta)\\.example\\.com/\")\n\n@app.route('/some/path/bad')\ndef unsafe(request):\n    target = request.args.get('target', '')\n    if UNSAFE_REGEX.match(target):\n        return redirect(target)\n\n@app.route('/some/path/good')\ndef safe(request):\n    target = request.args.get('target', '')\n    if SAFE_REGEX.match(target):\n        return redirect(target)\n\n```\nThe `unsafe` check is easy to bypass because the unescaped `.` allows for any character before `example.com`, effectively allowing the redirect to go to an attacker-controlled domain such as `wwwXexample.com`.\n\nThe `safe` check closes this vulnerability by escaping the `.` so that URLs of the form `wwwXexample.com` are rejected.\n\n\n## References\n* OWASP: [SSRF](https://www.owasp.org/index.php/Server_Side_Request_Forgery)\n* OWASP: [XSS Unvalidated Redirects and Forwards Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/Unvalidated_Redirects_and_Forwards_Cheat_Sheet.html).\n* Common Weakness Enumeration: [CWE-20](https://cwe.mitre.org/data/definitions/20.html).\n","markdown":"# Incomplete regular expression for hostnames\nSanitizing untrusted URLs is a common technique for preventing attacks such as request forgeries and malicious redirections. Often, this is done by checking that the host of a URL is in a set of allowed hosts.\n\nIf a regular expression implements such a check, it is easy to accidentally make the check too permissive by not escaping the `.` meta-characters appropriately. Even if the check is not used in a security-critical context, the incomplete check may still cause undesirable behaviors when it accidentally succeeds.\n\n\n## Recommendation\nEscape all meta-characters appropriately when constructing regular expressions for security checks, and pay special attention to the `.` meta-character.\n\n\n## Example\nThe following example code checks that a URL redirection will reach the `example.com` domain, or one of its subdomains.\n\n\n```python\nfrom flask import Flask, request, redirect\nimport re\n\napp = Flask(__name__)\n\nUNSAFE_REGEX = re.compile(\"(www|beta).example.com/\")\nSAFE_REGEX = re.compile(r\"(www|beta)\\.example\\.com/\")\n\n@app.route('/some/path/bad')\ndef unsafe(request):\n    target = request.args.get('target', '')\n    if UNSAFE_REGEX.match(target):\n        return redirect(target)\n\n@app.route('/some/path/good')\ndef safe(request):\n    target = request.args.get('target', '')\n    if SAFE_REGEX.match(target):\n        return redirect(target)\n\n```\nThe `unsafe` check is easy to bypass because the unescaped `.` allows for any character before `example.com`, effectively allowing the redirect to go to an attacker-controlled domain such as `wwwXexample.com`.\n\nThe `safe` check closes this vulnerability by escaping the `.` so that URLs of the form `wwwXexample.com` are rejected.\n\n\n## References\n* OWASP: [SSRF](https://www.owasp.org/index.php/Server_Side_Request_Forgery)\n* OWASP: [XSS Unvalidated Redirects and Forwards Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/Unvalidated_Redirects_and_Forwards_Cheat_Sheet.html).\n* Common Weakness Enumeration: [CWE-20](https://cwe.mitre.org/data/definitions/20.html).\n"},"properties":{"tags":["correctness","security","external/cwe/cwe-020"],"description":"Matching a URL or hostname against a regular expression that contains an unescaped dot as part of the hostname might match more hostnames than expected.","id":"py/incomplete-hostname-regexp","kind":"problem","name":"Incomplete regular expression for hostnames","precision":"high","problem.severity":"warning","security-severity":"7.8"}},{"id":"py/reflective-xss","name":"py/reflective-xss","shortDescription":{"text":"Reflected server-side cross-site scripting"},"fullDescription":{"text":"Writing user input directly to a web page allows for a cross-site scripting vulnerability."},"defaultConfiguration":{"enabled":true,"level":"error"},"help":{"text":"# Reflected server-side cross-site scripting\nDirectly writing user input (for example, an HTTP request parameter) to a webpage without properly sanitizing the input first, allows for a cross-site scripting vulnerability.\n\n\n## Recommendation\nTo guard against cross-site scripting, consider escaping the input before writing user input to the page. The standard library provides escaping functions: `html.escape()` for Python 3.2 upwards or `cgi.escape()` older versions of Python. Most frameworks also provide their own escaping functions, for example `flask.escape()`.\n\n\n## Example\nThe following example is a minimal flask app which shows a safe and unsafe way to render the given name back to the page. The first view is unsafe as `first_name` is not escaped, leaving the page vulnerable to cross-site scripting attacks. The second view is safe as `first_name` is escaped, so it is not vulnerable to cross-site scripting attacks.\n\n\n```python\nfrom flask import Flask, request, make_response, escape\n\napp = Flask(__name__)\n\n@app.route('/unsafe')\ndef unsafe():\n    first_name = request.args.get('name', '')\n    return make_response(\"Your name is \" + first_name)\n\n@app.route('/safe')\ndef safe():\n    first_name = request.args.get('name', '')\n    return make_response(\"Your name is \" + escape(first_name))\n\n```\n\n## References\n* OWASP: [XSS (Cross Site Scripting) Prevention Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/Cross_Site_Scripting_Prevention_Cheat_Sheet.html).\n* Wikipedia: [Cross-site scripting](http://en.wikipedia.org/wiki/Cross-site_scripting).\n* Python Library Reference: [html.escape()](https://docs.python.org/3/library/html.html#html.escape).\n* Common Weakness Enumeration: [CWE-79](https://cwe.mitre.org/data/definitions/79.html).\n* Common Weakness Enumeration: [CWE-116](https://cwe.mitre.org/data/definitions/116.html).\n","markdown":"# Reflected server-side cross-site scripting\nDirectly writing user input (for example, an HTTP request parameter) to a webpage without properly sanitizing the input first, allows for a cross-site scripting vulnerability.\n\n\n## Recommendation\nTo guard against cross-site scripting, consider escaping the input before writing user input to the page. The standard library provides escaping functions: `html.escape()` for Python 3.2 upwards or `cgi.escape()` older versions of Python. Most frameworks also provide their own escaping functions, for example `flask.escape()`.\n\n\n## Example\nThe following example is a minimal flask app which shows a safe and unsafe way to render the given name back to the page. The first view is unsafe as `first_name` is not escaped, leaving the page vulnerable to cross-site scripting attacks. The second view is safe as `first_name` is escaped, so it is not vulnerable to cross-site scripting attacks.\n\n\n```python\nfrom flask import Flask, request, make_response, escape\n\napp = Flask(__name__)\n\n@app.route('/unsafe')\ndef unsafe():\n    first_name = request.args.get('name', '')\n    return make_response(\"Your name is \" + first_name)\n\n@app.route('/safe')\ndef safe():\n    first_name = request.args.get('name', '')\n    return make_response(\"Your name is \" + escape(first_name))\n\n```\n\n## References\n* OWASP: [XSS (Cross Site Scripting) Prevention Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/Cross_Site_Scripting_Prevention_Cheat_Sheet.html).\n* Wikipedia: [Cross-site scripting](http://en.wikipedia.org/wiki/Cross-site_scripting).\n* Python Library Reference: [html.escape()](https://docs.python.org/3/library/html.html#html.escape).\n* Common Weakness Enumeration: [CWE-79](https://cwe.mitre.org/data/definitions/79.html).\n* Common Weakness Enumeration: [CWE-116](https://cwe.mitre.org/data/definitions/116.html).\n"},"properties":{"tags":["security","external/cwe/cwe-079","external/cwe/cwe-116"],"description":"Writing user input directly to a web page\n              allows for a cross-site scripting vulnerability.","id":"py/reflective-xss","kind":"path-problem","name":"Reflected server-side cross-site scripting","precision":"high","problem.severity":"error","security-severity":"6.1","sub-severity":"high"}},{"id":"py/path-injection","name":"py/path-injection","shortDescription":{"text":"Uncontrolled data used in path expression"},"fullDescription":{"text":"Accessing paths influenced by users can allow an attacker to access unexpected resources."},"defaultConfiguration":{"enabled":true,"level":"error"},"help":{"text":"# Uncontrolled data used in path expression\nAccessing files using paths constructed from user-controlled data can allow an attacker to access unexpected resources. This can result in sensitive information being revealed or deleted, or an attacker being able to influence behavior by modifying unexpected files.\n\n\n## Recommendation\nValidate user input before using it to construct a file path, either using an off-the-shelf library function like `werkzeug.utils.secure_filename`, or by performing custom validation.\n\nIdeally, follow these rules:\n\n* Do not allow more than a single \".\" character.\n* Do not allow directory separators such as \"/\" or \"\\\\\" (depending on the file system).\n* Do not rely on simply replacing problematic sequences such as \"../\". For example, after applying this filter to \".../...//\", the resulting string would still be \"../\".\n* Use an allowlist of known good patterns.\n\n## Example\nIn the first example, a file name is read from an HTTP request and then used to access a file. However, a malicious user could enter a file name that is an absolute path, such as `\"/etc/passwd\"`.\n\nIn the second example, it appears that the user is restricted to opening a file within the `\"user\"` home directory. However, a malicious user could enter a file name containing special characters. For example, the string `\"../../../etc/passwd\"` will result in the code reading the file located at `\"/server/static/images/../../../etc/passwd\"`, which is the system's password file. This file would then be sent back to the user, giving them access to all the system's passwords. Note that a user could also use an absolute path here, since the result of `os.path.join(\"/server/static/images/\", \"/etc/passwd\")` is `\"/etc/passwd\"`.\n\nIn the third example, the path used to access the file system is normalized *before* being checked against a known prefix. This ensures that regardless of the user input, the resulting path is safe.\n\n\n```python\nimport os.path\nfrom flask import Flask, request, abort\n\napp = Flask(__name__)\n\n@app.route(\"/user_picture1\")\ndef user_picture1():\n    filename = request.args.get('p')\n    # BAD: This could read any file on the file system\n    data = open(filename, 'rb').read()\n    return data\n\n@app.route(\"/user_picture2\")\ndef user_picture2():\n    base_path = '/server/static/images'\n    filename = request.args.get('p')\n    # BAD: This could still read any file on the file system\n    data = open(os.path.join(base_path, filename), 'rb').read()\n    return data\n\n@app.route(\"/user_picture3\")\ndef user_picture3():\n    base_path = '/server/static/images'\n    filename = request.args.get('p')\n    #GOOD -- Verify with normalised version of path\n    fullpath = os.path.normpath(os.path.join(base_path, filename))\n    if not fullpath.startswith(base_path):\n        raise Exception(\"not allowed\")\n    data = open(fullpath, 'rb').read()\n    return data\n\n```\n\n## References\n* OWASP: [Path Traversal](https://owasp.org/www-community/attacks/Path_Traversal).\n* npm: [werkzeug.utils.secure_filename](http://werkzeug.pocoo.org/docs/utils/#werkzeug.utils.secure_filename).\n* Common Weakness Enumeration: [CWE-22](https://cwe.mitre.org/data/definitions/22.html).\n* Common Weakness Enumeration: [CWE-23](https://cwe.mitre.org/data/definitions/23.html).\n* Common Weakness Enumeration: [CWE-36](https://cwe.mitre.org/data/definitions/36.html).\n* Common Weakness Enumeration: [CWE-73](https://cwe.mitre.org/data/definitions/73.html).\n* Common Weakness Enumeration: [CWE-99](https://cwe.mitre.org/data/definitions/99.html).\n","markdown":"# Uncontrolled data used in path expression\nAccessing files using paths constructed from user-controlled data can allow an attacker to access unexpected resources. This can result in sensitive information being revealed or deleted, or an attacker being able to influence behavior by modifying unexpected files.\n\n\n## Recommendation\nValidate user input before using it to construct a file path, either using an off-the-shelf library function like `werkzeug.utils.secure_filename`, or by performing custom validation.\n\nIdeally, follow these rules:\n\n* Do not allow more than a single \".\" character.\n* Do not allow directory separators such as \"/\" or \"\\\\\" (depending on the file system).\n* Do not rely on simply replacing problematic sequences such as \"../\". For example, after applying this filter to \".../...//\", the resulting string would still be \"../\".\n* Use an allowlist of known good patterns.\n\n## Example\nIn the first example, a file name is read from an HTTP request and then used to access a file. However, a malicious user could enter a file name that is an absolute path, such as `\"/etc/passwd\"`.\n\nIn the second example, it appears that the user is restricted to opening a file within the `\"user\"` home directory. However, a malicious user could enter a file name containing special characters. For example, the string `\"../../../etc/passwd\"` will result in the code reading the file located at `\"/server/static/images/../../../etc/passwd\"`, which is the system's password file. This file would then be sent back to the user, giving them access to all the system's passwords. Note that a user could also use an absolute path here, since the result of `os.path.join(\"/server/static/images/\", \"/etc/passwd\")` is `\"/etc/passwd\"`.\n\nIn the third example, the path used to access the file system is normalized *before* being checked against a known prefix. This ensures that regardless of the user input, the resulting path is safe.\n\n\n```python\nimport os.path\nfrom flask import Flask, request, abort\n\napp = Flask(__name__)\n\n@app.route(\"/user_picture1\")\ndef user_picture1():\n    filename = request.args.get('p')\n    # BAD: This could read any file on the file system\n    data = open(filename, 'rb').read()\n    return data\n\n@app.route(\"/user_picture2\")\ndef user_picture2():\n    base_path = '/server/static/images'\n    filename = request.args.get('p')\n    # BAD: This could still read any file on the file system\n    data = open(os.path.join(base_path, filename), 'rb').read()\n    return data\n\n@app.route(\"/user_picture3\")\ndef user_picture3():\n    base_path = '/server/static/images'\n    filename = request.args.get('p')\n    #GOOD -- Verify with normalised version of path\n    fullpath = os.path.normpath(os.path.join(base_path, filename))\n    if not fullpath.startswith(base_path):\n        raise Exception(\"not allowed\")\n    data = open(fullpath, 'rb').read()\n    return data\n\n```\n\n## References\n* OWASP: [Path Traversal](https://owasp.org/www-community/attacks/Path_Traversal).\n* npm: [werkzeug.utils.secure_filename](http://werkzeug.pocoo.org/docs/utils/#werkzeug.utils.secure_filename).\n* Common Weakness Enumeration: [CWE-22](https://cwe.mitre.org/data/definitions/22.html).\n* Common Weakness Enumeration: [CWE-23](https://cwe.mitre.org/data/definitions/23.html).\n* Common Weakness Enumeration: [CWE-36](https://cwe.mitre.org/data/definitions/36.html).\n* Common Weakness Enumeration: [CWE-73](https://cwe.mitre.org/data/definitions/73.html).\n* Common Weakness Enumeration: [CWE-99](https://cwe.mitre.org/data/definitions/99.html).\n"},"properties":{"tags":["correctness","security","external/cwe/cwe-022","external/cwe/cwe-023","external/cwe/cwe-036","external/cwe/cwe-073","external/cwe/cwe-099"],"description":"Accessing paths influenced by users can allow an attacker to access unexpected resources.","id":"py/path-injection","kind":"path-problem","name":"Uncontrolled data used in path expression","precision":"high","problem.severity":"error","security-severity":"7.5","sub-severity":"high"}},{"id":"py/pam-auth-bypass","name":"py/pam-auth-bypass","shortDescription":{"text":"PAM authorization bypass due to incorrect usage"},"fullDescription":{"text":"Not using `pam_acct_mgmt` after `pam_authenticate` to check the validity of a login can lead to authorization bypass."},"defaultConfiguration":{"enabled":true,"level":"warning"},"help":{"text":"# PAM authorization bypass due to incorrect usage\nUsing only a call to `pam_authenticate` to check the validity of a login can lead to authorization bypass vulnerabilities.\n\nA `pam_authenticate` only verifies the credentials of a user. It does not check if a user has an appropriate authorization to actually login. This means a user with an expired login or a password can still access the system.\n\n\n## Recommendation\nA call to `pam_authenticate` should be followed by a call to `pam_acct_mgmt` to check if a user is allowed to login.\n\n\n## Example\nIn the following example, the code only checks the credentials of a user. Hence, in this case, a user with expired credentials can still login. This can be verified by creating a new user account, expiring it with ``` chage -E0 `username`  ``` and then trying to log in.\n\n\n```python\nlibpam                    = CDLL(find_library(\"pam\"))\n\npam_authenticate          = libpam.pam_authenticate\npam_authenticate.restype  = c_int\npam_authenticate.argtypes = [PamHandle, c_int]\n\ndef authenticate(username, password, service='login'):\n    def my_conv(n_messages, messages, p_response, app_data):\n        \"\"\"\n        Simple conversation function that responds to any prompt where the echo is off with the supplied password\n        \"\"\"\n        ...\n\n    handle = PamHandle()\n    conv   = PamConv(my_conv, 0)\n    retval = pam_start(service, username, byref(conv), byref(handle))\n\n    retval = pam_authenticate(handle, 0)\n    return retval == 0\n\n```\nThis can be avoided by calling `pam_acct_mgmt` call to verify access as has been done in the snippet shown below.\n\n\n```python\nlibpam                    = CDLL(find_library(\"pam\"))\n\npam_authenticate          = libpam.pam_authenticate\npam_authenticate.restype  = c_int\npam_authenticate.argtypes = [PamHandle, c_int]\n\npam_acct_mgmt          = libpam.pam_acct_mgmt\npam_acct_mgmt.restype  = c_int\npam_acct_mgmt.argtypes = [PamHandle, c_int]\n\ndef authenticate(username, password, service='login'):\n    def my_conv(n_messages, messages, p_response, app_data):\n        \"\"\"\n        Simple conversation function that responds to any prompt where the echo is off with the supplied password\n        \"\"\"\n        ...\n\n    handle = PamHandle()\n    conv   = PamConv(my_conv, 0)\n    retval = pam_start(service, username, byref(conv), byref(handle))\n\n    retval = pam_authenticate(handle, 0)\n    if retval == 0:\n        retval = pam_acct_mgmt(handle, 0)\n    return retval == 0\n\n```\n\n## References\n* Man-Page: [pam_acct_mgmt](https://man7.org/linux/man-pages/man3/pam_acct_mgmt.3.html)\n* Common Weakness Enumeration: [CWE-285](https://cwe.mitre.org/data/definitions/285.html).\n","markdown":"# PAM authorization bypass due to incorrect usage\nUsing only a call to `pam_authenticate` to check the validity of a login can lead to authorization bypass vulnerabilities.\n\nA `pam_authenticate` only verifies the credentials of a user. It does not check if a user has an appropriate authorization to actually login. This means a user with an expired login or a password can still access the system.\n\n\n## Recommendation\nA call to `pam_authenticate` should be followed by a call to `pam_acct_mgmt` to check if a user is allowed to login.\n\n\n## Example\nIn the following example, the code only checks the credentials of a user. Hence, in this case, a user with expired credentials can still login. This can be verified by creating a new user account, expiring it with ``` chage -E0 `username`  ``` and then trying to log in.\n\n\n```python\nlibpam                    = CDLL(find_library(\"pam\"))\n\npam_authenticate          = libpam.pam_authenticate\npam_authenticate.restype  = c_int\npam_authenticate.argtypes = [PamHandle, c_int]\n\ndef authenticate(username, password, service='login'):\n    def my_conv(n_messages, messages, p_response, app_data):\n        \"\"\"\n        Simple conversation function that responds to any prompt where the echo is off with the supplied password\n        \"\"\"\n        ...\n\n    handle = PamHandle()\n    conv   = PamConv(my_conv, 0)\n    retval = pam_start(service, username, byref(conv), byref(handle))\n\n    retval = pam_authenticate(handle, 0)\n    return retval == 0\n\n```\nThis can be avoided by calling `pam_acct_mgmt` call to verify access as has been done in the snippet shown below.\n\n\n```python\nlibpam                    = CDLL(find_library(\"pam\"))\n\npam_authenticate          = libpam.pam_authenticate\npam_authenticate.restype  = c_int\npam_authenticate.argtypes = [PamHandle, c_int]\n\npam_acct_mgmt          = libpam.pam_acct_mgmt\npam_acct_mgmt.restype  = c_int\npam_acct_mgmt.argtypes = [PamHandle, c_int]\n\ndef authenticate(username, password, service='login'):\n    def my_conv(n_messages, messages, p_response, app_data):\n        \"\"\"\n        Simple conversation function that responds to any prompt where the echo is off with the supplied password\n        \"\"\"\n        ...\n\n    handle = PamHandle()\n    conv   = PamConv(my_conv, 0)\n    retval = pam_start(service, username, byref(conv), byref(handle))\n\n    retval = pam_authenticate(handle, 0)\n    if retval == 0:\n        retval = pam_acct_mgmt(handle, 0)\n    return retval == 0\n\n```\n\n## References\n* Man-Page: [pam_acct_mgmt](https://man7.org/linux/man-pages/man3/pam_acct_mgmt.3.html)\n* Common Weakness Enumeration: [CWE-285](https://cwe.mitre.org/data/definitions/285.html).\n"},"properties":{"tags":["security","external/cwe/cwe-285"],"description":"Not using `pam_acct_mgmt` after `pam_authenticate` to check the validity of a login can lead to authorization bypass.","id":"py/pam-auth-bypass","kind":"path-problem","name":"PAM authorization bypass due to incorrect usage","precision":"high","problem.severity":"warning","security-severity":"8.1"}},{"id":"py/url-redirection","name":"py/url-redirection","shortDescription":{"text":"URL redirection from remote source"},"fullDescription":{"text":"URL redirection based on unvalidated user input may cause redirection to malicious web sites."},"defaultConfiguration":{"enabled":true,"level":"error"},"help":{"text":"# URL redirection from remote source\nDirectly incorporating user input into a URL redirect request without validating the input can facilitate phishing attacks. In these attacks, unsuspecting users can be redirected to a malicious site that looks very similar to the real site they intend to visit, but which is controlled by the attacker.\n\n\n## Recommendation\nTo guard against untrusted URL redirection, it is advisable to avoid putting user input directly into a redirect URL. Instead, maintain a list of authorized redirects on the server; then choose from that list based on the user input provided.\n\nIf this is not possible, then the user input should be validated in some other way, for example, by verifying that the target URL does not include an explicit host name.\n\n\n## Example\nThe following example shows an HTTP request parameter being used directly in a URL redirect without validating the input, which facilitates phishing attacks:\n\n\n```python\nfrom flask import Flask, request, redirect\n\napp = Flask(__name__)\n\n@app.route('/')\ndef hello():\n    target = request.args.get('target', '')\n    return redirect(target, code=302)\n\n```\nIf you know the set of valid redirect targets, you can maintain a list of them on the server and check that the user input is in that list:\n\n\n```python\nfrom flask import Flask, request, redirect\n\nVALID_REDIRECT = \"http://cwe.mitre.org/data/definitions/601.html\"\n\napp = Flask(__name__)\n\n@app.route('/')\ndef hello():\n    target = request.args.get('target', '')\n    if target == VALID_REDIRECT:\n        return redirect(target, code=302)\n    else:\n        # ignore the target and redirect to the home page\n        return redirect('/', code=302)\n\n```\nOften this is not possible, so an alternative is to check that the target URL does not specify an explicit host name. For example, you can use the `urlparse` function from the Python standard library to parse the URL and check that the `netloc` attribute is empty.\n\nNote, however, that some cases are not handled as we desire out-of-the-box by `urlparse`, so we need to adjust two things, as shown in the example below:\n\n* Many browsers accept backslash characters (`\\`) as equivalent to forward slash characters (`/`) in URLs, but the `urlparse` function does not.\n* Mistyped URLs such as `https:/example.com` or `https:///example.com` are parsed as having an empty `netloc` attribute, while browsers will still redirect to the correct site.\n\n```python\nfrom flask import Flask, request, redirect\nfrom urllib.parse import urlparse\n\napp = Flask(__name__)\n\n@app.route('/')\ndef hello():\n    target = request.args.get('target', '')\n    target = target.replace('\\\\', '')\n    if not urlparse(target).netloc and not urlparse(target).scheme:\n        # relative path, safe to redirect\n        return redirect(target, code=302)\n    # ignore the target and redirect to the home page\n    return redirect('/', code=302)\n\n```\nFor Django application, you can use the function `url_has_allowed_host_and_scheme` to check that a URL is safe to redirect to, as shown in the following example:\n\n\n```python\nfrom django.http import HttpResponseRedirect\nfrom django.shortcuts import redirect\nfrom django.utils.http import url_has_allowed_host_and_scheme\nfrom django.views import View\n\nclass RedirectView(View):\n    def get(self, request, *args, **kwargs):\n        target = request.GET.get('target', '')\n        if url_has_allowed_host_and_scheme(target, allowed_hosts=None):\n            return HttpResponseRedirect(target)\n        else:\n            # ignore the target and redirect to the home page\n            return redirect('/')\n```\nNote that `url_has_allowed_host_and_scheme` handles backslashes correctly, so no additional processing is required.\n\n\n## References\n* OWASP: [ XSS Unvalidated Redirects and Forwards Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/Unvalidated_Redirects_and_Forwards_Cheat_Sheet.html).\n* Python standard library: [ urllib.parse](https://docs.python.org/3/library/urllib.parse.html).\n* Common Weakness Enumeration: [CWE-601](https://cwe.mitre.org/data/definitions/601.html).\n","markdown":"# URL redirection from remote source\nDirectly incorporating user input into a URL redirect request without validating the input can facilitate phishing attacks. In these attacks, unsuspecting users can be redirected to a malicious site that looks very similar to the real site they intend to visit, but which is controlled by the attacker.\n\n\n## Recommendation\nTo guard against untrusted URL redirection, it is advisable to avoid putting user input directly into a redirect URL. Instead, maintain a list of authorized redirects on the server; then choose from that list based on the user input provided.\n\nIf this is not possible, then the user input should be validated in some other way, for example, by verifying that the target URL does not include an explicit host name.\n\n\n## Example\nThe following example shows an HTTP request parameter being used directly in a URL redirect without validating the input, which facilitates phishing attacks:\n\n\n```python\nfrom flask import Flask, request, redirect\n\napp = Flask(__name__)\n\n@app.route('/')\ndef hello():\n    target = request.args.get('target', '')\n    return redirect(target, code=302)\n\n```\nIf you know the set of valid redirect targets, you can maintain a list of them on the server and check that the user input is in that list:\n\n\n```python\nfrom flask import Flask, request, redirect\n\nVALID_REDIRECT = \"http://cwe.mitre.org/data/definitions/601.html\"\n\napp = Flask(__name__)\n\n@app.route('/')\ndef hello():\n    target = request.args.get('target', '')\n    if target == VALID_REDIRECT:\n        return redirect(target, code=302)\n    else:\n        # ignore the target and redirect to the home page\n        return redirect('/', code=302)\n\n```\nOften this is not possible, so an alternative is to check that the target URL does not specify an explicit host name. For example, you can use the `urlparse` function from the Python standard library to parse the URL and check that the `netloc` attribute is empty.\n\nNote, however, that some cases are not handled as we desire out-of-the-box by `urlparse`, so we need to adjust two things, as shown in the example below:\n\n* Many browsers accept backslash characters (`\\`) as equivalent to forward slash characters (`/`) in URLs, but the `urlparse` function does not.\n* Mistyped URLs such as `https:/example.com` or `https:///example.com` are parsed as having an empty `netloc` attribute, while browsers will still redirect to the correct site.\n\n```python\nfrom flask import Flask, request, redirect\nfrom urllib.parse import urlparse\n\napp = Flask(__name__)\n\n@app.route('/')\ndef hello():\n    target = request.args.get('target', '')\n    target = target.replace('\\\\', '')\n    if not urlparse(target).netloc and not urlparse(target).scheme:\n        # relative path, safe to redirect\n        return redirect(target, code=302)\n    # ignore the target and redirect to the home page\n    return redirect('/', code=302)\n\n```\nFor Django application, you can use the function `url_has_allowed_host_and_scheme` to check that a URL is safe to redirect to, as shown in the following example:\n\n\n```python\nfrom django.http import HttpResponseRedirect\nfrom django.shortcuts import redirect\nfrom django.utils.http import url_has_allowed_host_and_scheme\nfrom django.views import View\n\nclass RedirectView(View):\n    def get(self, request, *args, **kwargs):\n        target = request.GET.get('target', '')\n        if url_has_allowed_host_and_scheme(target, allowed_hosts=None):\n            return HttpResponseRedirect(target)\n        else:\n            # ignore the target and redirect to the home page\n            return redirect('/')\n```\nNote that `url_has_allowed_host_and_scheme` handles backslashes correctly, so no additional processing is required.\n\n\n## References\n* OWASP: [ XSS Unvalidated Redirects and Forwards Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/Unvalidated_Redirects_and_Forwards_Cheat_Sheet.html).\n* Python standard library: [ urllib.parse](https://docs.python.org/3/library/urllib.parse.html).\n* Common Weakness Enumeration: [CWE-601](https://cwe.mitre.org/data/definitions/601.html).\n"},"properties":{"tags":["security","external/cwe/cwe-601"],"description":"URL redirection based on unvalidated user input\n              may cause redirection to malicious web sites.","id":"py/url-redirection","kind":"path-problem","name":"URL redirection from remote source","precision":"high","problem.severity":"error","security-severity":"6.1","sub-severity":"low"}},{"id":"py/flask-debug","name":"py/flask-debug","shortDescription":{"text":"Flask app is run in debug mode"},"fullDescription":{"text":"Running a Flask app in debug mode may allow an attacker to run arbitrary code through the Werkzeug debugger."},"defaultConfiguration":{"enabled":true,"level":"error"},"help":{"text":"# Flask app is run in debug mode\nRunning a Flask application with debug mode enabled may allow an attacker to gain access through the Werkzeug debugger.\n\n\n## Recommendation\nEnsure that Flask applications that are run in a production environment have debugging disabled.\n\n\n## Example\nRunning the following code starts a Flask webserver that has debugging enabled. By visiting `/crash`, it is possible to gain access to the debugger, and run arbitrary code through the interactive debugger.\n\n\n```python\nfrom flask import Flask\n\napp = Flask(__name__)\n\n@app.route('/crash')\ndef main():\n    raise Exception()\n\napp.run(debug=True)\n\n```\n\n## References\n* Flask Quickstart Documentation: [Debug Mode](http://flask.pocoo.org/docs/1.0/quickstart/#debug-mode).\n* Werkzeug Documentation: [Debugging Applications](http://werkzeug.pocoo.org/docs/0.14/debug/).\n* Common Weakness Enumeration: [CWE-215](https://cwe.mitre.org/data/definitions/215.html).\n* Common Weakness Enumeration: [CWE-489](https://cwe.mitre.org/data/definitions/489.html).\n","markdown":"# Flask app is run in debug mode\nRunning a Flask application with debug mode enabled may allow an attacker to gain access through the Werkzeug debugger.\n\n\n## Recommendation\nEnsure that Flask applications that are run in a production environment have debugging disabled.\n\n\n## Example\nRunning the following code starts a Flask webserver that has debugging enabled. By visiting `/crash`, it is possible to gain access to the debugger, and run arbitrary code through the interactive debugger.\n\n\n```python\nfrom flask import Flask\n\napp = Flask(__name__)\n\n@app.route('/crash')\ndef main():\n    raise Exception()\n\napp.run(debug=True)\n\n```\n\n## References\n* Flask Quickstart Documentation: [Debug Mode](http://flask.pocoo.org/docs/1.0/quickstart/#debug-mode).\n* Werkzeug Documentation: [Debugging Applications](http://werkzeug.pocoo.org/docs/0.14/debug/).\n* Common Weakness Enumeration: [CWE-215](https://cwe.mitre.org/data/definitions/215.html).\n* Common Weakness Enumeration: [CWE-489](https://cwe.mitre.org/data/definitions/489.html).\n"},"properties":{"tags":["security","external/cwe/cwe-215","external/cwe/cwe-489"],"description":"Running a Flask app in debug mode may allow an attacker to run arbitrary code through the Werkzeug debugger.","id":"py/flask-debug","kind":"problem","name":"Flask app is run in debug mode","precision":"high","problem.severity":"error","security-severity":"7.5"}},{"id":"py/sql-injection","name":"py/sql-injection","shortDescription":{"text":"SQL query built from user-controlled sources"},"fullDescription":{"text":"Building a SQL query from user-controlled sources is vulnerable to insertion of malicious SQL code by the user."},"defaultConfiguration":{"enabled":true,"level":"error"},"help":{"text":"# SQL query built from user-controlled sources\nIf a database query (such as a SQL or NoSQL query) is built from user-provided data without sufficient sanitization, a user may be able to run malicious database queries.\n\nThis also includes using the `TextClause` class in the `[SQLAlchemy](https://pypi.org/project/SQLAlchemy/)` PyPI package, which is used to represent a literal SQL fragment and is inserted directly into the final SQL when used in a query built using the ORM.\n\n\n## Recommendation\nMost database connector libraries offer a way of safely embedding untrusted data into a query by means of query parameters or prepared statements.\n\n\n## Example\nIn the following snippet, a user is fetched from the database using three different queries.\n\nIn the first case, the query string is built by directly using string formatting from a user-supplied request parameter. The parameter may include quote characters, so this code is vulnerable to a SQL injection attack.\n\nIn the second case, the user-supplied request attribute is passed to the database using query parameters. The database connector library will take care of escaping and inserting quotes as needed.\n\nIn the third case, the placeholder in the SQL string has been manually quoted. Since most databaseconnector libraries will insert their own quotes, doing so yourself will make the code vulnerable to SQL injection attacks. In this example, if `username` was `; DROP ALL TABLES -- `, the final SQL query would be `SELECT * FROM users WHERE username = ''; DROP ALL TABLES -- ''`\n\n\n```python\nfrom django.conf.urls import url\nfrom django.db import connection\n\n\ndef show_user(request, username):\n    with connection.cursor() as cursor:\n        # BAD -- Using string formatting\n        cursor.execute(\"SELECT * FROM users WHERE username = '%s'\" % username)\n        user = cursor.fetchone()\n\n        # GOOD -- Using parameters\n        cursor.execute(\"SELECT * FROM users WHERE username = %s\", username)\n        user = cursor.fetchone()\n\n        # BAD -- Manually quoting placeholder (%s)\n        cursor.execute(\"SELECT * FROM users WHERE username = '%s'\", username)\n        user = cursor.fetchone()\n\nurlpatterns = [url(r'^users/(?P<username>[^/]+)$', show_user)]\n\n```\n\n## References\n* Wikipedia: [SQL injection](https://en.wikipedia.org/wiki/SQL_injection).\n* OWASP: [SQL Injection Prevention Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/SQL_Injection_Prevention_Cheat_Sheet.html).\n* [SQLAlchemy documentation for TextClause](https://docs.sqlalchemy.org/en/14/core/sqlelement.html#sqlalchemy.sql.expression.text.params.text).\n* Common Weakness Enumeration: [CWE-89](https://cwe.mitre.org/data/definitions/89.html).\n","markdown":"# SQL query built from user-controlled sources\nIf a database query (such as a SQL or NoSQL query) is built from user-provided data without sufficient sanitization, a user may be able to run malicious database queries.\n\nThis also includes using the `TextClause` class in the `[SQLAlchemy](https://pypi.org/project/SQLAlchemy/)` PyPI package, which is used to represent a literal SQL fragment and is inserted directly into the final SQL when used in a query built using the ORM.\n\n\n## Recommendation\nMost database connector libraries offer a way of safely embedding untrusted data into a query by means of query parameters or prepared statements.\n\n\n## Example\nIn the following snippet, a user is fetched from the database using three different queries.\n\nIn the first case, the query string is built by directly using string formatting from a user-supplied request parameter. The parameter may include quote characters, so this code is vulnerable to a SQL injection attack.\n\nIn the second case, the user-supplied request attribute is passed to the database using query parameters. The database connector library will take care of escaping and inserting quotes as needed.\n\nIn the third case, the placeholder in the SQL string has been manually quoted. Since most databaseconnector libraries will insert their own quotes, doing so yourself will make the code vulnerable to SQL injection attacks. In this example, if `username` was `; DROP ALL TABLES -- `, the final SQL query would be `SELECT * FROM users WHERE username = ''; DROP ALL TABLES -- ''`\n\n\n```python\nfrom django.conf.urls import url\nfrom django.db import connection\n\n\ndef show_user(request, username):\n    with connection.cursor() as cursor:\n        # BAD -- Using string formatting\n        cursor.execute(\"SELECT * FROM users WHERE username = '%s'\" % username)\n        user = cursor.fetchone()\n\n        # GOOD -- Using parameters\n        cursor.execute(\"SELECT * FROM users WHERE username = %s\", username)\n        user = cursor.fetchone()\n\n        # BAD -- Manually quoting placeholder (%s)\n        cursor.execute(\"SELECT * FROM users WHERE username = '%s'\", username)\n        user = cursor.fetchone()\n\nurlpatterns = [url(r'^users/(?P<username>[^/]+)$', show_user)]\n\n```\n\n## References\n* Wikipedia: [SQL injection](https://en.wikipedia.org/wiki/SQL_injection).\n* OWASP: [SQL Injection Prevention Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/SQL_Injection_Prevention_Cheat_Sheet.html).\n* [SQLAlchemy documentation for TextClause](https://docs.sqlalchemy.org/en/14/core/sqlelement.html#sqlalchemy.sql.expression.text.params.text).\n* Common Weakness Enumeration: [CWE-89](https://cwe.mitre.org/data/definitions/89.html).\n"},"properties":{"tags":["security","external/cwe/cwe-089"],"description":"Building a SQL query from user-controlled sources is vulnerable to insertion of\n              malicious SQL code by the user.","id":"py/sql-injection","kind":"path-problem","name":"SQL query built from user-controlled sources","precision":"high","problem.severity":"error","security-severity":"8.8"}},{"id":"py/xxe","name":"py/xxe","shortDescription":{"text":"XML external entity expansion"},"fullDescription":{"text":"Parsing user input as an XML document with external entity expansion is vulnerable to XXE attacks."},"defaultConfiguration":{"enabled":true,"level":"error"},"help":{"text":"# XML external entity expansion\nParsing untrusted XML files with a weakly configured XML parser may lead to an XML External Entity (XXE) attack. This type of attack uses external entity references to access arbitrary files on a system, carry out denial-of-service (DoS) attacks, or server-side request forgery. Even when the result of parsing is not returned to the user, DoS attacks are still possible and out-of-band data retrieval techniques may allow attackers to steal sensitive data.\n\n\n## Recommendation\nThe easiest way to prevent XXE attacks is to disable external entity handling when parsing untrusted data. How this is done depends on the library being used. Note that some libraries, such as recent versions of the XML libraries in the standard library of Python 3, disable entity expansion by default, so unless you have explicitly enabled entity expansion, no further action needs to be taken.\n\nWe recommend using the [defusedxml](https://pypi.org/project/defusedxml/) PyPI package, which has been created to prevent XML attacks (both XXE and XML bombs).\n\n\n## Example\nThe following example uses the `lxml` XML parser to parse a string `xml_src`. That string is from an untrusted source, so this code is vulnerable to an XXE attack, since the [ default parser](https://lxml.de/apidoc/lxml.etree.html#lxml.etree.XMLParser) from `lxml.etree` allows local external entities to be resolved.\n\n\n```python\nfrom flask import Flask, request\nimport lxml.etree\n\napp = Flask(__name__)\n\n@app.post(\"/upload\")\ndef upload():\n    xml_src = request.get_data()\n    doc = lxml.etree.fromstring(xml_src)\n    return lxml.etree.tostring(doc)\n\n```\nTo guard against XXE attacks with the `lxml` library, you should create a parser with `resolve_entities` set to `false`. This means that no entity expansion is undertaken, although standard predefined entities such as `&gt;`, for writing `>` inside the text of an XML element, are still allowed.\n\n\n```python\nfrom flask import Flask, request\nimport lxml.etree\n\napp = Flask(__name__)\n\n@app.post(\"/upload\")\ndef upload():\n    xml_src = request.get_data()\n    parser = lxml.etree.XMLParser(resolve_entities=False)\n    doc = lxml.etree.fromstring(xml_src, parser=parser)\n    return lxml.etree.tostring(doc)\n\n```\n\n## References\n* OWASP: [XML External Entity (XXE) Processing](https://www.owasp.org/index.php/XML_External_Entity_(XXE)_Processing).\n* Timothy Morgen: [XML Schema, DTD, and Entity Attacks](https://research.nccgroup.com/2014/05/19/xml-schema-dtd-and-entity-attacks-a-compendium-of-known-techniques/).\n* Timur Yunusov, Alexey Osipov: [XML Out-Of-Band Data Retrieval](https://www.slideshare.net/qqlan/bh-ready-v4).\n* Python 3 standard library: [XML Vulnerabilities](https://docs.python.org/3/library/xml.html#xml-vulnerabilities).\n* Python 2 standard library: [XML Vulnerabilities](https://docs.python.org/2/library/xml.html#xml-vulnerabilities).\n* PortSwigger: [XML external entity (XXE) injection](https://portswigger.net/web-security/xxe).\n* Common Weakness Enumeration: [CWE-611](https://cwe.mitre.org/data/definitions/611.html).\n* Common Weakness Enumeration: [CWE-827](https://cwe.mitre.org/data/definitions/827.html).\n","markdown":"# XML external entity expansion\nParsing untrusted XML files with a weakly configured XML parser may lead to an XML External Entity (XXE) attack. This type of attack uses external entity references to access arbitrary files on a system, carry out denial-of-service (DoS) attacks, or server-side request forgery. Even when the result of parsing is not returned to the user, DoS attacks are still possible and out-of-band data retrieval techniques may allow attackers to steal sensitive data.\n\n\n## Recommendation\nThe easiest way to prevent XXE attacks is to disable external entity handling when parsing untrusted data. How this is done depends on the library being used. Note that some libraries, such as recent versions of the XML libraries in the standard library of Python 3, disable entity expansion by default, so unless you have explicitly enabled entity expansion, no further action needs to be taken.\n\nWe recommend using the [defusedxml](https://pypi.org/project/defusedxml/) PyPI package, which has been created to prevent XML attacks (both XXE and XML bombs).\n\n\n## Example\nThe following example uses the `lxml` XML parser to parse a string `xml_src`. That string is from an untrusted source, so this code is vulnerable to an XXE attack, since the [ default parser](https://lxml.de/apidoc/lxml.etree.html#lxml.etree.XMLParser) from `lxml.etree` allows local external entities to be resolved.\n\n\n```python\nfrom flask import Flask, request\nimport lxml.etree\n\napp = Flask(__name__)\n\n@app.post(\"/upload\")\ndef upload():\n    xml_src = request.get_data()\n    doc = lxml.etree.fromstring(xml_src)\n    return lxml.etree.tostring(doc)\n\n```\nTo guard against XXE attacks with the `lxml` library, you should create a parser with `resolve_entities` set to `false`. This means that no entity expansion is undertaken, although standard predefined entities such as `&gt;`, for writing `>` inside the text of an XML element, are still allowed.\n\n\n```python\nfrom flask import Flask, request\nimport lxml.etree\n\napp = Flask(__name__)\n\n@app.post(\"/upload\")\ndef upload():\n    xml_src = request.get_data()\n    parser = lxml.etree.XMLParser(resolve_entities=False)\n    doc = lxml.etree.fromstring(xml_src, parser=parser)\n    return lxml.etree.tostring(doc)\n\n```\n\n## References\n* OWASP: [XML External Entity (XXE) Processing](https://www.owasp.org/index.php/XML_External_Entity_(XXE)_Processing).\n* Timothy Morgen: [XML Schema, DTD, and Entity Attacks](https://research.nccgroup.com/2014/05/19/xml-schema-dtd-and-entity-attacks-a-compendium-of-known-techniques/).\n* Timur Yunusov, Alexey Osipov: [XML Out-Of-Band Data Retrieval](https://www.slideshare.net/qqlan/bh-ready-v4).\n* Python 3 standard library: [XML Vulnerabilities](https://docs.python.org/3/library/xml.html#xml-vulnerabilities).\n* Python 2 standard library: [XML Vulnerabilities](https://docs.python.org/2/library/xml.html#xml-vulnerabilities).\n* PortSwigger: [XML external entity (XXE) injection](https://portswigger.net/web-security/xxe).\n* Common Weakness Enumeration: [CWE-611](https://cwe.mitre.org/data/definitions/611.html).\n* Common Weakness Enumeration: [CWE-827](https://cwe.mitre.org/data/definitions/827.html).\n"},"properties":{"tags":["security","external/cwe/cwe-611","external/cwe/cwe-827"],"description":"Parsing user input as an XML document with external\n              entity expansion is vulnerable to XXE attacks.","id":"py/xxe","kind":"path-problem","name":"XML external entity expansion","precision":"high","problem.severity":"error","security-severity":"9.1"}},{"id":"py/use-of-input","name":"py/use-of-input","shortDescription":{"text":"'input' function used in Python 2"},"fullDescription":{"text":"The built-in function 'input' is used which, in Python 2, can allow arbitrary code to be run."},"defaultConfiguration":{"enabled":true,"level":"error"},"help":{"text":"# 'input' function used in Python 2\nIn Python 2, a call to the `input()` function, `input(prompt)` is equivalent to `eval(raw_input(prompt))`. Evaluating user input without any checking can be a serious security flaw.\n\n\n## Recommendation\nGet user input with `raw_input(prompt)` and then validate that input before evaluating. If the expected input is a number or string, then `ast.literal_eval()` can always be used safely.\n\n\n## References\n* Python Standard Library: [input](http://docs.python.org/2/library/functions.html#input), [ast.literal_eval](http://docs.python.org/2/library/ast.html#ast.literal_eval).\n* Wikipedia: [Data validation](http://en.wikipedia.org/wiki/Data_validation).\n* Common Weakness Enumeration: [CWE-94](https://cwe.mitre.org/data/definitions/94.html).\n* Common Weakness Enumeration: [CWE-95](https://cwe.mitre.org/data/definitions/95.html).\n","markdown":"# 'input' function used in Python 2\nIn Python 2, a call to the `input()` function, `input(prompt)` is equivalent to `eval(raw_input(prompt))`. Evaluating user input without any checking can be a serious security flaw.\n\n\n## Recommendation\nGet user input with `raw_input(prompt)` and then validate that input before evaluating. If the expected input is a number or string, then `ast.literal_eval()` can always be used safely.\n\n\n## References\n* Python Standard Library: [input](http://docs.python.org/2/library/functions.html#input), [ast.literal_eval](http://docs.python.org/2/library/ast.html#ast.literal_eval).\n* Wikipedia: [Data validation](http://en.wikipedia.org/wiki/Data_validation).\n* Common Weakness Enumeration: [CWE-94](https://cwe.mitre.org/data/definitions/94.html).\n* Common Weakness Enumeration: [CWE-95](https://cwe.mitre.org/data/definitions/95.html).\n"},"properties":{"tags":["security","correctness","external/cwe/cwe-094","external/cwe/cwe-095"],"description":"The built-in function 'input' is used which, in Python 2, can allow arbitrary code to be run.","id":"py/use-of-input","kind":"problem","name":"'input' function used in Python 2","precision":"high","problem.severity":"error","security-severity":"9.8","sub-severity":"high"}},{"id":"py/request-without-cert-validation","name":"py/request-without-cert-validation","shortDescription":{"text":"Request without certificate validation"},"fullDescription":{"text":"Making a request without certificate validation can allow man-in-the-middle attacks."},"defaultConfiguration":{"enabled":true,"level":"error"},"help":{"text":"# Request without certificate validation\nEncryption is key to the security of most, if not all, online communication. Using Transport Layer Security (TLS) can ensure that communication cannot be interrupted by an interloper. For this reason, it is unwise to disable the verification that TLS provides. Functions in the `requests` module provide verification by default, and it is only when explicitly turned off using `verify=False` that no verification occurs.\n\n\n## Recommendation\nNever use `verify=False` when making a request.\n\n\n## Example\nThe example shows two unsafe calls to [semmle.com](https://semmle.com), followed by various safe alternatives.\n\n\n```python\nimport requests\n\n#Unsafe requests\n\nrequests.get('https://semmle.com', verify=False) # UNSAFE\nrequests.get('https://semmle.com', verify=0) # UNSAFE\n\n#Various safe options\n\nrequests.get('https://semmle.com', verify=True) # Explicitly safe\nrequests.get('https://semmle.com', verify=\"/path/to/cert/\")\nrequests.get('https://semmle.com') # The default is to verify.\n\n#Wrapper to ensure safety\n\ndef make_safe_request(url, verify_cert):\n    if not verify_cert:\n        raise Exception(\"Trying to make unsafe request\")\n    return requests.get(url, verify_cert)\n\n```\n\n## References\n* Python requests documentation: [SSL Cert Verification](https://requests.readthedocs.io/en/latest/user/advanced/#ssl-cert-verification).\n* Common Weakness Enumeration: [CWE-295](https://cwe.mitre.org/data/definitions/295.html).\n","markdown":"# Request without certificate validation\nEncryption is key to the security of most, if not all, online communication. Using Transport Layer Security (TLS) can ensure that communication cannot be interrupted by an interloper. For this reason, it is unwise to disable the verification that TLS provides. Functions in the `requests` module provide verification by default, and it is only when explicitly turned off using `verify=False` that no verification occurs.\n\n\n## Recommendation\nNever use `verify=False` when making a request.\n\n\n## Example\nThe example shows two unsafe calls to [semmle.com](https://semmle.com), followed by various safe alternatives.\n\n\n```python\nimport requests\n\n#Unsafe requests\n\nrequests.get('https://semmle.com', verify=False) # UNSAFE\nrequests.get('https://semmle.com', verify=0) # UNSAFE\n\n#Various safe options\n\nrequests.get('https://semmle.com', verify=True) # Explicitly safe\nrequests.get('https://semmle.com', verify=\"/path/to/cert/\")\nrequests.get('https://semmle.com') # The default is to verify.\n\n#Wrapper to ensure safety\n\ndef make_safe_request(url, verify_cert):\n    if not verify_cert:\n        raise Exception(\"Trying to make unsafe request\")\n    return requests.get(url, verify_cert)\n\n```\n\n## References\n* Python requests documentation: [SSL Cert Verification](https://requests.readthedocs.io/en/latest/user/advanced/#ssl-cert-verification).\n* Common Weakness Enumeration: [CWE-295](https://cwe.mitre.org/data/definitions/295.html).\n"},"properties":{"tags":["security","external/cwe/cwe-295"],"description":"Making a request without certificate validation can allow man-in-the-middle attacks.","id":"py/request-without-cert-validation","kind":"problem","name":"Request without certificate validation","precision":"medium","problem.severity":"error","security-severity":"7.5"}},{"id":"py/partial-ssrf","name":"py/partial-ssrf","shortDescription":{"text":"Partial server-side request forgery"},"fullDescription":{"text":"Making a network request to a URL that is partially user-controlled allows for request forgery attacks."},"defaultConfiguration":{"enabled":true,"level":"error"},"help":{"text":"# Partial server-side request forgery\nDirectly incorporating user input into an HTTP request without validating the input can facilitate server-side request forgery (SSRF) attacks. In these attacks, the request may be changed, directed at a different server, or via a different protocol. This can allow the attacker to obtain sensitive information or perform actions with escalated privilege.\n\nWe make a distinctions between how much of the URL an attacker can control:\n\n* **Full SSRF**: where the full URL can be controlled.\n* **Partial SSRF**: where only part of the URL can be controlled, such as the path component of a URL to a hardcoded domain.\n\n\nPartial control of a URL is often much harder to exploit. Therefore we have created a separate query for each of these.\n\nThis query covers partial SSRF, to find full SSRF use the `py/full-ssrf` query.\n\n\n## Recommendation\nTo guard against SSRF attacks you should avoid putting user-provided input directly into a request URL. On the application level, maintain a list of authorized URLs on the server and choose from that list based on the input provided. If that is not possible, one should verify the IP address for all user-controlled requests to ensure they are not private. This requires saving the verified IP address of each domain, then utilizing a custom HTTP adapter to ensure that future requests to that domain use the verified IP address. On the network level, you can segment the vulnerable application into its own LAN or block access to specific devices.\n\n\n## Example\nThe following example shows code vulnerable to a full SSRF attack, because it uses untrusted input (HTTP request parameter) directly to construct a URL. By using `evil.com#` as the `target` value, the requested URL will be `https://evil.com#.example.com/data/`. It also shows how to remedy the problem by using the user input select a known fixed string.\n\n\n```python\nimport requests\nfrom flask import Flask, request\n\napp = Flask(__name__)\n\n@app.route(\"/full_ssrf\")\ndef full_ssrf():\n    target = request.args[\"target\"]\n\n    # BAD: user has full control of URL\n    resp = requests.get(\"https://\" + target + \".example.com/data/\")\n\n    # GOOD: `subdomain` is controlled by the server.\n    subdomain = \"europe\" if target == \"EU\" else \"world\"\n    resp = requests.get(\"https://\" + subdomain + \".example.com/data/\")\n\n```\n\n## Example\nThe following example shows code vulnerable to a partial SSRF attack, because it uses untrusted input (HTTP request parameter) directly to construct a URL. By using `../transfer-funds-to/123?amount=456` as the `user_id` value, the requested URL will be `https://api.example.com/transfer-funds-to/123?amount=456`. It also shows how to remedy the problem by validating the input.\n\n\n```python\nimport requests\nfrom flask import Flask, request\n\napp = Flask(__name__)\n\n@app.route(\"/partial_ssrf\")\ndef partial_ssrf():\n    user_id = request.args[\"user_id\"]\n\n    # BAD: user can fully control the path component of the URL\n    resp = requests.get(\"https://api.example.com/user_info/\" + user_id)\n\n    if user_id.isalnum():\n        # GOOD: user_id is restricted to be alpha-numeric, and cannot alter path component of URL\n        resp = requests.get(\"https://api.example.com/user_info/\" + user_id)\n\n```\n\n## References\n* [OWASP SSRF article](https://owasp.org/www-community/attacks/Server_Side_Request_Forgery)\n* [PortSwigger SSRF article](https://portswigger.net/web-security/ssrf)\n* Common Weakness Enumeration: [CWE-918](https://cwe.mitre.org/data/definitions/918.html).\n","markdown":"# Partial server-side request forgery\nDirectly incorporating user input into an HTTP request without validating the input can facilitate server-side request forgery (SSRF) attacks. In these attacks, the request may be changed, directed at a different server, or via a different protocol. This can allow the attacker to obtain sensitive information or perform actions with escalated privilege.\n\nWe make a distinctions between how much of the URL an attacker can control:\n\n* **Full SSRF**: where the full URL can be controlled.\n* **Partial SSRF**: where only part of the URL can be controlled, such as the path component of a URL to a hardcoded domain.\n\n\nPartial control of a URL is often much harder to exploit. Therefore we have created a separate query for each of these.\n\nThis query covers partial SSRF, to find full SSRF use the `py/full-ssrf` query.\n\n\n## Recommendation\nTo guard against SSRF attacks you should avoid putting user-provided input directly into a request URL. On the application level, maintain a list of authorized URLs on the server and choose from that list based on the input provided. If that is not possible, one should verify the IP address for all user-controlled requests to ensure they are not private. This requires saving the verified IP address of each domain, then utilizing a custom HTTP adapter to ensure that future requests to that domain use the verified IP address. On the network level, you can segment the vulnerable application into its own LAN or block access to specific devices.\n\n\n## Example\nThe following example shows code vulnerable to a full SSRF attack, because it uses untrusted input (HTTP request parameter) directly to construct a URL. By using `evil.com#` as the `target` value, the requested URL will be `https://evil.com#.example.com/data/`. It also shows how to remedy the problem by using the user input select a known fixed string.\n\n\n```python\nimport requests\nfrom flask import Flask, request\n\napp = Flask(__name__)\n\n@app.route(\"/full_ssrf\")\ndef full_ssrf():\n    target = request.args[\"target\"]\n\n    # BAD: user has full control of URL\n    resp = requests.get(\"https://\" + target + \".example.com/data/\")\n\n    # GOOD: `subdomain` is controlled by the server.\n    subdomain = \"europe\" if target == \"EU\" else \"world\"\n    resp = requests.get(\"https://\" + subdomain + \".example.com/data/\")\n\n```\n\n## Example\nThe following example shows code vulnerable to a partial SSRF attack, because it uses untrusted input (HTTP request parameter) directly to construct a URL. By using `../transfer-funds-to/123?amount=456` as the `user_id` value, the requested URL will be `https://api.example.com/transfer-funds-to/123?amount=456`. It also shows how to remedy the problem by validating the input.\n\n\n```python\nimport requests\nfrom flask import Flask, request\n\napp = Flask(__name__)\n\n@app.route(\"/partial_ssrf\")\ndef partial_ssrf():\n    user_id = request.args[\"user_id\"]\n\n    # BAD: user can fully control the path component of the URL\n    resp = requests.get(\"https://api.example.com/user_info/\" + user_id)\n\n    if user_id.isalnum():\n        # GOOD: user_id is restricted to be alpha-numeric, and cannot alter path component of URL\n        resp = requests.get(\"https://api.example.com/user_info/\" + user_id)\n\n```\n\n## References\n* [OWASP SSRF article](https://owasp.org/www-community/attacks/Server_Side_Request_Forgery)\n* [PortSwigger SSRF article](https://portswigger.net/web-security/ssrf)\n* Common Weakness Enumeration: [CWE-918](https://cwe.mitre.org/data/definitions/918.html).\n"},"properties":{"tags":["security","external/cwe/cwe-918"],"description":"Making a network request to a URL that is partially user-controlled allows for request forgery attacks.","id":"py/partial-ssrf","kind":"path-problem","name":"Partial server-side request forgery","precision":"medium","problem.severity":"error","security-severity":"9.1"}},{"id":"py/log-injection","name":"py/log-injection","shortDescription":{"text":"Log Injection"},"fullDescription":{"text":"Building log entries from user-controlled data is vulnerable to insertion of forged log entries by a malicious user."},"defaultConfiguration":{"enabled":true,"level":"error"},"help":{"text":"# Log Injection\nIf unsanitized user input is written to a log entry, a malicious user may be able to forge new log entries.\n\nForgery can occur if a user provides some input with characters that are interpreted when the log output is displayed. If the log is displayed as a plain text file, then new line characters can be used by a malicious user to create the appearance of multiple log entries. If the log is displayed as HTML, then arbitrary HTML may be included to spoof log entries.\n\n\n## Recommendation\nUser input should be suitably sanitized before it is logged.\n\nIf the log entries are plain text then line breaks should be removed from user input, using for example `replace(old, new)` or similar. Care should also be taken that user input is clearly marked in log entries, and that a malicious user cannot cause confusion in other ways.\n\nFor log entries that will be displayed in HTML, user input should be HTML encoded before being logged, to prevent forgery and other forms of HTML injection.\n\n\n## Example\nIn the example, the name provided by the user is recorded using the log output function (`logging.info` or `app.logger.info`, etc.). In these four cases, the name provided by the user is not provided The processing is recorded. If a malicious user provides `Guest%0D%0AUser name: Admin` as a parameter, the log entry will be divided into two lines, the first line is `User name: Guest` code&gt;, the second line is `User name: Admin`.\n\n\n```python\n#!/usr/bin/env python\n# -*- coding: UTF-8 -*-\n\"\"\"\n@Desc   ：Log Injection\n\"\"\"\nfrom flask import Flask\nfrom flask import request\nfrom django.utils.log import request_logger\nimport logging\n\nlogging.basicConfig(level=logging.DEBUG)\n\napp = Flask(__name__)\n\n@app.route('/bad1')\ndef bad1():\n    name = request.args.get('name')\n    app.logger.info('User name: ' + name) # Bad\n    return 'bad1'\n\n@app.route('/bad2')\ndef bad2():\n    name = request.args.get('name')\n    logging.info('User name: ' + name) # Bad\n    return 'bad2'\n\n@app.route('/bad3')\ndef bad3():\n    name = request.args.get('name')\n    request_logger.warn('User name: ' + name) # Bad\n    return 'bad3'\n\n@app.route('/bad4')\ndef bad4():\n    name = request.args.get('name')\n    logtest = logging.getLogger('test')\n    logtest.debug('User name: ' + name) # Bad\n    return 'bad4'\n\nif __name__ == '__main__':\n    app.debug = True\n    handler = logging.FileHandler('log')\n    app.logger.addHandler(handler)\n    app.run()\n\n```\nIn a good example, the program uses the `replace` function to provide parameter processing to the user, and replace `\\r\\n` and `\\n` with empty characters. To a certain extent, the occurrence of log injection vulnerabilities is reduced.\n\n\n```python\n#!/usr/bin/env python\n# -*- coding: UTF-8 -*-\n\"\"\"\n@Desc   ：Log Injection\n\"\"\"\nfrom flask import Flask\nfrom flask import request\nimport logging\n\nlogging.basicConfig(level=logging.DEBUG)\n\napp = Flask(__name__)\n\n@app.route('/good1')\ndef good1():\n    name = request.args.get('name')\n    name = name.replace('\\r\\n','').replace('\\n','')\n    logging.info('User name: ' + name) # Good\n    return 'good1'\n\nif __name__ == '__main__':\n    app.debug = True\n    handler = logging.FileHandler('log')\n    app.logger.addHandler(handler)\n    app.run()\n\n```\n\n## References\n* OWASP: [Log Injection](https://owasp.org/www-community/attacks/Log_Injection).\n* Common Weakness Enumeration: [CWE-117](https://cwe.mitre.org/data/definitions/117.html).\n","markdown":"# Log Injection\nIf unsanitized user input is written to a log entry, a malicious user may be able to forge new log entries.\n\nForgery can occur if a user provides some input with characters that are interpreted when the log output is displayed. If the log is displayed as a plain text file, then new line characters can be used by a malicious user to create the appearance of multiple log entries. If the log is displayed as HTML, then arbitrary HTML may be included to spoof log entries.\n\n\n## Recommendation\nUser input should be suitably sanitized before it is logged.\n\nIf the log entries are plain text then line breaks should be removed from user input, using for example `replace(old, new)` or similar. Care should also be taken that user input is clearly marked in log entries, and that a malicious user cannot cause confusion in other ways.\n\nFor log entries that will be displayed in HTML, user input should be HTML encoded before being logged, to prevent forgery and other forms of HTML injection.\n\n\n## Example\nIn the example, the name provided by the user is recorded using the log output function (`logging.info` or `app.logger.info`, etc.). In these four cases, the name provided by the user is not provided The processing is recorded. If a malicious user provides `Guest%0D%0AUser name: Admin` as a parameter, the log entry will be divided into two lines, the first line is `User name: Guest` code&gt;, the second line is `User name: Admin`.\n\n\n```python\n#!/usr/bin/env python\n# -*- coding: UTF-8 -*-\n\"\"\"\n@Desc   ：Log Injection\n\"\"\"\nfrom flask import Flask\nfrom flask import request\nfrom django.utils.log import request_logger\nimport logging\n\nlogging.basicConfig(level=logging.DEBUG)\n\napp = Flask(__name__)\n\n@app.route('/bad1')\ndef bad1():\n    name = request.args.get('name')\n    app.logger.info('User name: ' + name) # Bad\n    return 'bad1'\n\n@app.route('/bad2')\ndef bad2():\n    name = request.args.get('name')\n    logging.info('User name: ' + name) # Bad\n    return 'bad2'\n\n@app.route('/bad3')\ndef bad3():\n    name = request.args.get('name')\n    request_logger.warn('User name: ' + name) # Bad\n    return 'bad3'\n\n@app.route('/bad4')\ndef bad4():\n    name = request.args.get('name')\n    logtest = logging.getLogger('test')\n    logtest.debug('User name: ' + name) # Bad\n    return 'bad4'\n\nif __name__ == '__main__':\n    app.debug = True\n    handler = logging.FileHandler('log')\n    app.logger.addHandler(handler)\n    app.run()\n\n```\nIn a good example, the program uses the `replace` function to provide parameter processing to the user, and replace `\\r\\n` and `\\n` with empty characters. To a certain extent, the occurrence of log injection vulnerabilities is reduced.\n\n\n```python\n#!/usr/bin/env python\n# -*- coding: UTF-8 -*-\n\"\"\"\n@Desc   ：Log Injection\n\"\"\"\nfrom flask import Flask\nfrom flask import request\nimport logging\n\nlogging.basicConfig(level=logging.DEBUG)\n\napp = Flask(__name__)\n\n@app.route('/good1')\ndef good1():\n    name = request.args.get('name')\n    name = name.replace('\\r\\n','').replace('\\n','')\n    logging.info('User name: ' + name) # Good\n    return 'good1'\n\nif __name__ == '__main__':\n    app.debug = True\n    handler = logging.FileHandler('log')\n    app.logger.addHandler(handler)\n    app.run()\n\n```\n\n## References\n* OWASP: [Log Injection](https://owasp.org/www-community/attacks/Log_Injection).\n* Common Weakness Enumeration: [CWE-117](https://cwe.mitre.org/data/definitions/117.html).\n"},"properties":{"tags":["security","external/cwe/cwe-117"],"description":"Building log entries from user-controlled data is vulnerable to\n              insertion of forged log entries by a malicious user.","id":"py/log-injection","kind":"path-problem","name":"Log Injection","precision":"medium","problem.severity":"error","security-severity":"7.8"}},{"id":"py/shell-command-constructed-from-input","name":"py/shell-command-constructed-from-input","shortDescription":{"text":"Unsafe shell command constructed from library input"},"fullDescription":{"text":"Using externally controlled strings in a command line may allow a malicious user to change the meaning of the command."},"defaultConfiguration":{"enabled":true,"level":"error"},"help":{"text":"# Unsafe shell command constructed from library input\nDynamically constructing a shell command with inputs from library functions may inadvertently change the meaning of the shell command. Clients using the exported function may use inputs containing characters that the shell interprets in a special way, for instance quotes and spaces. This can result in the shell command misbehaving, or even allowing a malicious user to execute arbitrary commands on the system.\n\n\n## Recommendation\nIf possible, provide the dynamic arguments to the shell as an array to APIs such as `subprocess.run` to avoid interpretation by the shell.\n\nAlternatively, if the shell command must be constructed dynamically, then add code to ensure that special characters do not alter the shell command unexpectedly.\n\n\n## Example\nThe following example shows a dynamically constructed shell command that downloads a file from a remote URL.\n\n\n```python\nimport os\n\ndef download(path): \n    os.system(\"wget \" + path) # NOT OK\n\n```\nThe shell command will, however, fail to work as intended if the input contains spaces or other special characters interpreted in a special way by the shell.\n\nEven worse, a client might pass in user-controlled data, not knowing that the input is interpreted as a shell command. This could allow a malicious user to provide the input `http://example.org; cat /etc/passwd` in order to execute the command `cat /etc/passwd`.\n\nTo avoid such potentially catastrophic behaviors, provide the input from library functions as an argument that does not get interpreted by a shell:\n\n\n```python\nimport subprocess\n\ndef download(path): \n    subprocess.run([\"wget\", path]) # OK\n\n```\n\n## References\n* OWASP: [Command Injection](https://www.owasp.org/index.php/Command_Injection).\n* Common Weakness Enumeration: [CWE-78](https://cwe.mitre.org/data/definitions/78.html).\n* Common Weakness Enumeration: [CWE-88](https://cwe.mitre.org/data/definitions/88.html).\n* Common Weakness Enumeration: [CWE-73](https://cwe.mitre.org/data/definitions/73.html).\n","markdown":"# Unsafe shell command constructed from library input\nDynamically constructing a shell command with inputs from library functions may inadvertently change the meaning of the shell command. Clients using the exported function may use inputs containing characters that the shell interprets in a special way, for instance quotes and spaces. This can result in the shell command misbehaving, or even allowing a malicious user to execute arbitrary commands on the system.\n\n\n## Recommendation\nIf possible, provide the dynamic arguments to the shell as an array to APIs such as `subprocess.run` to avoid interpretation by the shell.\n\nAlternatively, if the shell command must be constructed dynamically, then add code to ensure that special characters do not alter the shell command unexpectedly.\n\n\n## Example\nThe following example shows a dynamically constructed shell command that downloads a file from a remote URL.\n\n\n```python\nimport os\n\ndef download(path): \n    os.system(\"wget \" + path) # NOT OK\n\n```\nThe shell command will, however, fail to work as intended if the input contains spaces or other special characters interpreted in a special way by the shell.\n\nEven worse, a client might pass in user-controlled data, not knowing that the input is interpreted as a shell command. This could allow a malicious user to provide the input `http://example.org; cat /etc/passwd` in order to execute the command `cat /etc/passwd`.\n\nTo avoid such potentially catastrophic behaviors, provide the input from library functions as an argument that does not get interpreted by a shell:\n\n\n```python\nimport subprocess\n\ndef download(path): \n    subprocess.run([\"wget\", path]) # OK\n\n```\n\n## References\n* OWASP: [Command Injection](https://www.owasp.org/index.php/Command_Injection).\n* Common Weakness Enumeration: [CWE-78](https://cwe.mitre.org/data/definitions/78.html).\n* Common Weakness Enumeration: [CWE-88](https://cwe.mitre.org/data/definitions/88.html).\n* Common Weakness Enumeration: [CWE-73](https://cwe.mitre.org/data/definitions/73.html).\n"},"properties":{"tags":["correctness","security","external/cwe/cwe-078","external/cwe/cwe-088","external/cwe/cwe-073"],"description":"Using externally controlled strings in a command line may allow a malicious\n              user to change the meaning of the command.","id":"py/shell-command-constructed-from-input","kind":"path-problem","name":"Unsafe shell command constructed from library input","precision":"medium","problem.severity":"error","security-severity":"6.3"}},{"id":"py/jinja2/autoescape-false","name":"py/jinja2/autoescape-false","shortDescription":{"text":"Jinja2 templating with autoescape=False"},"fullDescription":{"text":"Using jinja2 templates with 'autoescape=False' can cause a cross-site scripting vulnerability."},"defaultConfiguration":{"enabled":true,"level":"error"},"help":{"text":"# Jinja2 templating with autoescape=False\nCross-site scripting (XSS) attacks can occur if untrusted input is not escaped. This applies to templates as well as code. The `jinja2` templates may be vulnerable to XSS if the environment has `autoescape` set to `False`. Unfortunately, `jinja2` sets `autoescape` to `False` by default. Explicitly setting `autoescape` to `True` when creating an `Environment` object will prevent this.\n\n\n## Recommendation\nAvoid setting jinja2 autoescape to False. Jinja2 provides the function `select_autoescape` to make sure that the correct auto-escaping is chosen. For example, it can be used when creating an environment `Environment(autoescape=select_autoescape(['html', 'xml'])`\n\n\n## Example\nThe following example is a minimal Flask app which shows a safe and an unsafe way to render the given name back to the page. The first view is unsafe as `first_name` is not escaped, leaving the page vulnerable to cross-site scripting attacks. The second view is safe as `first_name` is escaped, so it is not vulnerable to cross-site scripting attacks.\n\n\n```python\nfrom flask import Flask, request, make_response, escape\nfrom jinja2 import Environment, select_autoescape, FileSystemLoader\n\napp = Flask(__name__)\nloader = FileSystemLoader( searchpath=\"templates/\" )\n\nunsafe_env = Environment(loader=loader)\nsafe1_env = Environment(loader=loader, autoescape=True)\nsafe2_env = Environment(loader=loader, autoescape=select_autoescape())\n\ndef render_response_from_env(env):\n    name = request.args.get('name', '')\n    template = env.get_template('template.html')\n    return make_response(template.render(name=name))\n\n@app.route('/unsafe')\ndef unsafe():\n    return render_response_from_env(unsafe_env)\n\n@app.route('/safe1')\ndef safe1():\n    return render_response_from_env(safe1_env)\n\n@app.route('/safe2')\ndef safe2():\n    return render_response_from_env(safe2_env)\n\n\n```\n\n## References\n* Jinja2: [API](http://jinja.pocoo.org/docs/2.10/api/).\n* Wikipedia: [Cross-site scripting](http://en.wikipedia.org/wiki/Cross-site_scripting).\n* OWASP: [XSS (Cross Site Scripting) Prevention Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/Cross_Site_Scripting_Prevention_Cheat_Sheet.html).\n* Common Weakness Enumeration: [CWE-79](https://cwe.mitre.org/data/definitions/79.html).\n","markdown":"# Jinja2 templating with autoescape=False\nCross-site scripting (XSS) attacks can occur if untrusted input is not escaped. This applies to templates as well as code. The `jinja2` templates may be vulnerable to XSS if the environment has `autoescape` set to `False`. Unfortunately, `jinja2` sets `autoescape` to `False` by default. Explicitly setting `autoescape` to `True` when creating an `Environment` object will prevent this.\n\n\n## Recommendation\nAvoid setting jinja2 autoescape to False. Jinja2 provides the function `select_autoescape` to make sure that the correct auto-escaping is chosen. For example, it can be used when creating an environment `Environment(autoescape=select_autoescape(['html', 'xml'])`\n\n\n## Example\nThe following example is a minimal Flask app which shows a safe and an unsafe way to render the given name back to the page. The first view is unsafe as `first_name` is not escaped, leaving the page vulnerable to cross-site scripting attacks. The second view is safe as `first_name` is escaped, so it is not vulnerable to cross-site scripting attacks.\n\n\n```python\nfrom flask import Flask, request, make_response, escape\nfrom jinja2 import Environment, select_autoescape, FileSystemLoader\n\napp = Flask(__name__)\nloader = FileSystemLoader( searchpath=\"templates/\" )\n\nunsafe_env = Environment(loader=loader)\nsafe1_env = Environment(loader=loader, autoescape=True)\nsafe2_env = Environment(loader=loader, autoescape=select_autoescape())\n\ndef render_response_from_env(env):\n    name = request.args.get('name', '')\n    template = env.get_template('template.html')\n    return make_response(template.render(name=name))\n\n@app.route('/unsafe')\ndef unsafe():\n    return render_response_from_env(unsafe_env)\n\n@app.route('/safe1')\ndef safe1():\n    return render_response_from_env(safe1_env)\n\n@app.route('/safe2')\ndef safe2():\n    return render_response_from_env(safe2_env)\n\n\n```\n\n## References\n* Jinja2: [API](http://jinja.pocoo.org/docs/2.10/api/).\n* Wikipedia: [Cross-site scripting](http://en.wikipedia.org/wiki/Cross-site_scripting).\n* OWASP: [XSS (Cross Site Scripting) Prevention Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/Cross_Site_Scripting_Prevention_Cheat_Sheet.html).\n* Common Weakness Enumeration: [CWE-79](https://cwe.mitre.org/data/definitions/79.html).\n"},"properties":{"tags":["security","external/cwe/cwe-079"],"description":"Using jinja2 templates with 'autoescape=False' can\n              cause a cross-site scripting vulnerability.","id":"py/jinja2/autoescape-false","kind":"problem","name":"Jinja2 templating with autoescape=False","precision":"medium","problem.severity":"error","security-severity":"6.1"}},{"id":"py/tarslip","name":"py/tarslip","shortDescription":{"text":"Arbitrary file write during tarfile extraction"},"fullDescription":{"text":"Extracting files from a malicious tar archive without validating that the destination file path is within the destination directory can cause files outside the destination directory to be overwritten."},"defaultConfiguration":{"enabled":true,"level":"error"},"help":{"text":"# Arbitrary file write during tarfile extraction\nExtracting files from a malicious tar archive without validating that the destination file path is within the destination directory can cause files outside the destination directory to be overwritten, due to the possible presence of directory traversal elements (`..`) in archive paths.\n\nTar archives contain archive entries representing each file in the archive. These entries include a file path for the entry, but these file paths are not restricted and may contain unexpected special elements such as the directory traversal element (`..`). If these file paths are used to determine an output file to write the contents of the archive item to, then the file may be written to an unexpected location. This can result in sensitive information being revealed or deleted, or an attacker being able to influence behavior by modifying unexpected files.\n\nFor example, if a tar archive contains a file entry `..\\sneaky-file`, and the tar archive is extracted to the directory `c:\\output`, then naively combining the paths would result in an output file path of `c:\\output\\..\\sneaky-file`, which would cause the file to be written to `c:\\sneaky-file`.\n\n\n## Recommendation\nEnsure that output paths constructed from tar archive entries are validated to prevent writing files to unexpected locations.\n\nThe recommended way of writing an output file from a tar archive entry is to check that `\"..\"` does not occur in the path.\n\n\n## Example\nIn this example an archive is extracted without validating file paths. If `archive.tar` contained relative paths (for instance, if it were created by something like `tar -cf archive.tar ../file.txt`) then executing this code could write to locations outside the destination directory.\n\n\n```python\nimport sys\nimport tarfile\n\nwith tarfile.open(sys.argv[1]) as tar:\n    #BAD : This could write any file on the filesystem.\n    for entry in tar:\n        tar.extract(entry, \"/tmp/unpack/\")\n\n```\nTo fix this vulnerability, we need to check that the path does not contain any `\"..\"` elements in it.\n\n\n```python\nimport sys\nimport tarfile\nimport os.path\n\nwith tarfile.open(sys.argv[1]) as tar:\n    for entry in tar:\n        #GOOD: Check that entry is safe\n        if os.path.isabs(entry.name) or \"..\" in entry.name:\n            raise ValueError(\"Illegal tar archive entry\")\n        tar.extract(entry, \"/tmp/unpack/\")\n\n```\n\n## References\n* Snyk: [Zip Slip Vulnerability](https://snyk.io/research/zip-slip-vulnerability).\n* OWASP: [Path Traversal](https://owasp.org/www-community/attacks/Path_Traversal).\n* Python Library Reference: [TarFile.extract](https://docs.python.org/3/library/tarfile.html#tarfile.TarFile.extract).\n* Python Library Reference: [TarFile.extractall](https://docs.python.org/3/library/tarfile.html#tarfile.TarFile.extractall).\n* Common Weakness Enumeration: [CWE-22](https://cwe.mitre.org/data/definitions/22.html).\n","markdown":"# Arbitrary file write during tarfile extraction\nExtracting files from a malicious tar archive without validating that the destination file path is within the destination directory can cause files outside the destination directory to be overwritten, due to the possible presence of directory traversal elements (`..`) in archive paths.\n\nTar archives contain archive entries representing each file in the archive. These entries include a file path for the entry, but these file paths are not restricted and may contain unexpected special elements such as the directory traversal element (`..`). If these file paths are used to determine an output file to write the contents of the archive item to, then the file may be written to an unexpected location. This can result in sensitive information being revealed or deleted, or an attacker being able to influence behavior by modifying unexpected files.\n\nFor example, if a tar archive contains a file entry `..\\sneaky-file`, and the tar archive is extracted to the directory `c:\\output`, then naively combining the paths would result in an output file path of `c:\\output\\..\\sneaky-file`, which would cause the file to be written to `c:\\sneaky-file`.\n\n\n## Recommendation\nEnsure that output paths constructed from tar archive entries are validated to prevent writing files to unexpected locations.\n\nThe recommended way of writing an output file from a tar archive entry is to check that `\"..\"` does not occur in the path.\n\n\n## Example\nIn this example an archive is extracted without validating file paths. If `archive.tar` contained relative paths (for instance, if it were created by something like `tar -cf archive.tar ../file.txt`) then executing this code could write to locations outside the destination directory.\n\n\n```python\nimport sys\nimport tarfile\n\nwith tarfile.open(sys.argv[1]) as tar:\n    #BAD : This could write any file on the filesystem.\n    for entry in tar:\n        tar.extract(entry, \"/tmp/unpack/\")\n\n```\nTo fix this vulnerability, we need to check that the path does not contain any `\"..\"` elements in it.\n\n\n```python\nimport sys\nimport tarfile\nimport os.path\n\nwith tarfile.open(sys.argv[1]) as tar:\n    for entry in tar:\n        #GOOD: Check that entry is safe\n        if os.path.isabs(entry.name) or \"..\" in entry.name:\n            raise ValueError(\"Illegal tar archive entry\")\n        tar.extract(entry, \"/tmp/unpack/\")\n\n```\n\n## References\n* Snyk: [Zip Slip Vulnerability](https://snyk.io/research/zip-slip-vulnerability).\n* OWASP: [Path Traversal](https://owasp.org/www-community/attacks/Path_Traversal).\n* Python Library Reference: [TarFile.extract](https://docs.python.org/3/library/tarfile.html#tarfile.TarFile.extract).\n* Python Library Reference: [TarFile.extractall](https://docs.python.org/3/library/tarfile.html#tarfile.TarFile.extractall).\n* Common Weakness Enumeration: [CWE-22](https://cwe.mitre.org/data/definitions/22.html).\n"},"properties":{"tags":["security","external/cwe/cwe-022"],"description":"Extracting files from a malicious tar archive without validating that the\n              destination file path is within the destination directory can cause files outside\n              the destination directory to be overwritten.","id":"py/tarslip","kind":"path-problem","name":"Arbitrary file write during tarfile extraction","precision":"medium","problem.severity":"error","security-severity":"7.5"}},{"id":"py/overly-permissive-file","name":"py/overly-permissive-file","shortDescription":{"text":"Overly permissive file permissions"},"fullDescription":{"text":"Allowing files to be readable or writable by users other than the owner may allow sensitive information to be accessed."},"defaultConfiguration":{"enabled":true,"level":"warning"},"help":{"text":"# Overly permissive file permissions\nWhen creating a file, POSIX systems allow permissions to be specified for owner, group and others separately. Permissions should be kept as strict as possible, preventing access to the files contents by other users.\n\n\n## Recommendation\nRestrict the file permissions of files to prevent any but the owner being able to read or write to that file\n\n\n## References\n* Wikipedia: [File system permissions](https://en.wikipedia.org/wiki/File_system_permissions).\n* Common Weakness Enumeration: [CWE-732](https://cwe.mitre.org/data/definitions/732.html).\n","markdown":"# Overly permissive file permissions\nWhen creating a file, POSIX systems allow permissions to be specified for owner, group and others separately. Permissions should be kept as strict as possible, preventing access to the files contents by other users.\n\n\n## Recommendation\nRestrict the file permissions of files to prevent any but the owner being able to read or write to that file\n\n\n## References\n* Wikipedia: [File system permissions](https://en.wikipedia.org/wiki/File_system_permissions).\n* Common Weakness Enumeration: [CWE-732](https://cwe.mitre.org/data/definitions/732.html).\n"},"properties":{"tags":["external/cwe/cwe-732","security"],"description":"Allowing files to be readable or writable by users other than the owner may allow sensitive information to be accessed.","id":"py/overly-permissive-file","kind":"problem","name":"Overly permissive file permissions","precision":"medium","problem.severity":"warning","security-severity":"7.8","sub-severity":"high"}},{"id":"py/summary/lines-of-code","name":"py/summary/lines-of-code","shortDescription":{"text":"Total lines of Python code in the database"},"fullDescription":{"text":"The total number of lines of Python code across all files, including external libraries and auto-generated files. This is a useful metric of the size of a database. This query counts the lines of code, excluding whitespace or comments."},"defaultConfiguration":{"enabled":true},"properties":{"tags":["summary","telemetry"],"description":"The total number of lines of Python code across all files, including\n   external libraries and auto-generated files. This is a useful metric of the size of a\n   database. This query counts the lines of code, excluding whitespace or comments.","id":"py/summary/lines-of-code","kind":"metric","name":"Total lines of Python code in the database"}},{"id":"py/summary/lines-of-user-code","name":"py/summary/lines-of-user-code","shortDescription":{"text":"Total lines of user written Python code in the database"},"fullDescription":{"text":"The total number of lines of Python code from the source code directory, excluding auto-generated files. This query counts the lines of code, excluding whitespace or comments. Note: If external libraries are included in the codebase either in a checked-in virtual environment or as vendored code, that will currently be counted as user written code."},"defaultConfiguration":{"enabled":true},"properties":{"tags":["summary","lines-of-code","debug"],"description":"The total number of lines of Python code from the source code directory,\n   excluding auto-generated files. This query counts the lines of code, excluding\n   whitespace or comments. Note: If external libraries are included in the codebase\n   either in a checked-in virtual environment or as vendored code, that will currently\n   be counted as user written code.","id":"py/summary/lines-of-user-code","kind":"metric","name":"Total lines of user written Python code in the database"}},{"id":"py/call/wrong-named-class-argument","name":"py/call/wrong-named-class-argument","shortDescription":{"text":"Wrong name for an argument in a class instantiation"},"fullDescription":{"text":"Using a named argument whose name does not correspond to a parameter of the __init__ method of the class being instantiated, will result in a TypeError at runtime."},"defaultConfiguration":{"enabled":true,"level":"error"},"help":{"text":"# Wrong name for an argument in a class instantiation\nUsing a named argument whose name does not correspond to a parameter of the `__init__` method of the class being instantiated, will result in a `TypeError` at runtime.\n\n\n## Recommendation\nCheck for typos in the name of the arguments and fix those. If the name is clearly different, then this suggests a logical error. The change required to correct the error will depend on whether the wrong argument has been specified or whether the wrong class has been specified.\n\n\n## Example\n\n```python\nclass Point(object):\n    def __init__(self, x, y):\n        self.x = x\n        self.y = y\n\np = Point(x=1, yy=2) # TypeError: 'yy' is not a valid keyword argument\n\n```\n\n## References\n* Python Glossary: [Arguments](https://docs.python.org/2/glossary.html#term-argument).\n* Python Glossary: [Parameters](https://docs.python.org/glossary.html#term-parameter).\n* Python Programming FAQ: [ What is the difference between arguments and parameters?](https://docs.python.org/2/faq/programming.html#faq-argument-vs-parameter).\n* The Python Language Reference: [Data model: object.__init__](https://docs.python.org/3/reference/datamodel.html#object.__init__)\n* The Python Tutorial: [Classes](https://docs.python.org/3/tutorial/classes.html)\n* Common Weakness Enumeration: [CWE-628](https://cwe.mitre.org/data/definitions/628.html).\n","markdown":"# Wrong name for an argument in a class instantiation\nUsing a named argument whose name does not correspond to a parameter of the `__init__` method of the class being instantiated, will result in a `TypeError` at runtime.\n\n\n## Recommendation\nCheck for typos in the name of the arguments and fix those. If the name is clearly different, then this suggests a logical error. The change required to correct the error will depend on whether the wrong argument has been specified or whether the wrong class has been specified.\n\n\n## Example\n\n```python\nclass Point(object):\n    def __init__(self, x, y):\n        self.x = x\n        self.y = y\n\np = Point(x=1, yy=2) # TypeError: 'yy' is not a valid keyword argument\n\n```\n\n## References\n* Python Glossary: [Arguments](https://docs.python.org/2/glossary.html#term-argument).\n* Python Glossary: [Parameters](https://docs.python.org/glossary.html#term-parameter).\n* Python Programming FAQ: [ What is the difference between arguments and parameters?](https://docs.python.org/2/faq/programming.html#faq-argument-vs-parameter).\n* The Python Language Reference: [Data model: object.__init__](https://docs.python.org/3/reference/datamodel.html#object.__init__)\n* The Python Tutorial: [Classes](https://docs.python.org/3/tutorial/classes.html)\n* Common Weakness Enumeration: [CWE-628](https://cwe.mitre.org/data/definitions/628.html).\n"},"properties":{"tags":["quality","reliability","correctness","external/cwe/cwe-628"],"description":"Using a named argument whose name does not correspond to a\n              parameter of the __init__ method of the class being\n              instantiated, will result in a TypeError at runtime.","id":"py/call/wrong-named-class-argument","kind":"problem","name":"Wrong name for an argument in a class instantiation","precision":"very-high","problem.severity":"error","sub-severity":"low"}},{"id":"py/missing-equals","name":"py/missing-equals","shortDescription":{"text":"`__eq__` not overridden when adding attributes"},"fullDescription":{"text":"When adding new attributes to instances of a class, equality for that class needs to be defined."},"defaultConfiguration":{"enabled":true,"level":"warning"},"help":{"text":"# `__eq__` not overridden when adding attributes\nA class that defines attributes that are not present in its superclasses may need to override the `__eq__()` method (`__ne__()` should also be defined).\n\nAdding additional attributes without overriding `__eq__()` means that the additional attributes will not be accounted for in equality tests.\n\n\n## Recommendation\nOverride the `__eq__` method.\n\n\n## Example\nIn the following example the `ColorPoint` class subclasses the `Point` class and adds a new attribute, but does not override the `__eq__` method.\n\n\n```python\nclass Point(object):\n\n    def __init__(self, x, y):\n        self._x = x\n        self._y = y\n\n    def __repr__(self):\n        return 'Point(%r, %r)' % (self._x, self._y)\n\n    def __eq__(self, other):\n        if not isinstance(other, Point):\n            return False\n        return self._x == other._x and self._y == other._y\n\nclass ColorPoint(Point):\n\n    def __init__(self, x, y, color):\n        Point.__init__(self, x, y)\n        self._color = color\n\n    def __repr__(self):\n        return 'ColorPoint(%r, %r)' % (self._x, self._y, self._color)\n\n#ColorPoint(0, 0, Red) == ColorPoint(0, 0, Green) should be False, but is True.\n\n#Fixed version\nclass ColorPoint(Point):\n\n    def __init__(self, x, y, color):\n        Point.__init__(self, x, y)\n        self._color = color\n\n    def __repr__(self):\n        return 'ColorPoint(%r, %r)' % (self._x, self._y, self._color)\n\n    def __eq__(self, other):\n        if not isinstance(other, ColorPoint):\n            return False\n        return Point.__eq__(self, other) and self._color = other._color\n\n\n```\n\n## References\n* Peter Grogono, Philip Santas: [Equality in Object Oriented Languages](http://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.48.5109&rep=rep1&type=pdf)\n","markdown":"# `__eq__` not overridden when adding attributes\nA class that defines attributes that are not present in its superclasses may need to override the `__eq__()` method (`__ne__()` should also be defined).\n\nAdding additional attributes without overriding `__eq__()` means that the additional attributes will not be accounted for in equality tests.\n\n\n## Recommendation\nOverride the `__eq__` method.\n\n\n## Example\nIn the following example the `ColorPoint` class subclasses the `Point` class and adds a new attribute, but does not override the `__eq__` method.\n\n\n```python\nclass Point(object):\n\n    def __init__(self, x, y):\n        self._x = x\n        self._y = y\n\n    def __repr__(self):\n        return 'Point(%r, %r)' % (self._x, self._y)\n\n    def __eq__(self, other):\n        if not isinstance(other, Point):\n            return False\n        return self._x == other._x and self._y == other._y\n\nclass ColorPoint(Point):\n\n    def __init__(self, x, y, color):\n        Point.__init__(self, x, y)\n        self._color = color\n\n    def __repr__(self):\n        return 'ColorPoint(%r, %r)' % (self._x, self._y, self._color)\n\n#ColorPoint(0, 0, Red) == ColorPoint(0, 0, Green) should be False, but is True.\n\n#Fixed version\nclass ColorPoint(Point):\n\n    def __init__(self, x, y, color):\n        Point.__init__(self, x, y)\n        self._color = color\n\n    def __repr__(self):\n        return 'ColorPoint(%r, %r)' % (self._x, self._y, self._color)\n\n    def __eq__(self, other):\n        if not isinstance(other, ColorPoint):\n            return False\n        return Point.__eq__(self, other) and self._color = other._color\n\n\n```\n\n## References\n* Peter Grogono, Philip Santas: [Equality in Object Oriented Languages](http://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.48.5109&rep=rep1&type=pdf)\n"},"properties":{"tags":["quality","reliability","correctness"],"description":"When adding new attributes to instances of a class, equality for that class needs to be defined.","id":"py/missing-equals","kind":"problem","name":"`__eq__` not overridden when adding attributes","precision":"high","problem.severity":"warning","sub-severity":"high"}},{"id":"py/conflicting-attributes","name":"py/conflicting-attributes","shortDescription":{"text":"Conflicting attributes in base classes"},"fullDescription":{"text":"When a class subclasses multiple base classes and more than one base class defines the same attribute, attribute overriding may result in unexpected behavior by instances of this class."},"defaultConfiguration":{"enabled":true,"level":"warning"},"help":{"text":"# Conflicting attributes in base classes\nWhen a class subclasses multiple base classes, attribute lookup is performed from left to right amongst the base classes. This form of attribute lookup is called \"method resolution order\" and is a solution to the [diamond inheritance problem](http://en.wikipedia.org/wiki/Multiple_inheritance#The_diamond_problem) where several base classes override a method in a shared superclass.\n\nUnfortunately, this means that if more than one base class defines the same attribute, the leftmost base class will effectively override the attribute of the rightmost base class, even though the leftmost base class is not a subclass of the rightmost base class. Unless the methods in question are designed for inheritance, using `super`, then this implicit overriding may not be the desired behavior. Even if it is the desired behavior it makes the code hard to understand and maintain.\n\n\n## Recommendation\nThere are a number of ways that might be used to address this issue:\n\n* Override the attribute in the subclass to implement the correct behavior.\n* Modify the class hierarchy and move equivalent or redundant methods to a common super class.\n* Modify the method hierarchy, breaking up complex methods into constituent parts.\n* Use delegation rather than inheritance.\n\n## Example\nIn this example the class `ThreadingTCPServer` inherits from `ThreadingMixIn` and from `TCPServer`. However, both these classes implement `process_request` which means that `ThreadingTCPServer` will inherit `process_request` from `ThreadingMixIn`. Consequently, the implementation of `process_request` in `TCPServer` will be ignored, which may not be the correct behavior.\n\n\n```python\n\nclass TCPServer(object):\n    \n    def process_request(self, request, client_address):\n        self.do_work(request, client_address)\n        self.shutdown_request(request)\n\n    \nclass ThreadingMixIn:\n    \"\"\"Mix-in class to handle each request in a new thread.\"\"\"\n\n    def process_request(self, request, client_address):\n        \"\"\"Start a new thread to process the request.\"\"\"\n        t = threading.Thread(target = self.do_work, args = (request, client_address))\n        t.daemon = self.daemon_threads\n        t.start()\n\nclass ThreadingTCPServer(ThreadingMixIn, TCPServer): pass\n\n```\nThis can be fixed either by overriding the method, as shown in class `ThreadingTCPServerOverriding` or by ensuring that the functionality provided by the two base classes does not overlap, as shown in class `ThreadingTCPServerChangedHierarchy`.\n\n\n```python\n   \n#Fixed by overriding. This does not change behavior, but makes it explicit and comprehensible.\nclass ThreadingTCPServerOverriding(ThreadingMixIn, TCPServer):\n    \n    def process_request(self, request, client_address):\n        #process_request forwards to do_work, so it is OK to call ThreadingMixIn.process_request directly\n        ThreadingMixIn.process_request(self, request, client_address)\n        \n\n#Fixed by separating threading functionality from request handling.\nclass ThreadingMixIn:\n    \"\"\"Mix-in class to help with threads.\"\"\"\n\n    def do_job_in_thread(self, job, args):\n        \"\"\"Start a new thread to do the job\"\"\"\n        t = threading.Thread(target = job, args = args)\n        t.start()\n\nclass ThreadingTCPServerChangedHierarchy(ThreadingMixIn, TCPServer):\n    \n    def process_request(self, request, client_address):\n        \"\"\"Start a new thread to process the request.\"\"\"\n        self.do_job_in_thread(self.do_work,  (request, client_address))\n    \n\n```\n\n## References\n* Python Language Reference: [Data model](https://docs.python.org/2/reference/datamodel.html).\n* Python releases: [The Python 2.3 Method Resolution Order](https://www.python.org/download/releases/2.3/mro/).\n* Wikipedia: [C3 linearization](https://en.wikipedia.org/wiki/C3_linearization).\n* Wikipedia: [Composition over inheritance](http://en.wikipedia.org/wiki/Composition_over_inheritance).\n","markdown":"# Conflicting attributes in base classes\nWhen a class subclasses multiple base classes, attribute lookup is performed from left to right amongst the base classes. This form of attribute lookup is called \"method resolution order\" and is a solution to the [diamond inheritance problem](http://en.wikipedia.org/wiki/Multiple_inheritance#The_diamond_problem) where several base classes override a method in a shared superclass.\n\nUnfortunately, this means that if more than one base class defines the same attribute, the leftmost base class will effectively override the attribute of the rightmost base class, even though the leftmost base class is not a subclass of the rightmost base class. Unless the methods in question are designed for inheritance, using `super`, then this implicit overriding may not be the desired behavior. Even if it is the desired behavior it makes the code hard to understand and maintain.\n\n\n## Recommendation\nThere are a number of ways that might be used to address this issue:\n\n* Override the attribute in the subclass to implement the correct behavior.\n* Modify the class hierarchy and move equivalent or redundant methods to a common super class.\n* Modify the method hierarchy, breaking up complex methods into constituent parts.\n* Use delegation rather than inheritance.\n\n## Example\nIn this example the class `ThreadingTCPServer` inherits from `ThreadingMixIn` and from `TCPServer`. However, both these classes implement `process_request` which means that `ThreadingTCPServer` will inherit `process_request` from `ThreadingMixIn`. Consequently, the implementation of `process_request` in `TCPServer` will be ignored, which may not be the correct behavior.\n\n\n```python\n\nclass TCPServer(object):\n    \n    def process_request(self, request, client_address):\n        self.do_work(request, client_address)\n        self.shutdown_request(request)\n\n    \nclass ThreadingMixIn:\n    \"\"\"Mix-in class to handle each request in a new thread.\"\"\"\n\n    def process_request(self, request, client_address):\n        \"\"\"Start a new thread to process the request.\"\"\"\n        t = threading.Thread(target = self.do_work, args = (request, client_address))\n        t.daemon = self.daemon_threads\n        t.start()\n\nclass ThreadingTCPServer(ThreadingMixIn, TCPServer): pass\n\n```\nThis can be fixed either by overriding the method, as shown in class `ThreadingTCPServerOverriding` or by ensuring that the functionality provided by the two base classes does not overlap, as shown in class `ThreadingTCPServerChangedHierarchy`.\n\n\n```python\n   \n#Fixed by overriding. This does not change behavior, but makes it explicit and comprehensible.\nclass ThreadingTCPServerOverriding(ThreadingMixIn, TCPServer):\n    \n    def process_request(self, request, client_address):\n        #process_request forwards to do_work, so it is OK to call ThreadingMixIn.process_request directly\n        ThreadingMixIn.process_request(self, request, client_address)\n        \n\n#Fixed by separating threading functionality from request handling.\nclass ThreadingMixIn:\n    \"\"\"Mix-in class to help with threads.\"\"\"\n\n    def do_job_in_thread(self, job, args):\n        \"\"\"Start a new thread to do the job\"\"\"\n        t = threading.Thread(target = job, args = args)\n        t.start()\n\nclass ThreadingTCPServerChangedHierarchy(ThreadingMixIn, TCPServer):\n    \n    def process_request(self, request, client_address):\n        \"\"\"Start a new thread to process the request.\"\"\"\n        self.do_job_in_thread(self.do_work,  (request, client_address))\n    \n\n```\n\n## References\n* Python Language Reference: [Data model](https://docs.python.org/2/reference/datamodel.html).\n* Python releases: [The Python 2.3 Method Resolution Order](https://www.python.org/download/releases/2.3/mro/).\n* Wikipedia: [C3 linearization](https://en.wikipedia.org/wiki/C3_linearization).\n* Wikipedia: [Composition over inheritance](http://en.wikipedia.org/wiki/Composition_over_inheritance).\n"},"properties":{"tags":["quality","reliability","correctness"],"description":"When a class subclasses multiple base classes and more than one base class defines the same attribute, attribute overriding may result in unexpected behavior by instances of this class.","id":"py/conflicting-attributes","kind":"problem","name":"Conflicting attributes in base classes","precision":"high","problem.severity":"warning","sub-severity":"low"}},{"id":"py/attribute-shadows-method","name":"py/attribute-shadows-method","shortDescription":{"text":"Superclass attribute shadows subclass method"},"fullDescription":{"text":"Defining an attribute in a superclass method with a name that matches a subclass method, hides the method in the subclass."},"defaultConfiguration":{"enabled":true,"level":"error"},"help":{"text":"# Superclass attribute shadows subclass method\nWhen an object has an attribute that shares its name with a method on the object's class (or another class attribute), the instance attribute is prioritized during attribute lookup, shadowing the method. If a method on a subclass is shadowed by an attribute on a superclass in this way, this may lead to unexpected results or errors, as this shadowing behavior is nonlocal and may be unintended.\n\n\n## Recommendation\nEnsure method names on subclasses don't conflict with attribute names on superclasses, and rename one. If the shadowing behavior is intended, ensure this is explicit in the superclass.\n\n\n## Example\nIn the following example, the `_foo` attribute of class `A` shadows the method `_foo` of class `B`. Calls to `B()._foo()` will result in a `TypeError`, as `3` will be called instead.\n\n\n```python\nclass A:\n    def __init__(self):\n        self._foo = 3\n\nclass B(A):\n    # BAD: _foo is shadowed by attribute A._foo\n    def _foo(self):\n        return 2\n\n\n```\nIn the following example, the behavior of the `default` attribute being shadowed to allow for customization during initialization is intended in within the superclass `A`. Overriding `default` in the subclass `B` is then OK.\n\n\n```python\nclass A:\n    def __init__(self, default_func=None):\n        if default_func is not None:\n            self.default = default_func \n\n    # GOOD: The shadowing behavior is explicitly intended in the superclass.\n    def default(self):\n        return []\n    \nclass B(A):\n    \n    # Subclasses may override the method `default`, which will still be shadowed by the attribute `default` if it is set.\n    # As this is part of the expected behavior of the superclass, this is fine. \n    def default(self):\n        return {}\n```\n","markdown":"# Superclass attribute shadows subclass method\nWhen an object has an attribute that shares its name with a method on the object's class (or another class attribute), the instance attribute is prioritized during attribute lookup, shadowing the method. If a method on a subclass is shadowed by an attribute on a superclass in this way, this may lead to unexpected results or errors, as this shadowing behavior is nonlocal and may be unintended.\n\n\n## Recommendation\nEnsure method names on subclasses don't conflict with attribute names on superclasses, and rename one. If the shadowing behavior is intended, ensure this is explicit in the superclass.\n\n\n## Example\nIn the following example, the `_foo` attribute of class `A` shadows the method `_foo` of class `B`. Calls to `B()._foo()` will result in a `TypeError`, as `3` will be called instead.\n\n\n```python\nclass A:\n    def __init__(self):\n        self._foo = 3\n\nclass B(A):\n    # BAD: _foo is shadowed by attribute A._foo\n    def _foo(self):\n        return 2\n\n\n```\nIn the following example, the behavior of the `default` attribute being shadowed to allow for customization during initialization is intended in within the superclass `A`. Overriding `default` in the subclass `B` is then OK.\n\n\n```python\nclass A:\n    def __init__(self, default_func=None):\n        if default_func is not None:\n            self.default = default_func \n\n    # GOOD: The shadowing behavior is explicitly intended in the superclass.\n    def default(self):\n        return []\n    \nclass B(A):\n    \n    # Subclasses may override the method `default`, which will still be shadowed by the attribute `default` if it is set.\n    # As this is part of the expected behavior of the superclass, this is fine. \n    def default(self):\n        return {}\n```\n"},"properties":{"tags":["quality","reliability","correctness"],"description":"Defining an attribute in a superclass method with a name that matches a subclass\n              method, hides the method in the subclass.","id":"py/attribute-shadows-method","kind":"problem","name":"Superclass attribute shadows subclass method","precision":"high","problem.severity":"error","sub-severity":"low"}},{"id":"py/multiple-calls-to-delete","name":"py/multiple-calls-to-delete","shortDescription":{"text":"Multiple calls to `__del__` during object destruction"},"fullDescription":{"text":"A duplicated call to a super-class `__del__` method may lead to class instances not be cleaned up properly."},"defaultConfiguration":{"enabled":true,"level":"warning"},"help":{"text":"# Multiple calls to `__del__` during object destruction\nPython, unlike statically typed languages such as Java, allows complete freedom when calling methods during object destruction. However, standard object-oriented principles apply to Python classes using deep inheritance hierarchies. Therefore the developer has responsibility for ensuring that objects are properly cleaned up when there are multiple `__del__` methods that need to be called.\n\nCalling a `__del__` method more than once during object destruction risks resources being released multiple times. The relevant `__del__` method may not be designed to be called more than once.\n\nThere are a number of ways that a `__del__` method may be be called more than once.\n\n* There may be more than one explicit call to the method in the hierarchy of `__del__` methods.\n* A class using multiple inheritance directly calls the `__del__` methods of its base types. One or more of those base types uses `super()` to pass down the inheritance chain.\n\n## Recommendation\nEither be careful not to explicitly call a `__del__` method more than once, or use `super()` throughout the inheritance hierarchy.\n\nAlternatively refactor one or more of the classes to use composition rather than inheritance.\n\n\n## Example\nIn the first example, explicit calls to `__del__` are used, but `SportsCar` erroneously calls both `Vehicle.__del__` and `Car.__del__`. This can be fixed by removing the call to `Vehicle.__del__`, as shown in `FixedSportsCar`.\n\n\n```python\n#Calling a method multiple times by using explicit calls when a base inherits from other base\nclass Vehicle(object):\n    \n    def __del__(self):\n        recycle(self.base_parts)\n        \n        \nclass Car(Vehicle):\n    \n    def __del__(self):\n        recycle(self.car_parts)\n        Vehicle.__del__(self)\n    \n    \nclass SportsCar(Car, Vehicle):\n    \n    # Vehicle.__del__ will get called twice\n    def __del__(self):\n        recycle(self.sports_car_parts)\n        Car.__del__(self)\n        Vehicle.__del__(self)\n        \n        \n#Fix SportsCar by only calling Car.__del__\nclass FixedSportsCar(Car, Vehicle):\n    \n    def __del__(self):\n        recycle(self.sports_car_parts)\n        Car.__del__(self)\n\n```\nIn the second example, there is a mixture of explicit calls to `__del__` and calls using `super()`. To fix this example, `super()` should be used throughout.\n\n\n```python\n\n#Calling a method multiple times by using explicit calls when a base uses super()\nclass Vehicle(object):\n     \n    def __init__(self):\n        super(Vehicle, self).__init__()\n        self.mobile = True\n        \nclass Car(Vehicle):\n    \n    def __init__(self):\n        super(Car, self).__init__()\n        self.car_init()\n        \n    def car_init(self):\n        pass\n        \nclass SportsCar(Car, Vehicle):\n    \n    # Vehicle.__init__ will get called twice\n    def __init__(self):\n        Vehicle.__init__(self)\n        Car.__init__(self)\n        self.sports_car_init()\n        \n    def sports_car_init(self):\n        pass\n        \n#Fix SportsCar by using super()\nclass FixedSportsCar(Car, Vehicle):\n    \n    def __init__(self):\n        super(SportsCar, self).__init__()\n        self.sports_car_init()\n        \n    def sports_car_init(self):\n        pass\n\n\n```\n\n## References\n* Python Tutorial: [Classes](https://docs.python.org/2/tutorial/classes.html).\n* Python Standard Library: [super](https://docs.python.org/2/library/functions.html#super).\n* Artima Developer: [Things to Know About Python Super](http://www.artima.com/weblogs/viewpost.jsp?thread=236275).\n* Wikipedia: [Composition over inheritance](http://en.wikipedia.org/wiki/Composition_over_inheritance).\n","markdown":"# Multiple calls to `__del__` during object destruction\nPython, unlike statically typed languages such as Java, allows complete freedom when calling methods during object destruction. However, standard object-oriented principles apply to Python classes using deep inheritance hierarchies. Therefore the developer has responsibility for ensuring that objects are properly cleaned up when there are multiple `__del__` methods that need to be called.\n\nCalling a `__del__` method more than once during object destruction risks resources being released multiple times. The relevant `__del__` method may not be designed to be called more than once.\n\nThere are a number of ways that a `__del__` method may be be called more than once.\n\n* There may be more than one explicit call to the method in the hierarchy of `__del__` methods.\n* A class using multiple inheritance directly calls the `__del__` methods of its base types. One or more of those base types uses `super()` to pass down the inheritance chain.\n\n## Recommendation\nEither be careful not to explicitly call a `__del__` method more than once, or use `super()` throughout the inheritance hierarchy.\n\nAlternatively refactor one or more of the classes to use composition rather than inheritance.\n\n\n## Example\nIn the first example, explicit calls to `__del__` are used, but `SportsCar` erroneously calls both `Vehicle.__del__` and `Car.__del__`. This can be fixed by removing the call to `Vehicle.__del__`, as shown in `FixedSportsCar`.\n\n\n```python\n#Calling a method multiple times by using explicit calls when a base inherits from other base\nclass Vehicle(object):\n    \n    def __del__(self):\n        recycle(self.base_parts)\n        \n        \nclass Car(Vehicle):\n    \n    def __del__(self):\n        recycle(self.car_parts)\n        Vehicle.__del__(self)\n    \n    \nclass SportsCar(Car, Vehicle):\n    \n    # Vehicle.__del__ will get called twice\n    def __del__(self):\n        recycle(self.sports_car_parts)\n        Car.__del__(self)\n        Vehicle.__del__(self)\n        \n        \n#Fix SportsCar by only calling Car.__del__\nclass FixedSportsCar(Car, Vehicle):\n    \n    def __del__(self):\n        recycle(self.sports_car_parts)\n        Car.__del__(self)\n\n```\nIn the second example, there is a mixture of explicit calls to `__del__` and calls using `super()`. To fix this example, `super()` should be used throughout.\n\n\n```python\n\n#Calling a method multiple times by using explicit calls when a base uses super()\nclass Vehicle(object):\n     \n    def __init__(self):\n        super(Vehicle, self).__init__()\n        self.mobile = True\n        \nclass Car(Vehicle):\n    \n    def __init__(self):\n        super(Car, self).__init__()\n        self.car_init()\n        \n    def car_init(self):\n        pass\n        \nclass SportsCar(Car, Vehicle):\n    \n    # Vehicle.__init__ will get called twice\n    def __init__(self):\n        Vehicle.__init__(self)\n        Car.__init__(self)\n        self.sports_car_init()\n        \n    def sports_car_init(self):\n        pass\n        \n#Fix SportsCar by using super()\nclass FixedSportsCar(Car, Vehicle):\n    \n    def __init__(self):\n        super(SportsCar, self).__init__()\n        self.sports_car_init()\n        \n    def sports_car_init(self):\n        pass\n\n\n```\n\n## References\n* Python Tutorial: [Classes](https://docs.python.org/2/tutorial/classes.html).\n* Python Standard Library: [super](https://docs.python.org/2/library/functions.html#super).\n* Artima Developer: [Things to Know About Python Super](http://www.artima.com/weblogs/viewpost.jsp?thread=236275).\n* Wikipedia: [Composition over inheritance](http://en.wikipedia.org/wiki/Composition_over_inheritance).\n"},"properties":{"tags":["quality","reliability","correctness"],"description":"A duplicated call to a super-class `__del__` method may lead to class instances not be cleaned up properly.","id":"py/multiple-calls-to-delete","kind":"problem","name":"Multiple calls to `__del__` during object destruction","precision":"very-high","problem.severity":"warning","sub-severity":"high"}},{"id":"py/call/wrong-number-class-arguments","name":"py/call/wrong-number-class-arguments","shortDescription":{"text":"Wrong number of arguments in a class instantiation"},"fullDescription":{"text":"Using too many or too few arguments in a call to the `__init__` method of a class will result in a TypeError at runtime."},"defaultConfiguration":{"enabled":true,"level":"error"},"help":{"text":"# Wrong number of arguments in a class instantiation\nA call to the `__init__` method of a class must supply an argument for each parameter that does not have a default value defined, so:\n\n* The minimum number of arguments is the number of parameters without default values.\n* The maximum number of arguments is the total number of parameters, unless the class `__init__` method takes a varargs (starred) parameter in which case there is no limit.\n\n## Recommendation\nIf there are too few arguments then check to see which arguments have been omitted and supply values for those.\n\nIf there are too many arguments then check to see if any have been added by mistake and remove those.\n\nAlso check where a comma has been inserted instead of an operator or a dot. For example, the code is `obj,attr` when it should be `obj.attr`.\n\nIf it is not clear which are the missing or surplus arguments, then this suggests a logical error. The fix will then depend on the nature of the error.\n\n\n## Example\n\n```python\nclass Point(object):\n    def __init__(self, x, y):\n        self.x = x\n        self.y = y\n\np = Point(1)      # TypeError: too few arguments\np = Point(1,2,3)  # TypeError: too many arguments\n\n```\n\n## References\n* Python Glossary: [Arguments](https://docs.python.org/2/glossary.html#term-argument).\n* Python Glossary: [Parameters](https://docs.python.org/glossary.html#term-parameter).\n* Python Programming FAQ: [ What is the difference between arguments and parameters?](https://docs.python.org/2/faq/programming.html#faq-argument-vs-parameter).\n* The Python Language Reference: [Data model: object.__init__](https://docs.python.org/3/reference/datamodel.html#object.__init__)\n* The Python Tutorial: [Classes](https://docs.python.org/3/tutorial/classes.html)\n* Common Weakness Enumeration: [CWE-685](https://cwe.mitre.org/data/definitions/685.html).\n","markdown":"# Wrong number of arguments in a class instantiation\nA call to the `__init__` method of a class must supply an argument for each parameter that does not have a default value defined, so:\n\n* The minimum number of arguments is the number of parameters without default values.\n* The maximum number of arguments is the total number of parameters, unless the class `__init__` method takes a varargs (starred) parameter in which case there is no limit.\n\n## Recommendation\nIf there are too few arguments then check to see which arguments have been omitted and supply values for those.\n\nIf there are too many arguments then check to see if any have been added by mistake and remove those.\n\nAlso check where a comma has been inserted instead of an operator or a dot. For example, the code is `obj,attr` when it should be `obj.attr`.\n\nIf it is not clear which are the missing or surplus arguments, then this suggests a logical error. The fix will then depend on the nature of the error.\n\n\n## Example\n\n```python\nclass Point(object):\n    def __init__(self, x, y):\n        self.x = x\n        self.y = y\n\np = Point(1)      # TypeError: too few arguments\np = Point(1,2,3)  # TypeError: too many arguments\n\n```\n\n## References\n* Python Glossary: [Arguments](https://docs.python.org/2/glossary.html#term-argument).\n* Python Glossary: [Parameters](https://docs.python.org/glossary.html#term-parameter).\n* Python Programming FAQ: [ What is the difference between arguments and parameters?](https://docs.python.org/2/faq/programming.html#faq-argument-vs-parameter).\n* The Python Language Reference: [Data model: object.__init__](https://docs.python.org/3/reference/datamodel.html#object.__init__)\n* The Python Tutorial: [Classes](https://docs.python.org/3/tutorial/classes.html)\n* Common Weakness Enumeration: [CWE-685](https://cwe.mitre.org/data/definitions/685.html).\n"},"properties":{"tags":["quality","reliability","correctness","external/cwe/cwe-685"],"description":"Using too many or too few arguments in a call to the `__init__`\n              method of a class will result in a TypeError at runtime.","id":"py/call/wrong-number-class-arguments","kind":"problem","name":"Wrong number of arguments in a class instantiation","precision":"very-high","problem.severity":"error","sub-severity":"low"}},{"id":"py/slots-in-old-style-class","name":"py/slots-in-old-style-class","shortDescription":{"text":"`__slots__` in old-style class"},"fullDescription":{"text":"Overriding the class dictionary by declaring `__slots__` is not supported by old-style classes."},"defaultConfiguration":{"enabled":true,"level":"error"},"help":{"text":"# `__slots__` in old-style class\nThe ability to override the class dictionary using a `__slots__` declaration is supported only by new-style classes. When you add a `__slots__` declaration to an old-style class it just creates a class attribute called `__slots__`.\n\n\n## Recommendation\nIf you want to override the dictionary for a class, then ensure that the class is a new-style class. You can convert an old-style class to a new-style class by inheriting from `object`.\n\n\n## Example\nIn the following Python 2 example the `Point` class is an old-style class (no inheritance). The `__slots__` declaration in this class creates a class attribute called `__slots__`, the class dictionary is unaffected. The `Point2` class is a new-style class so the `__slots__` declaration causes special compact attributes to be created for each name in the slots list and saves space by not creating attribute dictionaries.\n\n\n```python\nclass Point:\n\n    __slots__ = [ '_x', '_y' ] # Incorrect: 'Point' is an old-style class.\n                               # No slots are created.\n                               # Instances of Point have an attribute dictionary.\n\n    def __init__(self, x, y):\n        self._x = x\n        self._y = y\n\n\nclass Point2(object):\n\n    __slots__ = [ '_x', '_y' ] # Correct: 'Point2' is an new-style class\n                               # Two slots '_x' and '_y' are created.\n                               # Instances of Point2 have no attribute dictionary.\n\n    def __init__(self, x, y):\n        self._x = x\n        self._y = y\n\n```\n\n## References\n* Python Glossary: [New-style class](http://docs.python.org/glossary.html#term-new-style-class).\n* Python Language Reference: [New-style and classic classes](http://docs.python.org/2/reference/datamodel.html#newstyle), [__slots__](http://docs.python.org/reference/datamodel.html#__slots__).\n","markdown":"# `__slots__` in old-style class\nThe ability to override the class dictionary using a `__slots__` declaration is supported only by new-style classes. When you add a `__slots__` declaration to an old-style class it just creates a class attribute called `__slots__`.\n\n\n## Recommendation\nIf you want to override the dictionary for a class, then ensure that the class is a new-style class. You can convert an old-style class to a new-style class by inheriting from `object`.\n\n\n## Example\nIn the following Python 2 example the `Point` class is an old-style class (no inheritance). The `__slots__` declaration in this class creates a class attribute called `__slots__`, the class dictionary is unaffected. The `Point2` class is a new-style class so the `__slots__` declaration causes special compact attributes to be created for each name in the slots list and saves space by not creating attribute dictionaries.\n\n\n```python\nclass Point:\n\n    __slots__ = [ '_x', '_y' ] # Incorrect: 'Point' is an old-style class.\n                               # No slots are created.\n                               # Instances of Point have an attribute dictionary.\n\n    def __init__(self, x, y):\n        self._x = x\n        self._y = y\n\n\nclass Point2(object):\n\n    __slots__ = [ '_x', '_y' ] # Correct: 'Point2' is an new-style class\n                               # Two slots '_x' and '_y' are created.\n                               # Instances of Point2 have no attribute dictionary.\n\n    def __init__(self, x, y):\n        self._x = x\n        self._y = y\n\n```\n\n## References\n* Python Glossary: [New-style class](http://docs.python.org/glossary.html#term-new-style-class).\n* Python Language Reference: [New-style and classic classes](http://docs.python.org/2/reference/datamodel.html#newstyle), [__slots__](http://docs.python.org/reference/datamodel.html#__slots__).\n"},"properties":{"tags":["portability","correctness"],"description":"Overriding the class dictionary by declaring `__slots__` is not supported by old-style\n              classes.","id":"py/slots-in-old-style-class","kind":"problem","name":"`__slots__` in old-style class","precision":"very-high","problem.severity":"error","sub-severity":"low"}},{"id":"py/inconsistent-mro","name":"py/inconsistent-mro","shortDescription":{"text":"Inconsistent method resolution order"},"fullDescription":{"text":"Class definition will raise a type error at runtime due to inconsistent method resolution order(MRO)"},"defaultConfiguration":{"enabled":true,"level":"error"},"help":{"text":"# Inconsistent method resolution order\nPython 2.3 introduced new-style classes (classes inheriting from object). New-style classes use the C3 linearization method to determine a method resolution ordering (MRO) for each class. The C3 linearization method ensures that for a class C, if a class C1 precedes a class C2 in the MRO of C then C1 should also precede C2 in the MRO of all subclasses of C. It is possible to create a situation where it is impossible to achieve this consistency and this will guarantee that a ` TypeError` will be raised at runtime.\n\n\n## Recommendation\nUse a class hierarchy that is not ambiguous.\n\n\n## Example\nThe MRO of class `X` is just `X, object`. The program will fail when the MRO of class `Y` needs to be calculated because `object` precedes `X` in the definition of `Y` but the opposite is true in the MRO of `X`.\n\n\n```python\nclass X(object):\n    def __init__(self):\n        print(\"X\")\nclass Y(object,X):\n    def __init__(self):\n        print(\"Y\")\n```\n\n## References\n* Python: [The Python 2.3 Method Resolution Order](http://www.python.org/download/releases/2.3/mro/).\n","markdown":"# Inconsistent method resolution order\nPython 2.3 introduced new-style classes (classes inheriting from object). New-style classes use the C3 linearization method to determine a method resolution ordering (MRO) for each class. The C3 linearization method ensures that for a class C, if a class C1 precedes a class C2 in the MRO of C then C1 should also precede C2 in the MRO of all subclasses of C. It is possible to create a situation where it is impossible to achieve this consistency and this will guarantee that a ` TypeError` will be raised at runtime.\n\n\n## Recommendation\nUse a class hierarchy that is not ambiguous.\n\n\n## Example\nThe MRO of class `X` is just `X, object`. The program will fail when the MRO of class `Y` needs to be calculated because `object` precedes `X` in the definition of `Y` but the opposite is true in the MRO of `X`.\n\n\n```python\nclass X(object):\n    def __init__(self):\n        print(\"X\")\nclass Y(object,X):\n    def __init__(self):\n        print(\"Y\")\n```\n\n## References\n* Python: [The Python 2.3 Method Resolution Order](http://www.python.org/download/releases/2.3/mro/).\n"},"properties":{"tags":["quality","reliability","correctness"],"description":"Class definition will raise a type error at runtime due to inconsistent method resolution order(MRO)","id":"py/inconsistent-mro","kind":"problem","name":"Inconsistent method resolution order","precision":"very-high","problem.severity":"error","sub-severity":"high"}},{"id":"py/overwritten-inherited-attribute","name":"py/overwritten-inherited-attribute","shortDescription":{"text":"Overwriting attribute in super-class or sub-class"},"fullDescription":{"text":"Assignment to self attribute overwrites attribute previously defined in subclass or superclass `__init__` method."},"defaultConfiguration":{"enabled":true,"level":"warning"},"help":{"text":"# Overwriting attribute in super-class or sub-class\nSubclasses should not set attributes that are set in the superclass. Doing so may violate invariants in the superclass.\n\n\n## Recommendation\nIf you did not intend to override the attribute value set in the superclass, then rename the subclass attribute. If you do want to be able to set a new value for the attribute of the superclass, then convert the superclass attribute to a property. Otherwise the value should be passed as a parameter to the superclass `__init__` method.\n\n\n## Example\n\n```python\n\n#Attribute set in both superclass and subclass\nclass C(object):\n\n    def __init__(self):\n        self.var = 0\n\nclass D(C):\n\n    def __init__(self):\n        self.var = 1 # self.var will be overwritten\n        C.__init__(self)\n\nclass E(object):\n\n    def __init__(self):\n        self.var = 0 # self.var will be overwritten\n\nclass F(E):\n\n    def __init__(self):\n        E.__init__(self)\n        self.var = 1\n\n#Fixed version -- Pass explicitly as a parameter\nclass G(object):\n\n    def __init__(self, var = 0):\n        self.var = var\n\nclass H(G):\n\n    def __init__(self):\n        G.__init__(self, 1)\n\n\n```\n","markdown":"# Overwriting attribute in super-class or sub-class\nSubclasses should not set attributes that are set in the superclass. Doing so may violate invariants in the superclass.\n\n\n## Recommendation\nIf you did not intend to override the attribute value set in the superclass, then rename the subclass attribute. If you do want to be able to set a new value for the attribute of the superclass, then convert the superclass attribute to a property. Otherwise the value should be passed as a parameter to the superclass `__init__` method.\n\n\n## Example\n\n```python\n\n#Attribute set in both superclass and subclass\nclass C(object):\n\n    def __init__(self):\n        self.var = 0\n\nclass D(C):\n\n    def __init__(self):\n        self.var = 1 # self.var will be overwritten\n        C.__init__(self)\n\nclass E(object):\n\n    def __init__(self):\n        self.var = 0 # self.var will be overwritten\n\nclass F(E):\n\n    def __init__(self):\n        E.__init__(self)\n        self.var = 1\n\n#Fixed version -- Pass explicitly as a parameter\nclass G(object):\n\n    def __init__(self, var = 0):\n        self.var = var\n\nclass H(G):\n\n    def __init__(self):\n        G.__init__(self, 1)\n\n\n```\n"},"properties":{"tags":["reliability","maintainability","modularity"],"description":"Assignment to self attribute overwrites attribute previously defined in subclass or superclass `__init__` method.","id":"py/overwritten-inherited-attribute","kind":"problem","name":"Overwriting attribute in super-class or sub-class","precision":"medium","problem.severity":"warning","sub-severity":"low"}},{"id":"py/missing-call-to-delete","name":"py/missing-call-to-delete","shortDescription":{"text":"Missing call to `__del__` during object destruction"},"fullDescription":{"text":"An omitted call to a super-class `__del__` method may lead to class instances not being cleaned up properly."},"defaultConfiguration":{"enabled":true,"level":"error"},"help":{"text":"# Missing call to `__del__` during object destruction\nPython, unlike statically typed languages such as Java, allows complete freedom when calling methods during object destruction. However, standard object-oriented principles apply to Python classes using deep inheritance hierarchies. Therefore the developer has responsibility for ensuring that objects are properly cleaned up when there are multiple `__del__` methods that need to be called.\n\nIf the `__del__` method of a superclass is not called during object destruction it is likely that that resources may be leaked.\n\nA call to the `__del__` method of a superclass during object destruction may be omitted:\n\n* When a subclass calls the `__del__` method of the wrong class.\n* When a call to the `__del__` method of one its base classes is omitted.\n\n## Recommendation\nEither be careful to explicitly call the `__del__` of the correct base class, or use `super()` throughout the inheritance hierarchy.\n\nAlternatively refactor one or more of the classes to use composition rather than inheritance.\n\n\n## Example\nIn this example, explicit calls to `__del__` are used, but `SportsCar` erroneously calls `Vehicle.__del__`. This is fixed in `FixedSportsCar` by calling `Car.__del__`.\n\n\n```python\n\nclass Vehicle(object):\n    \n    def __del__(self):\n        recycle(self.base_parts)\n        \nclass Car(Vehicle):\n    \n    def __del__(self):\n        recycle(self.car_parts)\n        Vehicle.__del__(self)\n        \n#Car.__del__ is missed out.\nclass SportsCar(Car, Vehicle):\n    \n    def __del__(self):\n        recycle(self.sports_car_parts)\n        Vehicle.__del__(self)\n        \n#Fix SportsCar by calling Car.__del__\nclass FixedSportsCar(Car, Vehicle):\n    \n    def __del__(self):\n        recycle(self.sports_car_parts)\n        Car.__del__(self)\n        \n\n```\n\n## References\n* Python Tutorial: [Classes](https://docs.python.org/2/tutorial/classes.html).\n* Python Standard Library: [super](https://docs.python.org/2/library/functions.html#super).\n* Artima Developer: [Things to Know About Python Super](http://www.artima.com/weblogs/viewpost.jsp?thread=236275).\n* Wikipedia: [Composition over inheritance](http://en.wikipedia.org/wiki/Composition_over_inheritance).\n","markdown":"# Missing call to `__del__` during object destruction\nPython, unlike statically typed languages such as Java, allows complete freedom when calling methods during object destruction. However, standard object-oriented principles apply to Python classes using deep inheritance hierarchies. Therefore the developer has responsibility for ensuring that objects are properly cleaned up when there are multiple `__del__` methods that need to be called.\n\nIf the `__del__` method of a superclass is not called during object destruction it is likely that that resources may be leaked.\n\nA call to the `__del__` method of a superclass during object destruction may be omitted:\n\n* When a subclass calls the `__del__` method of the wrong class.\n* When a call to the `__del__` method of one its base classes is omitted.\n\n## Recommendation\nEither be careful to explicitly call the `__del__` of the correct base class, or use `super()` throughout the inheritance hierarchy.\n\nAlternatively refactor one or more of the classes to use composition rather than inheritance.\n\n\n## Example\nIn this example, explicit calls to `__del__` are used, but `SportsCar` erroneously calls `Vehicle.__del__`. This is fixed in `FixedSportsCar` by calling `Car.__del__`.\n\n\n```python\n\nclass Vehicle(object):\n    \n    def __del__(self):\n        recycle(self.base_parts)\n        \nclass Car(Vehicle):\n    \n    def __del__(self):\n        recycle(self.car_parts)\n        Vehicle.__del__(self)\n        \n#Car.__del__ is missed out.\nclass SportsCar(Car, Vehicle):\n    \n    def __del__(self):\n        recycle(self.sports_car_parts)\n        Vehicle.__del__(self)\n        \n#Fix SportsCar by calling Car.__del__\nclass FixedSportsCar(Car, Vehicle):\n    \n    def __del__(self):\n        recycle(self.sports_car_parts)\n        Car.__del__(self)\n        \n\n```\n\n## References\n* Python Tutorial: [Classes](https://docs.python.org/2/tutorial/classes.html).\n* Python Standard Library: [super](https://docs.python.org/2/library/functions.html#super).\n* Artima Developer: [Things to Know About Python Super](http://www.artima.com/weblogs/viewpost.jsp?thread=236275).\n* Wikipedia: [Composition over inheritance](http://en.wikipedia.org/wiki/Composition_over_inheritance).\n"},"properties":{"tags":["quality","reliability","correctness","performance"],"description":"An omitted call to a super-class `__del__` method may lead to class instances not being cleaned up properly.","id":"py/missing-call-to-delete","kind":"problem","name":"Missing call to `__del__` during object destruction","precision":"high","problem.severity":"error","sub-severity":"low"}},{"id":"py/missing-call-to-init","name":"py/missing-call-to-init","shortDescription":{"text":"Missing call to `__init__` during object initialization"},"fullDescription":{"text":"An omitted call to a super-class `__init__` method may lead to objects of this class not being fully initialized."},"defaultConfiguration":{"enabled":true,"level":"error"},"help":{"text":"# Missing call to `__init__` during object initialization\nPython, unlike statically typed languages such as Java, allows complete freedom when calling methods during object initialization. However, standard object-oriented principles apply to Python classes using deep inheritance hierarchies. Therefore the developer has responsibility for ensuring that objects are properly initialized when there are multiple `__init__` methods that need to be called.\n\nIf the `__init__` method of a superclass is not called during object initialization it is likely that that object will end up in an incorrect state.\n\nA call to the `__init__` method of a superclass during object initialization may be omitted:\n\n* When a subclass calls the `__init__` method of the wrong class.\n* When a call to the `__init__` method of one its base classes is omitted.\n* When multiple inheritance is used and a class inherits from several base classes, and at least one of those does not use `super()` in its own `__init__` method.\n\n## Recommendation\nEither be careful to explicitly call the `__init__` of the correct base class, or use `super()` throughout the inheritance hierarchy.\n\nAlternatively refactor one or more of the classes to use composition rather than inheritance.\n\n\n## Example\nIn this example, explicit calls to `__init__` are used, but `SportsCar` erroneously calls `Vehicle.__init__`. This is fixed in `FixedSportsCar` by calling `Car.__init__`.\n\n\n```python\n\nclass Vehicle(object):\n    \n    def __init__(self):\n        self.mobile = True\n        \nclass Car(Vehicle):\n    \n    def __init__(self):\n        Vehicle.__init__(self)\n        self.car_init()\n        \n#Car.__init__ is missed out.\nclass SportsCar(Car, Vehicle):\n    \n    def __init__(self):\n        Vehicle.__init__(self)\n        self.sports_car_init()\n        \n#Fix SportsCar by calling Car.__init__\nclass FixedSportsCar(Car, Vehicle):\n    \n    def __init__(self):\n        Car.__init__(self)\n        self.sports_car_init()\n        \n\n```\n\n## References\n* Python Tutorial: [Classes](https://docs.python.org/2/tutorial/classes.html).\n* Python Standard Library: [super](https://docs.python.org/2/library/functions.html#super).\n* Artima Developer: [Things to Know About Python Super](http://www.artima.com/weblogs/viewpost.jsp?thread=236275).\n* Wikipedia: [Composition over inheritance](http://en.wikipedia.org/wiki/Composition_over_inheritance).\n","markdown":"# Missing call to `__init__` during object initialization\nPython, unlike statically typed languages such as Java, allows complete freedom when calling methods during object initialization. However, standard object-oriented principles apply to Python classes using deep inheritance hierarchies. Therefore the developer has responsibility for ensuring that objects are properly initialized when there are multiple `__init__` methods that need to be called.\n\nIf the `__init__` method of a superclass is not called during object initialization it is likely that that object will end up in an incorrect state.\n\nA call to the `__init__` method of a superclass during object initialization may be omitted:\n\n* When a subclass calls the `__init__` method of the wrong class.\n* When a call to the `__init__` method of one its base classes is omitted.\n* When multiple inheritance is used and a class inherits from several base classes, and at least one of those does not use `super()` in its own `__init__` method.\n\n## Recommendation\nEither be careful to explicitly call the `__init__` of the correct base class, or use `super()` throughout the inheritance hierarchy.\n\nAlternatively refactor one or more of the classes to use composition rather than inheritance.\n\n\n## Example\nIn this example, explicit calls to `__init__` are used, but `SportsCar` erroneously calls `Vehicle.__init__`. This is fixed in `FixedSportsCar` by calling `Car.__init__`.\n\n\n```python\n\nclass Vehicle(object):\n    \n    def __init__(self):\n        self.mobile = True\n        \nclass Car(Vehicle):\n    \n    def __init__(self):\n        Vehicle.__init__(self)\n        self.car_init()\n        \n#Car.__init__ is missed out.\nclass SportsCar(Car, Vehicle):\n    \n    def __init__(self):\n        Vehicle.__init__(self)\n        self.sports_car_init()\n        \n#Fix SportsCar by calling Car.__init__\nclass FixedSportsCar(Car, Vehicle):\n    \n    def __init__(self):\n        Car.__init__(self)\n        self.sports_car_init()\n        \n\n```\n\n## References\n* Python Tutorial: [Classes](https://docs.python.org/2/tutorial/classes.html).\n* Python Standard Library: [super](https://docs.python.org/2/library/functions.html#super).\n* Artima Developer: [Things to Know About Python Super](http://www.artima.com/weblogs/viewpost.jsp?thread=236275).\n* Wikipedia: [Composition over inheritance](http://en.wikipedia.org/wiki/Composition_over_inheritance).\n"},"properties":{"tags":["quality","reliability","correctness"],"description":"An omitted call to a super-class `__init__` method may lead to objects of this class not being fully initialized.","id":"py/missing-call-to-init","kind":"problem","name":"Missing call to `__init__` during object initialization","precision":"high","problem.severity":"error","sub-severity":"low"}},{"id":"py/property-in-old-style-class","name":"py/property-in-old-style-class","shortDescription":{"text":"Property in old-style class"},"fullDescription":{"text":"Using property descriptors in old-style classes does not work from Python 2.1 onward."},"defaultConfiguration":{"enabled":true,"level":"error"},"help":{"text":"# Property in old-style class\nProperty descriptors are only supported for the new-style classes that were introduced in Python 2.1. Property descriptors should only be used in new-style classes.\n\n\n## Recommendation\nIf you want to define properties in a class, then ensure that the class is a new-style class. You can convert an old-style class to a new-style class by inheriting from `object`.\n\n\n## Example\nIn the following example all the classes attempt to set a property for `x`. However, only the third and fourth classes are new-style classes. Consequently, the `x` property is only available for the `NewStyle` and `InheritNewStyle` classes.\n\nIf you define the `OldStyle` class as inheriting from a new-style class, then the `x ` property would be available for both the `OldStyle` and `InheritOldStyle` classes.\n\n\n```python\n\nclass OldStyle:\n\n    def __init__(self, x):\n        self._x = x\n\n    # Incorrect: 'OldStyle' is not a new-style class and '@property' is not supported\n    @property\n    def x(self):\n        return self._x\n\n\nclass InheritOldStyle(OldStyle):\n\n    def __init__(self, x):\n        self._x = x\n\n    # Incorrect: 'InheritOldStyle' is not a new-style class and '@property' is not supported\n    @property\n    def x(self):\n        return self._x\n\n\nclass NewStyle(object):\n\n    def __init__(self, x):\n        self._x = x\n\n    # Correct: 'NewStyle' is a new-style class and '@property' is supported\n    @property\n    def x(self):\n        return self._x\n\nclass InheritNewStyle(NewStyle):\n\n    def __init__(self, x):\n        self._x = x\n\n    # Correct: 'InheritNewStyle' inherits from a new-style class and '@property' is supported\n    @property\n    def x(self):\n        return self._x\n\n```\n\n## References\n* Python Glossary: [New-style class](http://docs.python.org/glossary.html#term-new-style-class).\n* Python Language Reference: [New-style and classic classes](http://docs.python.org/2/reference/datamodel.html#newstyle), [ Descriptors](http://docs.python.org/2/reference/datamodel.html#implementing-descriptors).\n* Python Standard Library: [Property](http://docs.python.org/library/functions.html#property).\n* The History of Python: [ Inside story on new-style classes](http://python-history.blogspot.co.uk/2010/06/inside-story-on-new-style-classes.html).\n","markdown":"# Property in old-style class\nProperty descriptors are only supported for the new-style classes that were introduced in Python 2.1. Property descriptors should only be used in new-style classes.\n\n\n## Recommendation\nIf you want to define properties in a class, then ensure that the class is a new-style class. You can convert an old-style class to a new-style class by inheriting from `object`.\n\n\n## Example\nIn the following example all the classes attempt to set a property for `x`. However, only the third and fourth classes are new-style classes. Consequently, the `x` property is only available for the `NewStyle` and `InheritNewStyle` classes.\n\nIf you define the `OldStyle` class as inheriting from a new-style class, then the `x ` property would be available for both the `OldStyle` and `InheritOldStyle` classes.\n\n\n```python\n\nclass OldStyle:\n\n    def __init__(self, x):\n        self._x = x\n\n    # Incorrect: 'OldStyle' is not a new-style class and '@property' is not supported\n    @property\n    def x(self):\n        return self._x\n\n\nclass InheritOldStyle(OldStyle):\n\n    def __init__(self, x):\n        self._x = x\n\n    # Incorrect: 'InheritOldStyle' is not a new-style class and '@property' is not supported\n    @property\n    def x(self):\n        return self._x\n\n\nclass NewStyle(object):\n\n    def __init__(self, x):\n        self._x = x\n\n    # Correct: 'NewStyle' is a new-style class and '@property' is supported\n    @property\n    def x(self):\n        return self._x\n\nclass InheritNewStyle(NewStyle):\n\n    def __init__(self, x):\n        self._x = x\n\n    # Correct: 'InheritNewStyle' inherits from a new-style class and '@property' is supported\n    @property\n    def x(self):\n        return self._x\n\n```\n\n## References\n* Python Glossary: [New-style class](http://docs.python.org/glossary.html#term-new-style-class).\n* Python Language Reference: [New-style and classic classes](http://docs.python.org/2/reference/datamodel.html#newstyle), [ Descriptors](http://docs.python.org/2/reference/datamodel.html#implementing-descriptors).\n* Python Standard Library: [Property](http://docs.python.org/library/functions.html#property).\n* The History of Python: [ Inside story on new-style classes](http://python-history.blogspot.co.uk/2010/06/inside-story-on-new-style-classes.html).\n"},"properties":{"tags":["portability","correctness"],"description":"Using property descriptors in old-style classes does not work from Python 2.1 onward.","id":"py/property-in-old-style-class","kind":"problem","name":"Property in old-style class","precision":"very-high","problem.severity":"error","sub-severity":"low"}},{"id":"py/super-in-old-style","name":"py/super-in-old-style","shortDescription":{"text":"'super' in old style class"},"fullDescription":{"text":"Using super() to access inherited methods is not supported by old-style classes."},"defaultConfiguration":{"enabled":true,"level":"error"},"help":{"text":"# 'super' in old style class\nThe ability to access inherited methods that have been overridden in a class using `super()` is supported only by new-style classes. When you use the `super()` function in an old-style class it fails.\n\n\n## Recommendation\nIf you want to access inherited methods using the `super()` built-in, then ensure that the class is a new-style class. You can convert an old-style class to a new-style class by inheriting from `object`. Alternatively, you can call the `__init__` method of the superclass directly from an old-style class using: `BaseClass.__init__(...)`.\n\n\n## Example\nIn the following example, `PythonModule` is an old-style class as it inherits from another old-style class. If the `_ModuleIteratorHelper` class cannot be converted into a new-style class, then the call to `super()` must be replaced. The `PythonModule2` class demonstrates the correct way to call a superclass from an old-style class.\n\n\n```python\nclass PythonModule(_ModuleIteratorHelper): # '_ModuleIteratorHelper' and 'PythonModule' are old-style classes\n\n    # class definitions ....\n\n    def walkModules(self, importPackages=False):\n        if importPackages and self.isPackage():\n            self.load()\n        return super(PythonModule, self).walkModules(importPackages=importPackages) # super() will fail\n\n\nclass PythonModule2(_ModuleIteratorHelper): # call to super replaced with direct call to class\n\n    # class definitions ....\n\n    def walkModules(self, importPackages=False):\n        if importPackages and self.isPackage():\n            self.load()\n        return _ModuleIteratorHelper.__init__(PythonModule, self).walkModules(importPackages=importPackages)\n\n```\n\n## References\n* Python Glossary: [New-style class](http://docs.python.org/glossary.html#term-new-style-class).\n* Python Language Reference: [New-style and classic classes](http://docs.python.org/2/reference/datamodel.html#newstyle).\n* Python Standard Library: [super](http://docs.python.org/library/functions.html#super).\n","markdown":"# 'super' in old style class\nThe ability to access inherited methods that have been overridden in a class using `super()` is supported only by new-style classes. When you use the `super()` function in an old-style class it fails.\n\n\n## Recommendation\nIf you want to access inherited methods using the `super()` built-in, then ensure that the class is a new-style class. You can convert an old-style class to a new-style class by inheriting from `object`. Alternatively, you can call the `__init__` method of the superclass directly from an old-style class using: `BaseClass.__init__(...)`.\n\n\n## Example\nIn the following example, `PythonModule` is an old-style class as it inherits from another old-style class. If the `_ModuleIteratorHelper` class cannot be converted into a new-style class, then the call to `super()` must be replaced. The `PythonModule2` class demonstrates the correct way to call a superclass from an old-style class.\n\n\n```python\nclass PythonModule(_ModuleIteratorHelper): # '_ModuleIteratorHelper' and 'PythonModule' are old-style classes\n\n    # class definitions ....\n\n    def walkModules(self, importPackages=False):\n        if importPackages and self.isPackage():\n            self.load()\n        return super(PythonModule, self).walkModules(importPackages=importPackages) # super() will fail\n\n\nclass PythonModule2(_ModuleIteratorHelper): # call to super replaced with direct call to class\n\n    # class definitions ....\n\n    def walkModules(self, importPackages=False):\n        if importPackages and self.isPackage():\n            self.load()\n        return _ModuleIteratorHelper.__init__(PythonModule, self).walkModules(importPackages=importPackages)\n\n```\n\n## References\n* Python Glossary: [New-style class](http://docs.python.org/glossary.html#term-new-style-class).\n* Python Language Reference: [New-style and classic classes](http://docs.python.org/2/reference/datamodel.html#newstyle).\n* Python Standard Library: [super](http://docs.python.org/library/functions.html#super).\n"},"properties":{"tags":["portability","correctness"],"description":"Using super() to access inherited methods is not supported by old-style classes.","id":"py/super-in-old-style","kind":"problem","name":"'super' in old style class","precision":"very-high","problem.severity":"error","sub-severity":"low"}},{"id":"py/multiple-calls-to-init","name":"py/multiple-calls-to-init","shortDescription":{"text":"Multiple calls to `__init__` during object initialization"},"fullDescription":{"text":"A duplicated call to a super-class `__init__` method may lead to objects of this class not being properly initialized."},"defaultConfiguration":{"enabled":true,"level":"warning"},"help":{"text":"# Multiple calls to `__init__` during object initialization\nPython, unlike statically typed languages such as Java, allows complete freedom when calling methods during object initialization. However, standard object-oriented principles apply to Python classes using deep inheritance hierarchies. Therefore the developer has responsibility for ensuring that objects are properly initialized when there are multiple `__init__` methods that need to be called.\n\nCalling an `__init__` method more than once during object initialization risks the object being incorrectly initialized. It is unlikely that the relevant `__init__` method is designed to be called more than once.\n\nThere are a number of ways that an `__init__` method may be be called more than once.\n\n* There may be more than one explicit call to the method in the hierarchy of `__init__` methods.\n* A class using multiple inheritance directly calls the `__init__` methods of its base types. One or more of those base types uses `super()` to pass down the inheritance chain.\n\n## Recommendation\nEither be careful not to explicitly call an `__init__` method more than once, or use `super()` throughout the inheritance hierarchy.\n\nAlternatively refactor one or more of the classes to use composition rather than inheritance.\n\n\n## Example\nIn the first example, explicit calls to `__init__` are used, but `SportsCar` erroneously calls both `Vehicle.__init__` and `Car.__init__`. This can be fixed by removing the call to `Vehicle.__init__`, as shown in `FixedSportsCar`.\n\n\n```python\n#Calling a method multiple times by using explicit calls when a base inherits from other base\nclass Vehicle(object):\n    \n    def __init__(self):\n        self.mobile = True\n        \nclass Car(Vehicle):\n    \n    def __init__(self):\n        Vehicle.__init__(self)\n        self.car_init()\n        \n    def car_init(self):\n        pass\n    \nclass SportsCar(Car, Vehicle):\n    \n    # Vehicle.__init__ will get called twice\n    def __init__(self):\n        Vehicle.__init__(self)\n        Car.__init__(self)\n        self.sports_car_init()\n        \n    def sports_car_init(self):\n        pass\n        \n#Fix SportsCar by only calling Car.__init__\nclass FixedSportsCar(Car, Vehicle):\n    \n    def __init__(self):\n        Car.__init__(self)\n        self.sports_car_init()\n        \n    def sports_car_init(self):\n        pass\n \n\n```\nIn the second example, there is a mixture of explicit calls to `__init__` and calls using `super()`. To fix this example, `super()` should be used throughout.\n\n\n```python\n\n#Calling a method multiple times by using explicit calls when a base uses super()\nclass Vehicle(object):\n     \n    def __init__(self):\n        super(Vehicle, self).__init__()\n        self.mobile = True\n        \nclass Car(Vehicle):\n    \n    def __init__(self):\n        super(Car, self).__init__()\n        self.car_init()\n        \n    def car_init(self):\n        pass\n        \nclass SportsCar(Car, Vehicle):\n    \n    # Vehicle.__init__ will get called twice\n    def __init__(self):\n        Vehicle.__init__(self)\n        Car.__init__(self)\n        self.sports_car_init()\n        \n    def sports_car_init(self):\n        pass\n        \n#Fix SportsCar by using super()\nclass FixedSportsCar(Car, Vehicle):\n    \n    def __init__(self):\n        super(SportsCar, self).__init__()\n        self.sports_car_init()\n        \n    def sports_car_init(self):\n        pass\n\n\n```\n\n## References\n* Python Tutorial: [Classes](https://docs.python.org/2/tutorial/classes.html).\n* Python Standard Library: [super](https://docs.python.org/2/library/functions.html#super).\n* Artima Developer: [Things to Know About Python Super](http://www.artima.com/weblogs/viewpost.jsp?thread=236275).\n* Wikipedia: [Composition over inheritance](http://en.wikipedia.org/wiki/Composition_over_inheritance).\n","markdown":"# Multiple calls to `__init__` during object initialization\nPython, unlike statically typed languages such as Java, allows complete freedom when calling methods during object initialization. However, standard object-oriented principles apply to Python classes using deep inheritance hierarchies. Therefore the developer has responsibility for ensuring that objects are properly initialized when there are multiple `__init__` methods that need to be called.\n\nCalling an `__init__` method more than once during object initialization risks the object being incorrectly initialized. It is unlikely that the relevant `__init__` method is designed to be called more than once.\n\nThere are a number of ways that an `__init__` method may be be called more than once.\n\n* There may be more than one explicit call to the method in the hierarchy of `__init__` methods.\n* A class using multiple inheritance directly calls the `__init__` methods of its base types. One or more of those base types uses `super()` to pass down the inheritance chain.\n\n## Recommendation\nEither be careful not to explicitly call an `__init__` method more than once, or use `super()` throughout the inheritance hierarchy.\n\nAlternatively refactor one or more of the classes to use composition rather than inheritance.\n\n\n## Example\nIn the first example, explicit calls to `__init__` are used, but `SportsCar` erroneously calls both `Vehicle.__init__` and `Car.__init__`. This can be fixed by removing the call to `Vehicle.__init__`, as shown in `FixedSportsCar`.\n\n\n```python\n#Calling a method multiple times by using explicit calls when a base inherits from other base\nclass Vehicle(object):\n    \n    def __init__(self):\n        self.mobile = True\n        \nclass Car(Vehicle):\n    \n    def __init__(self):\n        Vehicle.__init__(self)\n        self.car_init()\n        \n    def car_init(self):\n        pass\n    \nclass SportsCar(Car, Vehicle):\n    \n    # Vehicle.__init__ will get called twice\n    def __init__(self):\n        Vehicle.__init__(self)\n        Car.__init__(self)\n        self.sports_car_init()\n        \n    def sports_car_init(self):\n        pass\n        \n#Fix SportsCar by only calling Car.__init__\nclass FixedSportsCar(Car, Vehicle):\n    \n    def __init__(self):\n        Car.__init__(self)\n        self.sports_car_init()\n        \n    def sports_car_init(self):\n        pass\n \n\n```\nIn the second example, there is a mixture of explicit calls to `__init__` and calls using `super()`. To fix this example, `super()` should be used throughout.\n\n\n```python\n\n#Calling a method multiple times by using explicit calls when a base uses super()\nclass Vehicle(object):\n     \n    def __init__(self):\n        super(Vehicle, self).__init__()\n        self.mobile = True\n        \nclass Car(Vehicle):\n    \n    def __init__(self):\n        super(Car, self).__init__()\n        self.car_init()\n        \n    def car_init(self):\n        pass\n        \nclass SportsCar(Car, Vehicle):\n    \n    # Vehicle.__init__ will get called twice\n    def __init__(self):\n        Vehicle.__init__(self)\n        Car.__init__(self)\n        self.sports_car_init()\n        \n    def sports_car_init(self):\n        pass\n        \n#Fix SportsCar by using super()\nclass FixedSportsCar(Car, Vehicle):\n    \n    def __init__(self):\n        super(SportsCar, self).__init__()\n        self.sports_car_init()\n        \n    def sports_car_init(self):\n        pass\n\n\n```\n\n## References\n* Python Tutorial: [Classes](https://docs.python.org/2/tutorial/classes.html).\n* Python Standard Library: [super](https://docs.python.org/2/library/functions.html#super).\n* Artima Developer: [Things to Know About Python Super](http://www.artima.com/weblogs/viewpost.jsp?thread=236275).\n* Wikipedia: [Composition over inheritance](http://en.wikipedia.org/wiki/Composition_over_inheritance).\n"},"properties":{"tags":["quality","reliability","correctness"],"description":"A duplicated call to a super-class `__init__` method may lead to objects of this class not being properly initialized.","id":"py/multiple-calls-to-init","kind":"problem","name":"Multiple calls to `__init__` during object initialization","precision":"very-high","problem.severity":"warning","sub-severity":"high"}},{"id":"py/incomplete-ordering","name":"py/incomplete-ordering","shortDescription":{"text":"Incomplete ordering"},"fullDescription":{"text":"Class defines ordering comparison methods, but does not define both strict and nonstrict ordering methods, to ensure all four comparison operators behave as expected."},"defaultConfiguration":{"enabled":true,"level":"warning"},"help":{"text":"# Incomplete ordering\nA class that implements the rich comparison operators (`__lt__`, `__gt__`, `__le__`, or `__ge__`) should ensure that all four comparison operations `<`, `<=`, `>`, and `>=` function as expected, consistent with expected mathematical rules. In Python 3, this is ensured by implementing one of `__lt__` or `__gt__`, and one of `__le__` or `__ge__`. If the ordering is not consistent with default equality, then `__eq__` should also be implemented.\n\n\n## Recommendation\nEnsure that at least one of `__lt__` or `__gt__` and at least one of `__le__` or `__ge__` is defined.\n\nThe `functools.total_ordering` class decorator can be used to automatically implement all four comparison methods from a single one, which is typically the cleanest way to ensure all necessary comparison methods are implemented consistently.\n\n\n## Example\nIn the following example, only the `__lt__` operator has been implemented, which would lead to unexpected errors if the `<=` or `>=` operators are used on `A` instances. The `__le__` method should also be defined, as well as `__eq__` in this case.\n\n\n```python\nclass A:\n    def __init__(self, i):\n        self.i = i\n\n    # BAD: le is not defined, so `A(1) <= A(2)` would result in an error.\n    def __lt__(self, other):\n        return self.i < other.i\n    \n```\n\n## References\n* Python Language Reference: [Rich comparisons in Python](http://docs.python.org/3/reference/datamodel.html#object.__lt__).\n","markdown":"# Incomplete ordering\nA class that implements the rich comparison operators (`__lt__`, `__gt__`, `__le__`, or `__ge__`) should ensure that all four comparison operations `<`, `<=`, `>`, and `>=` function as expected, consistent with expected mathematical rules. In Python 3, this is ensured by implementing one of `__lt__` or `__gt__`, and one of `__le__` or `__ge__`. If the ordering is not consistent with default equality, then `__eq__` should also be implemented.\n\n\n## Recommendation\nEnsure that at least one of `__lt__` or `__gt__` and at least one of `__le__` or `__ge__` is defined.\n\nThe `functools.total_ordering` class decorator can be used to automatically implement all four comparison methods from a single one, which is typically the cleanest way to ensure all necessary comparison methods are implemented consistently.\n\n\n## Example\nIn the following example, only the `__lt__` operator has been implemented, which would lead to unexpected errors if the `<=` or `>=` operators are used on `A` instances. The `__le__` method should also be defined, as well as `__eq__` in this case.\n\n\n```python\nclass A:\n    def __init__(self, i):\n        self.i = i\n\n    # BAD: le is not defined, so `A(1) <= A(2)` would result in an error.\n    def __lt__(self, other):\n        return self.i < other.i\n    \n```\n\n## References\n* Python Language Reference: [Rich comparisons in Python](http://docs.python.org/3/reference/datamodel.html#object.__lt__).\n"},"properties":{"tags":["quality","reliability","correctness"],"description":"Class defines ordering comparison methods, but does not define both strict and nonstrict ordering methods, to ensure all four comparison operators behave as expected.","id":"py/incomplete-ordering","kind":"problem","name":"Incomplete ordering","precision":"very-high","problem.severity":"warning","sub-severity":"low"}},{"id":"py/inconsistent-equality","name":"py/inconsistent-equality","shortDescription":{"text":"Inconsistent equality and inequality"},"fullDescription":{"text":"Class definitions of equality and inequality operators may be inconsistent."},"defaultConfiguration":{"enabled":true,"level":"warning"},"help":{"text":"# Inconsistent equality and inequality\nIn order to ensure the `==` and `!=` operators behave consistently as expected (i.e. they should be negations of each other), care should be taken when implementing the `__eq__` and `__ne__` special methods.\n\nIn Python 3, if the `__eq__` method is defined in a class while the `__ne__` is not, then the `!=` operator will automatically delegate to the `__eq__` method in the expected way.\n\nHowever, if the `__ne__` method is defined without a corresponding `__eq__` method, the `==` operator will still default to object identity (equivalent to the `is` operator), while the `!=` operator will use the `__ne__` method, which may be inconsistent.\n\nAdditionally, if the `__ne__` method is defined on a superclass, and the subclass defines its own `__eq__` method without overriding the superclass `__ne__` method, the `!=` operator will use this superclass `__ne__` method, rather than automatically delegating to `__eq__`, which may be incorrect.\n\n\n## Recommendation\nEnsure that when an `__ne__` method is defined, the `__eq__` method is also defined, and their results are consistent. In most cases, the `__ne__` method does not need to be defined at all, as the default behavior is to delegate to `__eq__` and negate the result.\n\n\n## Example\nIn the following example, `A` defines a `__ne__` method, but not an `__eq__` method. This leads to inconsistent results between equality and inequality operators.\n\n\n```python\nclass A:\n    def __init__(self, a):\n        self.a = a \n\n    # BAD: ne is defined, but not eq.\n    def __ne__(self, other):\n        if not isinstance(other, A):\n            return NotImplemented \n        return self.a != other.a\n\nx = A(1)\ny = A(1)\n\nprint(x == y) # Prints False (potentially unexpected - object identity is used)\nprint(x != y) # Prints False\n\n```\nIn the following example, `C` defines an `__eq__` method, but its `__ne__` implementation is inherited from `B`, which is not consistent with the equality operation.\n\n\n```python\nclass B:\n    def __init__(self, b):\n        self.b = b \n    \n    def __eq__(self, other):\n        return self.b == other.b \n    \n    def __ne__(self, other):\n        return self.b != other.b \n    \nclass C(B):\n    def __init__(self, b, c):\n        super().__init__(b)\n        self.c = c \n\n    # BAD: eq is defined, but != will use superclass ne method, which is not consistent\n    def __eq__(self, other):\n        return self.b == other.b and self.c == other.c \n    \nprint(C(1,2) == C(1,3)) # Prints False \nprint(C(1,2) != C(1,3)) # Prints False (potentially unexpected)\n```\n\n## References\n* Python Language Reference: [object.__ne__](http://docs.python.org/3/reference/datamodel.html#object.__ne__), [Comparisons](http://docs.python.org/3/reference/expressions.html#comparisons).\n","markdown":"# Inconsistent equality and inequality\nIn order to ensure the `==` and `!=` operators behave consistently as expected (i.e. they should be negations of each other), care should be taken when implementing the `__eq__` and `__ne__` special methods.\n\nIn Python 3, if the `__eq__` method is defined in a class while the `__ne__` is not, then the `!=` operator will automatically delegate to the `__eq__` method in the expected way.\n\nHowever, if the `__ne__` method is defined without a corresponding `__eq__` method, the `==` operator will still default to object identity (equivalent to the `is` operator), while the `!=` operator will use the `__ne__` method, which may be inconsistent.\n\nAdditionally, if the `__ne__` method is defined on a superclass, and the subclass defines its own `__eq__` method without overriding the superclass `__ne__` method, the `!=` operator will use this superclass `__ne__` method, rather than automatically delegating to `__eq__`, which may be incorrect.\n\n\n## Recommendation\nEnsure that when an `__ne__` method is defined, the `__eq__` method is also defined, and their results are consistent. In most cases, the `__ne__` method does not need to be defined at all, as the default behavior is to delegate to `__eq__` and negate the result.\n\n\n## Example\nIn the following example, `A` defines a `__ne__` method, but not an `__eq__` method. This leads to inconsistent results between equality and inequality operators.\n\n\n```python\nclass A:\n    def __init__(self, a):\n        self.a = a \n\n    # BAD: ne is defined, but not eq.\n    def __ne__(self, other):\n        if not isinstance(other, A):\n            return NotImplemented \n        return self.a != other.a\n\nx = A(1)\ny = A(1)\n\nprint(x == y) # Prints False (potentially unexpected - object identity is used)\nprint(x != y) # Prints False\n\n```\nIn the following example, `C` defines an `__eq__` method, but its `__ne__` implementation is inherited from `B`, which is not consistent with the equality operation.\n\n\n```python\nclass B:\n    def __init__(self, b):\n        self.b = b \n    \n    def __eq__(self, other):\n        return self.b == other.b \n    \n    def __ne__(self, other):\n        return self.b != other.b \n    \nclass C(B):\n    def __init__(self, b, c):\n        super().__init__(b)\n        self.c = c \n\n    # BAD: eq is defined, but != will use superclass ne method, which is not consistent\n    def __eq__(self, other):\n        return self.b == other.b and self.c == other.c \n    \nprint(C(1,2) == C(1,3)) # Prints False \nprint(C(1,2) != C(1,3)) # Prints False (potentially unexpected)\n```\n\n## References\n* Python Language Reference: [object.__ne__](http://docs.python.org/3/reference/datamodel.html#object.__ne__), [Comparisons](http://docs.python.org/3/reference/expressions.html#comparisons).\n"},"properties":{"tags":["quality","reliability","correctness"],"description":"Class definitions of equality and inequality operators may be inconsistent.","id":"py/inconsistent-equality","kind":"problem","name":"Inconsistent equality and inequality","precision":"very-high","problem.severity":"warning","sub-severity":"high"}},{"id":"py/equals-hash-mismatch","name":"py/equals-hash-mismatch","shortDescription":{"text":"Inconsistent equality and hashing"},"fullDescription":{"text":"Defining a hash operation without defining equality may be a mistake."},"defaultConfiguration":{"enabled":true,"level":"warning"},"help":{"text":"# Inconsistent equality and hashing\nA hashable class has an `__eq__` method, and a `__hash__` method that agrees with equality. When a hash method is defined, an equality method should also be defined; otherwise object identity is used for equality comparisons which may not be intended.\n\nNote that defining an `__eq__` method without defining a `__hash__` method automatically makes the class unhashable in Python 3. (even if a superclass defines a hash method).\n\n\n## Recommendation\nIf a `__hash__` method is defined, ensure a compatible `__eq__` method is also defined.\n\nTo explicitly declare a class as unhashable, set `__hash__ = None`, rather than defining a `__hash__` method that always raises an exception. Otherwise, the class would be incorrectly identified as hashable by an `isinstance(obj, collections.abc.Hashable)` call.\n\n\n## Example\nIn the following example, the `A` class defines an hash method but no equality method. Equality will be determined by object identity, which may not be the expected behaviour.\n\n\n```python\nclass A:\n    def __init__(self, a, b):\n        self.a = a \n        self.b = b\n\n    # No equality method is defined\n    def __hash__(self):\n        return hash((self.a, self.b))\n\n```\n\n## References\n* Python Language Reference: [object.__hash__](http://docs.python.org/reference/datamodel.html#object.__hash__).\n* Python Glossary: [hashable](http://docs.python.org/3/glossary.html#term-hashable).\n* Common Weakness Enumeration: [CWE-581](https://cwe.mitre.org/data/definitions/581.html).\n","markdown":"# Inconsistent equality and hashing\nA hashable class has an `__eq__` method, and a `__hash__` method that agrees with equality. When a hash method is defined, an equality method should also be defined; otherwise object identity is used for equality comparisons which may not be intended.\n\nNote that defining an `__eq__` method without defining a `__hash__` method automatically makes the class unhashable in Python 3. (even if a superclass defines a hash method).\n\n\n## Recommendation\nIf a `__hash__` method is defined, ensure a compatible `__eq__` method is also defined.\n\nTo explicitly declare a class as unhashable, set `__hash__ = None`, rather than defining a `__hash__` method that always raises an exception. Otherwise, the class would be incorrectly identified as hashable by an `isinstance(obj, collections.abc.Hashable)` call.\n\n\n## Example\nIn the following example, the `A` class defines an hash method but no equality method. Equality will be determined by object identity, which may not be the expected behaviour.\n\n\n```python\nclass A:\n    def __init__(self, a, b):\n        self.a = a \n        self.b = b\n\n    # No equality method is defined\n    def __hash__(self):\n        return hash((self.a, self.b))\n\n```\n\n## References\n* Python Language Reference: [object.__hash__](http://docs.python.org/reference/datamodel.html#object.__hash__).\n* Python Glossary: [hashable](http://docs.python.org/3/glossary.html#term-hashable).\n* Common Weakness Enumeration: [CWE-581](https://cwe.mitre.org/data/definitions/581.html).\n"},"properties":{"tags":["quality","reliability","correctness","external/cwe/cwe-581"],"description":"Defining a hash operation without defining equality may be a mistake.","id":"py/equals-hash-mismatch","kind":"problem","name":"Inconsistent equality and hashing","precision":"very-high","problem.severity":"warning","sub-severity":"high"}},{"id":"py/mutable-descriptor","name":"py/mutable-descriptor","shortDescription":{"text":"Mutation of descriptor in `__get__` or `__set__` method."},"fullDescription":{"text":"Descriptor objects can be shared across many instances. Mutating them can cause strange side effects or race conditions."},"defaultConfiguration":{"enabled":true,"level":"error"},"help":{"text":"# Mutation of descriptor in `__get__` or `__set__` method.\nThe descriptor protocol allows user programmable attribute access. The descriptor protocol is what enables class methods, static methods, properties and `super()`.\n\nDescriptor objects are class attributes which control the behavior of instance attributes. Consequently, a single descriptor is common to all instances of a class and should not be mutated when instance attributes are accessed.\n\n\n## Recommendation\nDo not mutate the descriptor object, rather create a new object that contains the necessary state.\n\n\n## Example\nIn this example the descriptor class `MutatingDescriptor` stores a reference to `obj` in an attribute.\n\n\n```python\n\n#This is prone to strange side effects and race conditions.\nclass MutatingDescriptor(object):\n    \n    def __init__(self, func):\n        self.my_func = func\n        \n    def __get__(self, obj, obj_type):\n        #Modified state is visible to all instances of C that might call \"show\".\n        self.my_obj = obj\n        return self\n        \n    def __call__(self, *args):\n        return self.my_func(self.my_obj, *args)\n    \ndef show(obj):\n    print (obj)\n    \nclass C(object):\n    \n    def __init__(self, value):\n        self.value = value\n        \n    def __str__(self):\n        return (\"C: \" + str(self.value))\n    \n    show = MutatingDescriptor(show)\n    \nc1 = C(1)\nc1.show()\nc2 = C(2)\nc2.show()\nc1_show = c1.show\nc2.show\nc1_show()\n\n#Outputs:\n#C: 1\n#C: 2\n#C: 2\n```\nIn the following example, the descriptor class `NonMutatingDescriptor` returns a new object every time `__get__` is called.\n\n\n```python\nimport types\n\n#Immutable version, which is safe to share.\nclass NonMutatingDescriptor(object):\n    \n    def __init__(self, func):\n        self.my_func = func\n        \n    def __get__(self, obj, obj_type):\n        #Return a new object to each access.\n        return types.MethodType(self.my_func, obj)\n    \ndef show(obj):\n    print (obj)\n    \nclass C(object):\n    \n    def __init__(self, value):\n        self.value = value\n        \n    def __str__(self):\n        return (\"C: \" + str(self.value))\n    \n    show = NonMutatingDescriptor(show)\n    \nc1 = C(1)\nc1.show()\nc2 = C(2)\nc2.show()\nc1_show = c1.show\nc2.show\nc1_show()\n\n#Outputs:\n#C: 1\n#C: 2\n#C: 1\n```\n\n## References\n* Python Language Reference: [Implementing Descriptors.](https://docs.python.org/reference/datamodel.html#descriptors)\n* Mark Lutz. *Learning Python*, Section 30.6: Methods Are Objects: Bound or Unbound. O'Reilly 2013.\n* A real world example: [NumPy Issue 5247.](https://github.com/numpy/numpy/issues/5247)\n","markdown":"# Mutation of descriptor in `__get__` or `__set__` method.\nThe descriptor protocol allows user programmable attribute access. The descriptor protocol is what enables class methods, static methods, properties and `super()`.\n\nDescriptor objects are class attributes which control the behavior of instance attributes. Consequently, a single descriptor is common to all instances of a class and should not be mutated when instance attributes are accessed.\n\n\n## Recommendation\nDo not mutate the descriptor object, rather create a new object that contains the necessary state.\n\n\n## Example\nIn this example the descriptor class `MutatingDescriptor` stores a reference to `obj` in an attribute.\n\n\n```python\n\n#This is prone to strange side effects and race conditions.\nclass MutatingDescriptor(object):\n    \n    def __init__(self, func):\n        self.my_func = func\n        \n    def __get__(self, obj, obj_type):\n        #Modified state is visible to all instances of C that might call \"show\".\n        self.my_obj = obj\n        return self\n        \n    def __call__(self, *args):\n        return self.my_func(self.my_obj, *args)\n    \ndef show(obj):\n    print (obj)\n    \nclass C(object):\n    \n    def __init__(self, value):\n        self.value = value\n        \n    def __str__(self):\n        return (\"C: \" + str(self.value))\n    \n    show = MutatingDescriptor(show)\n    \nc1 = C(1)\nc1.show()\nc2 = C(2)\nc2.show()\nc1_show = c1.show\nc2.show\nc1_show()\n\n#Outputs:\n#C: 1\n#C: 2\n#C: 2\n```\nIn the following example, the descriptor class `NonMutatingDescriptor` returns a new object every time `__get__` is called.\n\n\n```python\nimport types\n\n#Immutable version, which is safe to share.\nclass NonMutatingDescriptor(object):\n    \n    def __init__(self, func):\n        self.my_func = func\n        \n    def __get__(self, obj, obj_type):\n        #Return a new object to each access.\n        return types.MethodType(self.my_func, obj)\n    \ndef show(obj):\n    print (obj)\n    \nclass C(object):\n    \n    def __init__(self, value):\n        self.value = value\n        \n    def __str__(self):\n        return (\"C: \" + str(self.value))\n    \n    show = NonMutatingDescriptor(show)\n    \nc1 = C(1)\nc1.show()\nc2 = C(2)\nc2.show()\nc1_show = c1.show\nc2.show\nc1_show()\n\n#Outputs:\n#C: 1\n#C: 2\n#C: 1\n```\n\n## References\n* Python Language Reference: [Implementing Descriptors.](https://docs.python.org/reference/datamodel.html#descriptors)\n* Mark Lutz. *Learning Python*, Section 30.6: Methods Are Objects: Bound or Unbound. O'Reilly 2013.\n* A real world example: [NumPy Issue 5247.](https://github.com/numpy/numpy/issues/5247)\n"},"properties":{"tags":["quality","reliability","correctness"],"description":"Descriptor objects can be shared across many instances. Mutating them can cause strange side effects or race conditions.","id":"py/mutable-descriptor","kind":"problem","name":"Mutation of descriptor in `__get__` or `__set__` method.","precision":"very-high","problem.severity":"error","sub-severity":"low"}},{"id":"py/init-calls-subclass","name":"py/init-calls-subclass","shortDescription":{"text":"`__init__` method calls overridden method"},"fullDescription":{"text":"Calling a method from `__init__` that is overridden by a subclass may result in a partially initialized instance being observed."},"defaultConfiguration":{"enabled":true,"level":"warning"},"help":{"text":"# `__init__` method calls overridden method\nWhen initializing an instance of the class in the class' `__init__` method, calls tha are made using the instance may receive an instance of the class that is not yet fully initialized. When a method called in an initializer is overridden in a subclass, the subclass method receives the instance in a potentially unexpected state. Fields that would be initialized after the call, including potentially in the subclass' `__init__` method, will not be initialized. This may lead to runtime errors, as well as make the code more difficult to maintain, as future changes may not be aware of which fields would not be initialized.\n\n\n## Recommendation\nIf possible, refactor the initializer method such that initialization is complete before calling any overridden methods. For helper methods used as part of initialization, avoid overriding them, and instead call any additional logic required in the subclass' `__init__` method.\n\nIf the overridden method does not depend on the instance `self`, and only on its class, consider making it a `@classmethod` or `@staticmethod` instead.\n\nIf calling an overridden method is absolutely required, consider marking it as an internal method (by using an `_` prefix) to discourage external users of the library from overriding it and observing partially initialized state, and ensure that the fact it is called during initialization is mentioned in the documentation.\n\n\n## Example\nIn the following case, the `__init__` method of `Super` calls the `set_up` method that is overridden by `Sub`. This results in `Sub.set_up` being called with a partially initialized instance of `Super` which may be unexpected.\n\n\n```python\nclass Super(object):\n\n    def __init__(self, arg):\n        self._state = \"Not OK\"\n        self.set_up(arg) # BAD: This method is overridden, so `Sub.set_up` receives a partially initialized instance.\n        self._state = \"OK\"\n\n    def set_up(self, arg):\n        \"Do some setup\"\n        self.a = 2\n\nclass Sub(Super):\n\n    def __init__(self, arg):\n        super().__init__(arg)\n        self.important_state = \"OK\"\n\n    def set_up(self, arg):\n        super().set_up(arg)\n        \"Do some more setup\"\n        # BAD: at this point `self._state` is set to `\"Not OK\"`, and `self.important_state` is not initialized.\n        if self._state == \"OK\":\n            self.b = self.a + 2\n\n```\nIn the following case, the initialization methods are separate between the superclass and the subclass.\n\n\n```python\nclass Super(object):\n\n    def __init__(self, arg):\n        self._state = \"Not OK\"\n        self.super_set_up(arg) # GOOD: This isn't overriden. Instead, additional setup the subclass needs is called by the subclass' `__init__ method.`\n        self._state = \"OK\"\n\n    def super_set_up(self, arg):\n        \"Do some setup\"\n        self.a = 2\n\n\nclass Sub(Super):\n\n    def __init__(self, arg):\n        super().__init__(arg)\n        self.sub_set_up(self, arg)\n        self.important_state = \"OK\"\n\n\n    def sub_set_up(self, arg):\n        \"Do some more setup\"\n        if self._state == \"OK\":\n            self.b = self.a + 2\n```\n\n## References\n* CERT Secure Coding: [ Rule MET05-J](https://www.securecoding.cert.org/confluence/display/java/MET05-J.+Ensure+that+constructors+do+not+call+overridable+methods). Reference discusses Java but is applicable to object oriented programming in many languages.\n* StackOverflow: [Overridable method calls in constructors](https://stackoverflow.com/questions/3404301/whats-wrong-with-overridable-method-calls-in-constructors).\n* Python documentation: [@classmethod](https://docs.python.org/3/library/functions.html#classmethod).\n","markdown":"# `__init__` method calls overridden method\nWhen initializing an instance of the class in the class' `__init__` method, calls tha are made using the instance may receive an instance of the class that is not yet fully initialized. When a method called in an initializer is overridden in a subclass, the subclass method receives the instance in a potentially unexpected state. Fields that would be initialized after the call, including potentially in the subclass' `__init__` method, will not be initialized. This may lead to runtime errors, as well as make the code more difficult to maintain, as future changes may not be aware of which fields would not be initialized.\n\n\n## Recommendation\nIf possible, refactor the initializer method such that initialization is complete before calling any overridden methods. For helper methods used as part of initialization, avoid overriding them, and instead call any additional logic required in the subclass' `__init__` method.\n\nIf the overridden method does not depend on the instance `self`, and only on its class, consider making it a `@classmethod` or `@staticmethod` instead.\n\nIf calling an overridden method is absolutely required, consider marking it as an internal method (by using an `_` prefix) to discourage external users of the library from overriding it and observing partially initialized state, and ensure that the fact it is called during initialization is mentioned in the documentation.\n\n\n## Example\nIn the following case, the `__init__` method of `Super` calls the `set_up` method that is overridden by `Sub`. This results in `Sub.set_up` being called with a partially initialized instance of `Super` which may be unexpected.\n\n\n```python\nclass Super(object):\n\n    def __init__(self, arg):\n        self._state = \"Not OK\"\n        self.set_up(arg) # BAD: This method is overridden, so `Sub.set_up` receives a partially initialized instance.\n        self._state = \"OK\"\n\n    def set_up(self, arg):\n        \"Do some setup\"\n        self.a = 2\n\nclass Sub(Super):\n\n    def __init__(self, arg):\n        super().__init__(arg)\n        self.important_state = \"OK\"\n\n    def set_up(self, arg):\n        super().set_up(arg)\n        \"Do some more setup\"\n        # BAD: at this point `self._state` is set to `\"Not OK\"`, and `self.important_state` is not initialized.\n        if self._state == \"OK\":\n            self.b = self.a + 2\n\n```\nIn the following case, the initialization methods are separate between the superclass and the subclass.\n\n\n```python\nclass Super(object):\n\n    def __init__(self, arg):\n        self._state = \"Not OK\"\n        self.super_set_up(arg) # GOOD: This isn't overriden. Instead, additional setup the subclass needs is called by the subclass' `__init__ method.`\n        self._state = \"OK\"\n\n    def super_set_up(self, arg):\n        \"Do some setup\"\n        self.a = 2\n\n\nclass Sub(Super):\n\n    def __init__(self, arg):\n        super().__init__(arg)\n        self.sub_set_up(self, arg)\n        self.important_state = \"OK\"\n\n\n    def sub_set_up(self, arg):\n        \"Do some more setup\"\n        if self._state == \"OK\":\n            self.b = self.a + 2\n```\n\n## References\n* CERT Secure Coding: [ Rule MET05-J](https://www.securecoding.cert.org/confluence/display/java/MET05-J.+Ensure+that+constructors+do+not+call+overridable+methods). Reference discusses Java but is applicable to object oriented programming in many languages.\n* StackOverflow: [Overridable method calls in constructors](https://stackoverflow.com/questions/3404301/whats-wrong-with-overridable-method-calls-in-constructors).\n* Python documentation: [@classmethod](https://docs.python.org/3/library/functions.html#classmethod).\n"},"properties":{"tags":["reliability","correctness","quality"],"description":"Calling a method from `__init__` that is overridden by a subclass may result in a partially\n              initialized instance being observed.","id":"py/init-calls-subclass","kind":"problem","name":"`__init__` method calls overridden method","precision":"high","problem.severity":"warning","sub-severity":"low"}},{"id":"py/file-not-closed","name":"py/file-not-closed","shortDescription":{"text":"File is not always closed"},"fullDescription":{"text":"Opening a file without ensuring that it is always closed may lead to data loss or resource leaks."},"defaultConfiguration":{"enabled":true,"level":"warning"},"help":{"text":"# File is not always closed\nWhen a file is opened, it should always be closed.\n\nA file opened for writing that is not closed when the application exits may result in data loss, where not all of the data written may be saved to the file. A file opened for reading or writing that is not closed may also use up file descriptors, which is a resource leak that in long running applications could lead to a failure to open additional files.\n\n\n## Recommendation\nEnsure that opened files are always closed, including when an exception could be raised. The best practice is often to use a `with` statement to automatically clean up resources. Otherwise, ensure that `.close()` is called in a `try...except` or `try...finally` block to handle any possible exceptions.\n\n\n## Example\nIn the following examples, in the case marked BAD, the file may not be closed if an exception is raised. In the cases marked GOOD, the file is always closed.\n\n\n```python\ndef bad():\n    f = open(\"filename\", \"w\")\n    f.write(\"could raise exception\") # BAD: This call could raise an exception, leading to the file not being closed.\n    f.close()\n\n\ndef good1():\n    with open(\"filename\", \"w\") as f:\n        f.write(\"always closed\") # GOOD: The `with` statement ensures the file is always closed.\n\ndef good2():\n    f = open(\"filename\", \"w\")\n    try:\n       f.write(\"always closed\")\n    finally:\n        f.close() # GOOD: The `finally` block always ensures the file is closed.\n   \n\n```\n\n## References\n* Python Documentation: [Reading and writing files](https://docs.python.org/3/tutorial/inputoutput.html#reading-and-writing-files).\n* Python Language Reference: [The with statement](http://docs.python.org/reference/compound_stmts.html#the-with-statement), [The try statement](http://docs.python.org/reference/compound_stmts.html#the-try-statement).\n* Python PEP 343: [The \"with\" Statement](http://www.python.org/dev/peps/pep-0343).\n* Common Weakness Enumeration: [CWE-772](https://cwe.mitre.org/data/definitions/772.html).\n","markdown":"# File is not always closed\nWhen a file is opened, it should always be closed.\n\nA file opened for writing that is not closed when the application exits may result in data loss, where not all of the data written may be saved to the file. A file opened for reading or writing that is not closed may also use up file descriptors, which is a resource leak that in long running applications could lead to a failure to open additional files.\n\n\n## Recommendation\nEnsure that opened files are always closed, including when an exception could be raised. The best practice is often to use a `with` statement to automatically clean up resources. Otherwise, ensure that `.close()` is called in a `try...except` or `try...finally` block to handle any possible exceptions.\n\n\n## Example\nIn the following examples, in the case marked BAD, the file may not be closed if an exception is raised. In the cases marked GOOD, the file is always closed.\n\n\n```python\ndef bad():\n    f = open(\"filename\", \"w\")\n    f.write(\"could raise exception\") # BAD: This call could raise an exception, leading to the file not being closed.\n    f.close()\n\n\ndef good1():\n    with open(\"filename\", \"w\") as f:\n        f.write(\"always closed\") # GOOD: The `with` statement ensures the file is always closed.\n\ndef good2():\n    f = open(\"filename\", \"w\")\n    try:\n       f.write(\"always closed\")\n    finally:\n        f.close() # GOOD: The `finally` block always ensures the file is closed.\n   \n\n```\n\n## References\n* Python Documentation: [Reading and writing files](https://docs.python.org/3/tutorial/inputoutput.html#reading-and-writing-files).\n* Python Language Reference: [The with statement](http://docs.python.org/reference/compound_stmts.html#the-with-statement), [The try statement](http://docs.python.org/reference/compound_stmts.html#the-try-statement).\n* Python PEP 343: [The \"with\" Statement](http://www.python.org/dev/peps/pep-0343).\n* Common Weakness Enumeration: [CWE-772](https://cwe.mitre.org/data/definitions/772.html).\n"},"properties":{"tags":["quality","reliability","correctness","performance","external/cwe/cwe-772"],"description":"Opening a file without ensuring that it is always closed may lead to data loss or resource leaks.","id":"py/file-not-closed","kind":"problem","name":"File is not always closed","precision":"high","problem.severity":"warning","sub-severity":"high"}},{"id":"py/commented-out-code","name":"py/commented-out-code","shortDescription":{"text":"Commented-out code"},"fullDescription":{"text":"Commented-out code makes the remaining code more difficult to read."},"defaultConfiguration":{"enabled":true,"level":"note"},"help":{"text":"# Commented-out code\nCommented-out code is distracting and confusing for developers who read the surrounding code, and its significance is often unclear. It will not get compiled or tested when the code around it changes, so it's likely to break over time. For these reasons, commented-out code should be avoided.\n\n\n## Recommendation\nRemove or reinstate the commented-out code. If you want to include a snippet of example code in a comment, consider enclosing it in quotes or marking it up as appropriate for the source language.\n\n\n## Example\nIn the following example, a `print` statement, originally used for debugging, is left in the code, but commented out. It should be removed altogether.\n\n\n```python\ndef area(r):\n    #if DEBUG:\n    #   print(\"Computing area of %r\" % r)\n    return r.length * r.width\n\n```\n\n## References\n* Mark Needham: [The danger of commenting out code](http://www.markhneedham.com/blog/2009/01/17/the-danger-of-commenting-out-code/).\n* Los Techies: [Commented Code == Technical Debt](http://lostechies.com/rodpaddock/2010/12/29/commented-code-technical-debt).\n* High Integrity C++ Coding Standard: [2.3.2 Do not comment out code](http://www.codingstandard.com/rule/2-3-2-do-not-comment-out-code/).\n","markdown":"# Commented-out code\nCommented-out code is distracting and confusing for developers who read the surrounding code, and its significance is often unclear. It will not get compiled or tested when the code around it changes, so it's likely to break over time. For these reasons, commented-out code should be avoided.\n\n\n## Recommendation\nRemove or reinstate the commented-out code. If you want to include a snippet of example code in a comment, consider enclosing it in quotes or marking it up as appropriate for the source language.\n\n\n## Example\nIn the following example, a `print` statement, originally used for debugging, is left in the code, but commented out. It should be removed altogether.\n\n\n```python\ndef area(r):\n    #if DEBUG:\n    #   print(\"Computing area of %r\" % r)\n    return r.length * r.width\n\n```\n\n## References\n* Mark Needham: [The danger of commenting out code](http://www.markhneedham.com/blog/2009/01/17/the-danger-of-commenting-out-code/).\n* Los Techies: [Commented Code == Technical Debt](http://lostechies.com/rodpaddock/2010/12/29/commented-code-technical-debt).\n* High Integrity C++ Coding Standard: [2.3.2 Do not comment out code](http://www.codingstandard.com/rule/2-3-2-do-not-comment-out-code/).\n"},"properties":{"tags":["quality","maintainability","readability"],"description":"Commented-out code makes the remaining code more difficult to read.","id":"py/commented-out-code","kind":"problem","name":"Commented-out code","precision":"high","problem.severity":"recommendation","sub-severity":"high"}},{"id":"py/old-style-octal-literal","name":"py/old-style-octal-literal","shortDescription":{"text":"Confusing octal literal"},"fullDescription":{"text":"Octal literal with a leading 0 is easily misread as a decimal value"},"defaultConfiguration":{"enabled":true,"level":"note"},"help":{"text":"# Confusing octal literal\nOctal literals starting with 0 are easily misread as a decimal, particularly by those programmers who do not have a C or Java background.\n\nThe new literal syntax for non-decimal numbers is more distinct and is thus less likely to be misunderstood.\n\n\n## Recommendation\nUse the 0oXXX form instead of the 0XXX form. Alternatively use binary or hexadecimal format if that would be clearer.\n\n\n## Example\n\n```python\n\n#Easily misread as x = 15\nx = 015\n\n#The extra 'o' alerts the reader that this is an octal literal\ny = 0o15\n\n#If this is a byte sized value then a hexadecimal might be clearer\ny = 0x0d\n\n#Or if it is a bit pattern then a binary value might be clearer\ny = 0b1101\n\n```\n\n## References\n* Python Language Reference: [Integer Literals](http://docs.python.org/2/reference/lexical_analysis.html#integer-and-long-integer-literals).\n* Python PEP 3127: [Integer Literal Support and Syntax](http://www.python.org/dev/peps/pep-3127/).\n","markdown":"# Confusing octal literal\nOctal literals starting with 0 are easily misread as a decimal, particularly by those programmers who do not have a C or Java background.\n\nThe new literal syntax for non-decimal numbers is more distinct and is thus less likely to be misunderstood.\n\n\n## Recommendation\nUse the 0oXXX form instead of the 0XXX form. Alternatively use binary or hexadecimal format if that would be clearer.\n\n\n## Example\n\n```python\n\n#Easily misread as x = 15\nx = 015\n\n#The extra 'o' alerts the reader that this is an octal literal\ny = 0o15\n\n#If this is a byte sized value then a hexadecimal might be clearer\ny = 0x0d\n\n#Or if it is a bit pattern then a binary value might be clearer\ny = 0b1101\n\n```\n\n## References\n* Python Language Reference: [Integer Literals](http://docs.python.org/2/reference/lexical_analysis.html#integer-and-long-integer-literals).\n* Python PEP 3127: [Integer Literal Support and Syntax](http://www.python.org/dev/peps/pep-3127/).\n"},"properties":{"tags":["readability"],"description":"Octal literal with a leading 0 is easily misread as a decimal value","id":"py/old-style-octal-literal","kind":"problem","name":"Confusing octal literal","precision":"high","problem.severity":"recommendation","sub-severity":"low"}},{"id":"py/percent-format/unsupported-character","name":"py/percent-format/unsupported-character","shortDescription":{"text":"Unsupported format character"},"fullDescription":{"text":"An unsupported format character in a format string"},"defaultConfiguration":{"enabled":true,"level":"error"},"help":{"text":"# Unsupported format character\nA printf-style format string (i.e. a string that is used as the left hand side of the `%` operator, such as `fmt % arguments`) must consist of valid conversion specifiers, such as `%s`, `%d`, etc. Otherwise, a `ValueError` will be raised.\n\n\n## Recommendation\nEnsure a valid conversion specifier is used.\n\n\n## Example\nIn the following example, `format_as_tuple_incorrect`, `%t` is not a valid conversion specifier.\n\n\n```python\n\ndef format_as_tuple_incorrect(args):\n    return \"%t\" % args\n\ndef format_as_tuple_correct(args):\n    return \"%r\" % (args,)\n\n```\n\n## References\n* Python Library Reference: [printf-style String Formatting.](https://docs.python.org/3/library/stdtypes.html#printf-style-string-formatting)\n","markdown":"# Unsupported format character\nA printf-style format string (i.e. a string that is used as the left hand side of the `%` operator, such as `fmt % arguments`) must consist of valid conversion specifiers, such as `%s`, `%d`, etc. Otherwise, a `ValueError` will be raised.\n\n\n## Recommendation\nEnsure a valid conversion specifier is used.\n\n\n## Example\nIn the following example, `format_as_tuple_incorrect`, `%t` is not a valid conversion specifier.\n\n\n```python\n\ndef format_as_tuple_incorrect(args):\n    return \"%t\" % args\n\ndef format_as_tuple_correct(args):\n    return \"%r\" % (args,)\n\n```\n\n## References\n* Python Library Reference: [printf-style String Formatting.](https://docs.python.org/3/library/stdtypes.html#printf-style-string-formatting)\n"},"properties":{"tags":["quality","reliability","correctness"],"description":"An unsupported format character in a format string","id":"py/percent-format/unsupported-character","kind":"problem","name":"Unsupported format character","precision":"high","problem.severity":"error","sub-severity":"low"}},{"id":"py/explicit-call-to-delete","name":"py/explicit-call-to-delete","shortDescription":{"text":"`__del__` is called explicitly"},"fullDescription":{"text":"The `__del__` special method is called by the virtual machine when an object is being finalized. It should not be called explicitly."},"defaultConfiguration":{"enabled":true,"level":"warning"},"help":{"text":"# `__del__` is called explicitly\nThe `__del__` special method is designed to be called by the Python virtual machine when an object is no longer reachable, but before it is destroyed. Calling a `__del__` method explicitly may cause an object to enter an unsafe state.\n\n\n## Recommendation\nIf explicit clean up of an object is required, a `close()` method should be called or, better still, wrap the use of the object in a `with` statement.\n\n\n## Example\nIn the first example, rather than close the zip file in a conventional manner, the programmer has called `__del__`. A safer alternative is shown in the second example.\n\n\n```python\n\n\ndef extract_bad(zippath, dest):\n    zipped = ZipFile(zippath)\n    try:\n        zipped.extractall(dest)\n    finally:\n        zipped.__del__()\n\ndef extract_good(zippath, dest):\n    zipped = ZipFile(zippath)\n    try:\n        zipped.extractall(dest)\n    finally:\n        zipped.close()\n\n\n```\n\n## References\n* Python Standard Library: [object.__del__](http://docs.python.org/reference/datamodel.html#object.__del__)\n","markdown":"# `__del__` is called explicitly\nThe `__del__` special method is designed to be called by the Python virtual machine when an object is no longer reachable, but before it is destroyed. Calling a `__del__` method explicitly may cause an object to enter an unsafe state.\n\n\n## Recommendation\nIf explicit clean up of an object is required, a `close()` method should be called or, better still, wrap the use of the object in a `with` statement.\n\n\n## Example\nIn the first example, rather than close the zip file in a conventional manner, the programmer has called `__del__`. A safer alternative is shown in the second example.\n\n\n```python\n\n\ndef extract_bad(zippath, dest):\n    zipped = ZipFile(zippath)\n    try:\n        zipped.extractall(dest)\n    finally:\n        zipped.__del__()\n\ndef extract_good(zippath, dest):\n    zipped = ZipFile(zippath)\n    try:\n        zipped.extractall(dest)\n    finally:\n        zipped.close()\n\n\n```\n\n## References\n* Python Standard Library: [object.__del__](http://docs.python.org/reference/datamodel.html#object.__del__)\n"},"properties":{"tags":["quality","reliability","correctness"],"description":"The `__del__` special method is called by the virtual machine when an object is being finalized. It should not be called explicitly.","id":"py/explicit-call-to-delete","kind":"problem","name":"`__del__` is called explicitly","precision":"very-high","problem.severity":"warning","sub-severity":"low"}},{"id":"py/duplicate-key-dict-literal","name":"py/duplicate-key-dict-literal","shortDescription":{"text":"Duplicate key in dict literal"},"fullDescription":{"text":"Duplicate key in dict literal. All but the last will be lost."},"defaultConfiguration":{"enabled":true,"level":"warning"},"help":{"text":"# Duplicate key in dict literal\nDictionary literals are constructed in the order given in the source. This means that if a key is duplicated, the second key-value pair will overwrite the first; as a dictionary can only have one value per key.\n\n\n## Recommendation\nCheck for typos to ensure that the keys are supposed to be the same. If they are then decide which value is wanted and delete the other one.\n\n\n## Example\nThe following example will output `\"c\"`, because the mapping between 2 and `\"b\"` is overwritten by the mapping from 2 to `\"c\"`. The programmer may have meant to map 3 to `\"c\"` instead.\n\n\n```python\ndictionary = {1:\"a\", 2:\"b\", 2:\"c\"} # BAD: The `2` key is duplicated.\nprint(dictionary[2])\n```\n\n## References\n* Python: [Dictionary literals](http://docs.python.org/3/reference/expressions.html#dictionary-displays).\n* Common Weakness Enumeration: [CWE-561](https://cwe.mitre.org/data/definitions/561.html).\n","markdown":"# Duplicate key in dict literal\nDictionary literals are constructed in the order given in the source. This means that if a key is duplicated, the second key-value pair will overwrite the first; as a dictionary can only have one value per key.\n\n\n## Recommendation\nCheck for typos to ensure that the keys are supposed to be the same. If they are then decide which value is wanted and delete the other one.\n\n\n## Example\nThe following example will output `\"c\"`, because the mapping between 2 and `\"b\"` is overwritten by the mapping from 2 to `\"c\"`. The programmer may have meant to map 3 to `\"c\"` instead.\n\n\n```python\ndictionary = {1:\"a\", 2:\"b\", 2:\"c\"} # BAD: The `2` key is duplicated.\nprint(dictionary[2])\n```\n\n## References\n* Python: [Dictionary literals](http://docs.python.org/3/reference/expressions.html#dictionary-displays).\n* Common Weakness Enumeration: [CWE-561](https://cwe.mitre.org/data/definitions/561.html).\n"},"properties":{"tags":["quality","maintainability","useless-code","external/cwe/cwe-561"],"description":"Duplicate key in dict literal. All but the last will be lost.","id":"py/duplicate-key-dict-literal","kind":"problem","name":"Duplicate key in dict literal","precision":"very-high","problem.severity":"warning","sub-severity":"high"}},{"id":"py/comparison-using-is","name":"py/comparison-using-is","shortDescription":{"text":"Comparison using is when operands support `__eq__`"},"fullDescription":{"text":"Comparison using `is` when equivalence is not the same as identity"},"defaultConfiguration":{"enabled":true,"level":"warning"},"help":{"text":"# Comparison using is when operands support `__eq__`\nWhen you compare two values using the `is` or `is not` operator, it is the object identities of the two values that is tested rather than their equality. If the class of either of the values in the comparison redefines equality then the `is` operator may return `False` even though the objects compare as equal. Equality is defined by the `__eq__` or, in Python2, `__cmp__` method. To compare two objects for equality, use the `==` or `!=` operator instead.\n\n\n## Recommendation\nWhen you want to compare the value of two literals, use the comparison operator `==` or `!=` in place of `is` or `is not`.\n\nIf the uniqueness property or performance are important then use an object that does not redefine equality.\n\n\n## Example\nIn the first line of the following example the programmer tests the value of `value` against `DEFAULT` using the `is` operator. Unfortunately, this may fail when the function is called with the string `\"default\"`.\n\nTo function correctly, change the expression `value is DEFAULT` to `value == DEFAULT`. Alternatively, if the uniqueness property is desirable, then change the definition of `DEFAULT` to either of the alternatives below.\n\n\n```python\n\nDEFAULT = \"default\"\n\ndef get_color(name, fallback):\n    if name in COLORS:\n        return COLORS[name]\n    elif fallback is DEFAULT:\n        return DEFAULT_COLOR\n    else:\n        return fallback\n\n#This works\nprint (get_color(\"spam\", \"def\" + \"ault\"))\n\n#But this does not\nprint (get_color(\"spam\", \"default-spam\"[:7]))\n\n#To fix the above code change to object\nDEFAULT = object()\n\n#Or if you want better repr() output:\nclass Default(object):\n\n    def __repr__(self):\n        return \"DEFAULT\"\n\nDEFAULT = Default()\n\n```\n\n## References\n* Python Standard Library: [Comparisons](http://docs.python.org/3/library/stdtypes.html#comparisons).\n","markdown":"# Comparison using is when operands support `__eq__`\nWhen you compare two values using the `is` or `is not` operator, it is the object identities of the two values that is tested rather than their equality. If the class of either of the values in the comparison redefines equality then the `is` operator may return `False` even though the objects compare as equal. Equality is defined by the `__eq__` or, in Python2, `__cmp__` method. To compare two objects for equality, use the `==` or `!=` operator instead.\n\n\n## Recommendation\nWhen you want to compare the value of two literals, use the comparison operator `==` or `!=` in place of `is` or `is not`.\n\nIf the uniqueness property or performance are important then use an object that does not redefine equality.\n\n\n## Example\nIn the first line of the following example the programmer tests the value of `value` against `DEFAULT` using the `is` operator. Unfortunately, this may fail when the function is called with the string `\"default\"`.\n\nTo function correctly, change the expression `value is DEFAULT` to `value == DEFAULT`. Alternatively, if the uniqueness property is desirable, then change the definition of `DEFAULT` to either of the alternatives below.\n\n\n```python\n\nDEFAULT = \"default\"\n\ndef get_color(name, fallback):\n    if name in COLORS:\n        return COLORS[name]\n    elif fallback is DEFAULT:\n        return DEFAULT_COLOR\n    else:\n        return fallback\n\n#This works\nprint (get_color(\"spam\", \"def\" + \"ault\"))\n\n#But this does not\nprint (get_color(\"spam\", \"default-spam\"[:7]))\n\n#To fix the above code change to object\nDEFAULT = object()\n\n#Or if you want better repr() output:\nclass Default(object):\n\n    def __repr__(self):\n        return \"DEFAULT\"\n\nDEFAULT = Default()\n\n```\n\n## References\n* Python Standard Library: [Comparisons](http://docs.python.org/3/library/stdtypes.html#comparisons).\n"},"properties":{"tags":["quality","reliability","correctness"],"description":"Comparison using `is` when equivalence is not the same as identity","id":"py/comparison-using-is","kind":"problem","name":"Comparison using is when operands support `__eq__`","precision":"high","problem.severity":"warning","sub-severity":"low"}},{"id":"py/hash-unhashable-value","name":"py/hash-unhashable-value","shortDescription":{"text":"Unhashable object hashed"},"fullDescription":{"text":"Hashing an object which is not hashable will result in a TypeError at runtime."},"defaultConfiguration":{"enabled":true,"level":"error"},"help":{"text":"# Unhashable object hashed\nIf an object is used as a key in a dictionary or as a member of a set then it must be hashable, that is it must define a `__hash__` method. All built-in immutable types are hashable, but mutable ones are not. Common hashable types include all numbers, strings (both `unicode` and `bytes`) and `tuple`. Common unhashable types include `list`, `dict` and `set`.\n\nIn order to store a key in a `dict` or `set` a hash value is needed. To determine this value the built-in function `hash()` is called which in turn calls the `__hash__` method on the object. If the object's class does not have the `__hash__` method, then a `TypeError` will be raised.\n\n\n## Recommendation\nSince this problem usually indicates a logical error, it is not possible to give a general recipe for fixing it. Mutable collections can be converted into immutable equivalents where appropriate. For example sets can be hashed by converting any instances of `set` into `frozenset` instances.\n\n\n## Example\n`list`s are not hashable. In this example, an attempt is made to use a `list` as a key in a mapping which will fail with a `TypeError`.\n\n\n```python\n\ndef lookup_with_default_key(mapping, key=None):\n    if key is None:\n        key = [] # Should be key = ()\n    return mapping[key]\n\n```\n\n## References\n* Python Standard Library: [hash](http://docs.python.org/library/functions.html#hash).\n* Python Language Reference: [object.__hash__](http://docs.python.org/reference/datamodel.html#object.__hash__).\n* Python Standard Library: [Mapping Types &mdash; dict](http://docs.python.org/library/stdtypes.html#mapping-types-dict).\n* Python Standard Library: [Set Types &mdash; set, frozenset](http://docs.python.org/2/library/stdtypes.html#set-types-set-frozenset).\n","markdown":"# Unhashable object hashed\nIf an object is used as a key in a dictionary or as a member of a set then it must be hashable, that is it must define a `__hash__` method. All built-in immutable types are hashable, but mutable ones are not. Common hashable types include all numbers, strings (both `unicode` and `bytes`) and `tuple`. Common unhashable types include `list`, `dict` and `set`.\n\nIn order to store a key in a `dict` or `set` a hash value is needed. To determine this value the built-in function `hash()` is called which in turn calls the `__hash__` method on the object. If the object's class does not have the `__hash__` method, then a `TypeError` will be raised.\n\n\n## Recommendation\nSince this problem usually indicates a logical error, it is not possible to give a general recipe for fixing it. Mutable collections can be converted into immutable equivalents where appropriate. For example sets can be hashed by converting any instances of `set` into `frozenset` instances.\n\n\n## Example\n`list`s are not hashable. In this example, an attempt is made to use a `list` as a key in a mapping which will fail with a `TypeError`.\n\n\n```python\n\ndef lookup_with_default_key(mapping, key=None):\n    if key is None:\n        key = [] # Should be key = ()\n    return mapping[key]\n\n```\n\n## References\n* Python Standard Library: [hash](http://docs.python.org/library/functions.html#hash).\n* Python Language Reference: [object.__hash__](http://docs.python.org/reference/datamodel.html#object.__hash__).\n* Python Standard Library: [Mapping Types &mdash; dict](http://docs.python.org/library/stdtypes.html#mapping-types-dict).\n* Python Standard Library: [Set Types &mdash; set, frozenset](http://docs.python.org/2/library/stdtypes.html#set-types-set-frozenset).\n"},"properties":{"tags":["quality","reliability","correctness"],"description":"Hashing an object which is not hashable will result in a TypeError at runtime.","id":"py/hash-unhashable-value","kind":"problem","name":"Unhashable object hashed","precision":"very-high","problem.severity":"error","sub-severity":"low"}},{"id":"py/str-format/missing-argument","name":"py/str-format/missing-argument","shortDescription":{"text":"Too few arguments in formatting call"},"fullDescription":{"text":"A string formatting operation, such as '\"{0}: {1}, {2}\".format(a,b)', where the number of values to be formatted is too few for the format string will raise an IndexError."},"defaultConfiguration":{"enabled":true,"level":"error"},"help":{"text":"# Too few arguments in formatting call\nA formatting expression, that is an expression of the form `the_format.format(args)` or `format(the_format, args)`, must have sufficient arguments to match the format. Otherwise, an `IndexError` will be raised.\n\n\n## Recommendation\nEither change the format to match the arguments, or ensure that there are sufficient arguments.\n\n\n## Example\nIn the following example, only 2 arguments may be provided for the call to the `str.format` method, which is insufficient for the format string used. To fix this a third parameter should be provided on line 4.\n\n\n```python\ndef unsafe_format():\n    the_format = \"{} {} {}\"\n    if unlikely_condition():\n        return the_format.format(1, 2)\n    else:\n        return the_format.format(1, 2, 3)\n\n\n```\n\n## References\n* Python Library Reference: [String Formatting.](https://docs.python.org/2/library/string.html#string-formatting)\n","markdown":"# Too few arguments in formatting call\nA formatting expression, that is an expression of the form `the_format.format(args)` or `format(the_format, args)`, must have sufficient arguments to match the format. Otherwise, an `IndexError` will be raised.\n\n\n## Recommendation\nEither change the format to match the arguments, or ensure that there are sufficient arguments.\n\n\n## Example\nIn the following example, only 2 arguments may be provided for the call to the `str.format` method, which is insufficient for the format string used. To fix this a third parameter should be provided on line 4.\n\n\n```python\ndef unsafe_format():\n    the_format = \"{} {} {}\"\n    if unlikely_condition():\n        return the_format.format(1, 2)\n    else:\n        return the_format.format(1, 2, 3)\n\n\n```\n\n## References\n* Python Library Reference: [String Formatting.](https://docs.python.org/2/library/string.html#string-formatting)\n"},"properties":{"tags":["quality","reliability","correctness"],"description":"A string formatting operation, such as '\"{0}: {1}, {2}\".format(a,b)',\n              where the number of values to be formatted is too few for the format string will raise an IndexError.","id":"py/str-format/missing-argument","kind":"problem","name":"Too few arguments in formatting call","precision":"high","problem.severity":"error","sub-severity":"low"}},{"id":"py/str-format/surplus-named-argument","name":"py/str-format/surplus-named-argument","shortDescription":{"text":"Unused named argument in formatting call"},"fullDescription":{"text":"Including surplus keyword arguments in a formatting call makes code more difficult to read and may indicate an error."},"defaultConfiguration":{"enabled":true,"level":"warning"},"help":{"text":"# Unused named argument in formatting call\nA formatting expression, that is an expression of the form `the_format.format(args)` or `format(the_format, args)` can have keyword arguments of any name, as long as all the required names are provided. However, surplus keyword arguments, those with names that are not in the format, are redundant. These surplus arguments clutter the code, making it harder to read.\n\nIt is also possible that surplus keyword arguments indicate a mistake in the format string.\n\n\n## Recommendation\nCheck that the format string is correct and then remove any surplus keyword arguments.\n\n\n## Example\nIn the following example, the comment indicates that the `chips` keyword argument is no longer required and should be deleted.\n\n\n```python\ndef surplus_argument():\n    the_format = \"{spam} {eggs}\" # Used to be \"{spam} {eggs} {chips}\"\n    return the_format.format(spam = \"spam\", eggs=\"eggs\", chips=\"chips\")\n\n```\n\n## References\n* Python Library Reference: [String Formatting.](https://docs.python.org/2/library/string.html#string-formatting)\n","markdown":"# Unused named argument in formatting call\nA formatting expression, that is an expression of the form `the_format.format(args)` or `format(the_format, args)` can have keyword arguments of any name, as long as all the required names are provided. However, surplus keyword arguments, those with names that are not in the format, are redundant. These surplus arguments clutter the code, making it harder to read.\n\nIt is also possible that surplus keyword arguments indicate a mistake in the format string.\n\n\n## Recommendation\nCheck that the format string is correct and then remove any surplus keyword arguments.\n\n\n## Example\nIn the following example, the comment indicates that the `chips` keyword argument is no longer required and should be deleted.\n\n\n```python\ndef surplus_argument():\n    the_format = \"{spam} {eggs}\" # Used to be \"{spam} {eggs} {chips}\"\n    return the_format.format(spam = \"spam\", eggs=\"eggs\", chips=\"chips\")\n\n```\n\n## References\n* Python Library Reference: [String Formatting.](https://docs.python.org/2/library/string.html#string-formatting)\n"},"properties":{"tags":["quality","maintainability","useless-code"],"description":"Including surplus keyword arguments in a formatting call makes code more difficult to read and may indicate an error.","id":"py/str-format/surplus-named-argument","kind":"problem","name":"Unused named argument in formatting call","precision":"very-high","problem.severity":"warning","sub-severity":"high"}},{"id":"py/str-format/surplus-argument","name":"py/str-format/surplus-argument","shortDescription":{"text":"Unused argument in a formatting call"},"fullDescription":{"text":"Including surplus arguments in a formatting call makes code more difficult to read and may indicate an error."},"defaultConfiguration":{"enabled":true,"level":"warning"},"help":{"text":"# Unused argument in a formatting call\nA formatting expression, that is an expression of the form `the_format.format(args)` or `format(the_format, args)`, can have any number of arguments, provided that there are enough to match the format. However, surplus arguments are redundant and clutter the code, making it harder to read.\n\nIt is also possible that surplus arguments indicate a mistake in the format string.\n\n\n## Recommendation\nCheck that the format string is correct and then remove any surplus arguments.\n\n\n## Example\nIn the following example there are three arguments for the call to the `str.format()` method, but the format string only requires two. The third argument should be deleted.\n\n\n```python\ndef surplus_argument():\n    the_format = \"{} {}\" # Used to be \"{} {} {}\"\n    return the_format.format(1, 2, 3)\n\n```\n\n## References\n* Python Library Reference: [String Formatting.](https://docs.python.org/2/library/string.html#string-formatting)\n","markdown":"# Unused argument in a formatting call\nA formatting expression, that is an expression of the form `the_format.format(args)` or `format(the_format, args)`, can have any number of arguments, provided that there are enough to match the format. However, surplus arguments are redundant and clutter the code, making it harder to read.\n\nIt is also possible that surplus arguments indicate a mistake in the format string.\n\n\n## Recommendation\nCheck that the format string is correct and then remove any surplus arguments.\n\n\n## Example\nIn the following example there are three arguments for the call to the `str.format()` method, but the format string only requires two. The third argument should be deleted.\n\n\n```python\ndef surplus_argument():\n    the_format = \"{} {}\" # Used to be \"{} {} {}\"\n    return the_format.format(1, 2, 3)\n\n```\n\n## References\n* Python Library Reference: [String Formatting.](https://docs.python.org/2/library/string.html#string-formatting)\n"},"properties":{"tags":["quality","maintainability","useless-code"],"description":"Including surplus arguments in a formatting call makes code more difficult to read and may indicate an error.","id":"py/str-format/surplus-argument","kind":"problem","name":"Unused argument in a formatting call","precision":"high","problem.severity":"warning","sub-severity":"high"}},{"id":"py/str-format/mixed-fields","name":"py/str-format/mixed-fields","shortDescription":{"text":"Formatting string mixes implicitly and explicitly numbered fields"},"fullDescription":{"text":"Using implicit and explicit numbering in string formatting operations, such as '\"{}: {1}\".format(a,b)', will raise a ValueError."},"defaultConfiguration":{"enabled":true,"level":"error"},"help":{"text":"# Formatting string mixes implicitly and explicitly numbered fields\nA formatting expression, that is an expression of the form `the_format.format(args)` or `format(the_format, args)`, can use explicitly numbered fields, like `{1}`, or implicitly numbered fields, such as `{}`, but it cannot use both. Doing so will raise a `ValueError`.\n\n\n## Recommendation\nUse either explicitly numbered fields or implicitly numbered fields, but be consistent.\n\n\n## Example\nIn the following example the formatting uses both implicit, `{}`, and explicit, `{1}`, numbering for fields, which is illegal.\n\n\n```python\ndef illegal_format():\n    \"{} {1}\".format(\"spam\", \"eggs\")\n\n```\n\n## References\n* Python Library Reference: [String Formatting.](https://docs.python.org/2/library/string.html#string-formatting)\n","markdown":"# Formatting string mixes implicitly and explicitly numbered fields\nA formatting expression, that is an expression of the form `the_format.format(args)` or `format(the_format, args)`, can use explicitly numbered fields, like `{1}`, or implicitly numbered fields, such as `{}`, but it cannot use both. Doing so will raise a `ValueError`.\n\n\n## Recommendation\nUse either explicitly numbered fields or implicitly numbered fields, but be consistent.\n\n\n## Example\nIn the following example the formatting uses both implicit, `{}`, and explicit, `{1}`, numbering for fields, which is illegal.\n\n\n```python\ndef illegal_format():\n    \"{} {1}\".format(\"spam\", \"eggs\")\n\n```\n\n## References\n* Python Library Reference: [String Formatting.](https://docs.python.org/2/library/string.html#string-formatting)\n"},"properties":{"tags":["quality","reliability","correctness"],"description":"Using implicit and explicit numbering in string formatting operations, such as '\"{}: {1}\".format(a,b)', will raise a ValueError.","id":"py/str-format/mixed-fields","kind":"problem","name":"Formatting string mixes implicitly and explicitly numbered fields","precision":"high","problem.severity":"error","sub-severity":"low"}},{"id":"py/str-format/missing-named-argument","name":"py/str-format/missing-named-argument","shortDescription":{"text":"Missing named arguments in formatting call"},"fullDescription":{"text":"A string formatting operation, such as '\"{name}\".format(key=b)', where the names of format items in the format string differs from the names of the values to be formatted will raise a KeyError."},"defaultConfiguration":{"enabled":true,"level":"error"},"help":{"text":"# Missing named arguments in formatting call\nA formatting expression, that is an expression of the form `the_format.format(args)` or `format(the_format, args)`, can use named fields. If it does, then keyword arguments must be supplied for all named fields. If any of the keyword arguments are missing then a `KeyError` will be raised.\n\n\n## Recommendation\nChange the format to match the arguments and ensure that the arguments have the correct names.\n\n\n## Example\nIn the following example, if `unlikely_condition()` is true, then a `KeyError` will be raised as the keyword parameter `eggs` is missing. Adding a keyword parameter named `eggs` would fix this.\n\n\n```python\ndef unsafe_named_format():\n    the_format = \"{spam} {eggs}\"\n    if unlikely_condition():\n        return the_format.format(spam=\"spam\", completely_different=\"eggs\")\n    else:\n        return the_format.format(spam=\"spam\", eggs=\"eggs\")\n\n```\n\n## References\n* Python Library Reference: [String Formatting.](https://docs.python.org/2/library/string.html#string-formatting)\n","markdown":"# Missing named arguments in formatting call\nA formatting expression, that is an expression of the form `the_format.format(args)` or `format(the_format, args)`, can use named fields. If it does, then keyword arguments must be supplied for all named fields. If any of the keyword arguments are missing then a `KeyError` will be raised.\n\n\n## Recommendation\nChange the format to match the arguments and ensure that the arguments have the correct names.\n\n\n## Example\nIn the following example, if `unlikely_condition()` is true, then a `KeyError` will be raised as the keyword parameter `eggs` is missing. Adding a keyword parameter named `eggs` would fix this.\n\n\n```python\ndef unsafe_named_format():\n    the_format = \"{spam} {eggs}\"\n    if unlikely_condition():\n        return the_format.format(spam=\"spam\", completely_different=\"eggs\")\n    else:\n        return the_format.format(spam=\"spam\", eggs=\"eggs\")\n\n```\n\n## References\n* Python Library Reference: [String Formatting.](https://docs.python.org/2/library/string.html#string-formatting)\n"},"properties":{"tags":["quality","reliability","correctness"],"description":"A string formatting operation, such as '\"{name}\".format(key=b)',\n              where the names of format items in the format string differs from the names of the values to be formatted will raise a KeyError.","id":"py/str-format/missing-named-argument","kind":"problem","name":"Missing named arguments in formatting call","precision":"high","problem.severity":"error","sub-severity":"low"}},{"id":"py/call/wrong-arguments","name":"py/call/wrong-arguments","shortDescription":{"text":"Wrong number of arguments in a call"},"fullDescription":{"text":"Using too many or too few arguments in a call to a function will result in a TypeError at runtime."},"defaultConfiguration":{"enabled":true,"level":"error"},"help":{"text":"# Wrong number of arguments in a call\nA function call must supply an argument for each parameter that does not have a default value defined, so:\n\n* The minimum number of arguments is the number of parameters without default values.\n* The maximum number of arguments is the total number of parameters, unless the function takes a varargs (starred) parameter in which case there is no limit.\n\n## Recommendation\nIf there are too few arguments then check to see which arguments have been omitted and supply values for those.\n\nIf there are too many arguments then check to see if any have been added by mistake and remove those.\n\nAlso check where a comma has been inserted instead of an operator or a dot. For example, the code is `obj,attr` when it should be `obj.attr`.\n\nIf it is not clear which are the missing or surplus arguments, then this suggests a logical error. The fix will then depend on the nature of the error.\n\n\n## References\n* Python Glossary: [Arguments](https://docs.python.org/2/glossary.html#term-argument).\n* Python Glossary: [Parameters](https://docs.python.org/glossary.html#term-parameter).\n* Python Programming FAQ: [ What is the difference between arguments and parameters?](https://docs.python.org/2/faq/programming.html#faq-argument-vs-parameter).\n* Common Weakness Enumeration: [CWE-685](https://cwe.mitre.org/data/definitions/685.html).\n","markdown":"# Wrong number of arguments in a call\nA function call must supply an argument for each parameter that does not have a default value defined, so:\n\n* The minimum number of arguments is the number of parameters without default values.\n* The maximum number of arguments is the total number of parameters, unless the function takes a varargs (starred) parameter in which case there is no limit.\n\n## Recommendation\nIf there are too few arguments then check to see which arguments have been omitted and supply values for those.\n\nIf there are too many arguments then check to see if any have been added by mistake and remove those.\n\nAlso check where a comma has been inserted instead of an operator or a dot. For example, the code is `obj,attr` when it should be `obj.attr`.\n\nIf it is not clear which are the missing or surplus arguments, then this suggests a logical error. The fix will then depend on the nature of the error.\n\n\n## References\n* Python Glossary: [Arguments](https://docs.python.org/2/glossary.html#term-argument).\n* Python Glossary: [Parameters](https://docs.python.org/glossary.html#term-parameter).\n* Python Programming FAQ: [ What is the difference between arguments and parameters?](https://docs.python.org/2/faq/programming.html#faq-argument-vs-parameter).\n* Common Weakness Enumeration: [CWE-685](https://cwe.mitre.org/data/definitions/685.html).\n"},"properties":{"tags":["quality","reliability","correctness","external/cwe/cwe-685"],"description":"Using too many or too few arguments in a call to a function will result in a TypeError at runtime.","id":"py/call/wrong-arguments","kind":"problem","name":"Wrong number of arguments in a call","precision":"very-high","problem.severity":"error","sub-severity":"low"}},{"id":"py/member-test-non-container","name":"py/member-test-non-container","shortDescription":{"text":"Membership test with a non-container"},"fullDescription":{"text":"A membership test, such as 'item in sequence', with a non-container on the right hand side will raise a 'TypeError'."},"defaultConfiguration":{"enabled":true,"level":"error"},"help":{"text":"# Membership test with a non-container\nA membership test, that is a binary expression with `in` or `not in` as the operator, expects that the expression to the right of the operator will be a container.\n\nAs well as standard containers such as `list`, `tuple`, `dict` or `set`, a container can be an instance of any class that has the `__contains__`, `__iter__` or `__getitem__` method.\n\n\n## Recommendation\nEnsure that the right hand side of the expression is a container, or add a guard clause for other cases. For example, if the right side may be a container or `None` then change `if x in seq:` to `if seq is not None and x in seq:`\n\n\n## Example\nIn this example the `NotAContainer` class has no `__contains__`, `__iter__` or `__getitem__` method. Consequently, when the line `if 2 in cont:` is executed a TypeError will be raised. Adding a `__getitem__` method to the `NotAContainer` class would solve the problem.\n\n\n```python\nclass NotAContainer(object):\n\n    def __init__(self, *items):\n        self.items = items\n\ndef main():\n    cont = NotAContainer(1, 2, 3)\n    if 2 in cont:\n        print(\"2 in container\")\n\n```\n\n## References\n* Python: [Membership test details](http://docs.python.org/reference/expressions.html#membership-test-details).\n* Python: [The __contains__ method](http://docs.python.org/reference/datamodel.html#object.__contains__).\n","markdown":"# Membership test with a non-container\nA membership test, that is a binary expression with `in` or `not in` as the operator, expects that the expression to the right of the operator will be a container.\n\nAs well as standard containers such as `list`, `tuple`, `dict` or `set`, a container can be an instance of any class that has the `__contains__`, `__iter__` or `__getitem__` method.\n\n\n## Recommendation\nEnsure that the right hand side of the expression is a container, or add a guard clause for other cases. For example, if the right side may be a container or `None` then change `if x in seq:` to `if seq is not None and x in seq:`\n\n\n## Example\nIn this example the `NotAContainer` class has no `__contains__`, `__iter__` or `__getitem__` method. Consequently, when the line `if 2 in cont:` is executed a TypeError will be raised. Adding a `__getitem__` method to the `NotAContainer` class would solve the problem.\n\n\n```python\nclass NotAContainer(object):\n\n    def __init__(self, *items):\n        self.items = items\n\ndef main():\n    cont = NotAContainer(1, 2, 3)\n    if 2 in cont:\n        print(\"2 in container\")\n\n```\n\n## References\n* Python: [Membership test details](http://docs.python.org/reference/expressions.html#membership-test-details).\n* Python: [The __contains__ method](http://docs.python.org/reference/datamodel.html#object.__contains__).\n"},"properties":{"tags":["quality","reliability","correctness"],"description":"A membership test, such as 'item in sequence', with a non-container on the right hand side will raise a 'TypeError'.","id":"py/member-test-non-container","kind":"problem","name":"Membership test with a non-container","precision":"high","problem.severity":"error","sub-severity":"high"}},{"id":"py/percent-format/not-mapping","name":"py/percent-format/not-mapping","shortDescription":{"text":"Formatted object is not a mapping"},"fullDescription":{"text":"The formatted object must be a mapping when the format includes a named specifier; otherwise a TypeError will be raised.\""},"defaultConfiguration":{"enabled":true,"level":"error"},"help":{"text":"# Formatted object is not a mapping\nIf a format string includes conversion specifiers of the form `%(name)s` then the right hand side of the operation must be a mapping. A string is a format string if it appears on the left of a modulo (`%`) operator, the right hand side being the value to be formatted. If the right hand side is not a mapping then a `TypeError` will be raised. Mappings are usually `dict`s but can be any type that implements the mapping protocol.\n\n\n## Recommendation\nChange the format to match the arguments and ensure that the right hand side is always a mapping.\n\n\n## Example\nIn the following example the right hand side of the formatting operation can be a `tuple`, which is not a mapping. To fix this example, ensure that `args` is a mapping when `unlike_condition` occurs.\n\n\n```python\n\ndef unsafe_format():\n    if unlikely_condition():\n        args = (1,2,3)\n    else:\n        args = {a:1,b:2,c:3}\n    return \"%(a)s %(b)s %(c)s\" % args\n```\n\n## References\n* Python Library Reference: [String Formatting.](http://docs.python.org/library/stdtypes.html#string-formatting)\n","markdown":"# Formatted object is not a mapping\nIf a format string includes conversion specifiers of the form `%(name)s` then the right hand side of the operation must be a mapping. A string is a format string if it appears on the left of a modulo (`%`) operator, the right hand side being the value to be formatted. If the right hand side is not a mapping then a `TypeError` will be raised. Mappings are usually `dict`s but can be any type that implements the mapping protocol.\n\n\n## Recommendation\nChange the format to match the arguments and ensure that the right hand side is always a mapping.\n\n\n## Example\nIn the following example the right hand side of the formatting operation can be a `tuple`, which is not a mapping. To fix this example, ensure that `args` is a mapping when `unlike_condition` occurs.\n\n\n```python\n\ndef unsafe_format():\n    if unlikely_condition():\n        args = (1,2,3)\n    else:\n        args = {a:1,b:2,c:3}\n    return \"%(a)s %(b)s %(c)s\" % args\n```\n\n## References\n* Python Library Reference: [String Formatting.](http://docs.python.org/library/stdtypes.html#string-formatting)\n"},"properties":{"tags":["quality","reliability","correctness"],"description":"The formatted object must be a mapping when the format includes a named specifier; otherwise a TypeError will be raised.\"","id":"py/percent-format/not-mapping","kind":"problem","name":"Formatted object is not a mapping","precision":"high","problem.severity":"error","sub-severity":"low"}},{"id":"py/use-of-apply","name":"py/use-of-apply","shortDescription":{"text":"'apply' function used"},"fullDescription":{"text":"The builtin function 'apply' is obsolete and should not be used."},"defaultConfiguration":{"enabled":true,"level":"warning"},"help":{"text":"# 'apply' function used\nThe 'apply' function is deprecated and makes code harder to read as most Python programmers will not be familiar with it (it has been deprecated since 2003).\n\n\n## Recommendation\nReplace `apply(function, args)` with `function(*args)`.\n\nReplace `apply(function, args, keywords)` with `function(*args, **keywords)`.\n\n\n## References\n* Python Standard Library: [apply](http://docs.python.org/2/library/functions.html#apply).\n* Python PEP-290: [Code Migration and Modernization](http://www.python.org/dev/peps/pep-0290/).\n","markdown":"# 'apply' function used\nThe 'apply' function is deprecated and makes code harder to read as most Python programmers will not be familiar with it (it has been deprecated since 2003).\n\n\n## Recommendation\nReplace `apply(function, args)` with `function(*args)`.\n\nReplace `apply(function, args, keywords)` with `function(*args, **keywords)`.\n\n\n## References\n* Python Standard Library: [apply](http://docs.python.org/2/library/functions.html#apply).\n* Python PEP-290: [Code Migration and Modernization](http://www.python.org/dev/peps/pep-0290/).\n"},"properties":{"tags":["maintainability"],"description":"The builtin function 'apply' is obsolete and should not be used.","id":"py/use-of-apply","kind":"problem","name":"'apply' function used","precision":"very-high","problem.severity":"warning","sub-severity":"high"}},{"id":"py/super-not-enclosing-class","name":"py/super-not-enclosing-class","shortDescription":{"text":"First argument to super() is not enclosing class"},"fullDescription":{"text":"Calling super with something other than the enclosing class may cause incorrect object initialization."},"defaultConfiguration":{"enabled":true,"level":"error"},"help":{"text":"# First argument to super() is not enclosing class\nThe `super` class should be called with the enclosing class as its first argument and `self` as its second argument.\n\nPassing a different class may work correctly, provided the class passed is a super class of the enclosing class and the enclosing class does not define an `__init__` method. However, this may result in incorrect object initialization if the enclosing class is later subclassed using multiple inheritance.\n\n\n## Recommendation\nEnsure that the first argument to `super()` is the enclosing class.\n\n\n## Example\nIn this example, the call to `super(Vehicle, self)` in `Car.__init__` is incorrect, as it passes `Vehicle` rather than `Car` as the first argument to `super`. As a result, `super(SportsCar, self).__init__()` in the `SportsCar.__init__` method will not call all `__init__()` methods because the call to `super(Vehicle, self).__init__()` skips `StatusSymbol.__init__()`.\n\n\n```python\n\n\nclass Vehicle(object):\n    pass\n        \nclass Car(Vehicle):\n    \n    def __init__(self):\n        #This is OK provided that Car is not subclassed.\n        super(Vehicle, self).__init__()\n        self.car_init()\n        \nclass StatusSymbol(object):\n    \n    def __init__(self):\n        super(StatusSymbol, self).__init__()\n        self.show_off()\n        \nclass SportsCar(Car, StatusSymbol):\n    \n    def __init__(self):\n        #This will not call StatusSymbol.__init__()\n        super(SportsCar, self).__init__()\n        self.sports_car_init()\n\n        \n#Fix Car by passing Car to super().\n#SportsCar does not need to be changed.\nclass Car(Car, Vehicle):\n    \n    def __init__(self):\n        super(Car, self).__init__()\n        self.car_init()\n        \n\n```\n\n## References\n* Python Standard Library: [super](https://docs.python.org/3/library/functions.html#super).\n* Artima Developer: [Things to Know About Python Super](http://www.artima.com/weblogs/viewpost.jsp?thread=236275).\n* Common Weakness Enumeration: [CWE-687](https://cwe.mitre.org/data/definitions/687.html).\n","markdown":"# First argument to super() is not enclosing class\nThe `super` class should be called with the enclosing class as its first argument and `self` as its second argument.\n\nPassing a different class may work correctly, provided the class passed is a super class of the enclosing class and the enclosing class does not define an `__init__` method. However, this may result in incorrect object initialization if the enclosing class is later subclassed using multiple inheritance.\n\n\n## Recommendation\nEnsure that the first argument to `super()` is the enclosing class.\n\n\n## Example\nIn this example, the call to `super(Vehicle, self)` in `Car.__init__` is incorrect, as it passes `Vehicle` rather than `Car` as the first argument to `super`. As a result, `super(SportsCar, self).__init__()` in the `SportsCar.__init__` method will not call all `__init__()` methods because the call to `super(Vehicle, self).__init__()` skips `StatusSymbol.__init__()`.\n\n\n```python\n\n\nclass Vehicle(object):\n    pass\n        \nclass Car(Vehicle):\n    \n    def __init__(self):\n        #This is OK provided that Car is not subclassed.\n        super(Vehicle, self).__init__()\n        self.car_init()\n        \nclass StatusSymbol(object):\n    \n    def __init__(self):\n        super(StatusSymbol, self).__init__()\n        self.show_off()\n        \nclass SportsCar(Car, StatusSymbol):\n    \n    def __init__(self):\n        #This will not call StatusSymbol.__init__()\n        super(SportsCar, self).__init__()\n        self.sports_car_init()\n\n        \n#Fix Car by passing Car to super().\n#SportsCar does not need to be changed.\nclass Car(Car, Vehicle):\n    \n    def __init__(self):\n        super(Car, self).__init__()\n        self.car_init()\n        \n\n```\n\n## References\n* Python Standard Library: [super](https://docs.python.org/3/library/functions.html#super).\n* Artima Developer: [Things to Know About Python Super](http://www.artima.com/weblogs/viewpost.jsp?thread=236275).\n* Common Weakness Enumeration: [CWE-687](https://cwe.mitre.org/data/definitions/687.html).\n"},"properties":{"tags":["quality","reliability","correctness","external/cwe/cwe-687"],"description":"Calling super with something other than the enclosing class may cause incorrect object initialization.","id":"py/super-not-enclosing-class","kind":"problem","name":"First argument to super() is not enclosing class","precision":"high","problem.severity":"error","sub-severity":"low"}},{"id":"py/call-to-non-callable","name":"py/call-to-non-callable","shortDescription":{"text":"Non-callable called"},"fullDescription":{"text":"A call to an object which is not a callable will raise a TypeError at runtime."},"defaultConfiguration":{"enabled":true,"level":"error"},"help":{"text":"# Non-callable called\nIf an object is called, `obj()`, then that object must be a callable or a `TypeError` will be raised. A callable object is any object whose class defines the `__call__` special method. Callable objects include functions, methods, classes.\n\nThe `callable(object)` builtin function determines if an object is callable or not.\n\nWhen the Python interpreter attempts to evaluate a call such as `func(arg)` it will invoke the `__call__` special method on `func`. Thus, `func(arg)` is roughly equivalent to `type(func).__call__(func, arg)` which means that the *class* must define the attribute `__call__`, merely adding it to the instance is not sufficient.\n\n\n## Recommendation\nSince this problem usually indicates a logical error, it is not possible to give a general recipe for fixing it.\n\n\n## Example\n`list`s are not callable. In this example, an attempt is made to call a `list` which will fail with a `TypeError`.\n\n\n```python\na_list = []\na_list()\n\n```\n\n## References\n* Python Standard Library: [callable](http://docs.python.org/2/library/functions.html#callable).\n* Python Language Reference: [object.__call__](http://docs.python.org/2/reference/datamodel.html#object.__call__).\n","markdown":"# Non-callable called\nIf an object is called, `obj()`, then that object must be a callable or a `TypeError` will be raised. A callable object is any object whose class defines the `__call__` special method. Callable objects include functions, methods, classes.\n\nThe `callable(object)` builtin function determines if an object is callable or not.\n\nWhen the Python interpreter attempts to evaluate a call such as `func(arg)` it will invoke the `__call__` special method on `func`. Thus, `func(arg)` is roughly equivalent to `type(func).__call__(func, arg)` which means that the *class* must define the attribute `__call__`, merely adding it to the instance is not sufficient.\n\n\n## Recommendation\nSince this problem usually indicates a logical error, it is not possible to give a general recipe for fixing it.\n\n\n## Example\n`list`s are not callable. In this example, an attempt is made to call a `list` which will fail with a `TypeError`.\n\n\n```python\na_list = []\na_list()\n\n```\n\n## References\n* Python Standard Library: [callable](http://docs.python.org/2/library/functions.html#callable).\n* Python Language Reference: [object.__call__](http://docs.python.org/2/reference/datamodel.html#object.__call__).\n"},"properties":{"tags":["quality","reliability","correctness"],"description":"A call to an object which is not a callable will raise a TypeError at runtime.","id":"py/call-to-non-callable","kind":"problem","name":"Non-callable called","precision":"high","problem.severity":"error","sub-severity":"high"}},{"id":"py/test-equals-none","name":"py/test-equals-none","shortDescription":{"text":"Testing equality to None"},"fullDescription":{"text":"Testing whether an object is 'None' using the == operator is inefficient and potentially incorrect."},"defaultConfiguration":{"enabled":true,"level":"note"},"help":{"text":"# Testing equality to None\nWhen you compare an object to `None`, use `is` rather than `==`. `None` is a singleton object, comparing using `==` invokes the `__eq__` method on the object in question, which may be slower than identity comparison. Comparing to `None` using the `is` operator is also easier for other programmers to read.\n\n\n## Recommendation\nReplace `==` with `is`.\n\n\n## Example\nThe `filter2` function is likely to be more efficient than the `filter1` function because it uses an identity comparison.\n\n\n```python\n\ndef filter1(function, iterable=None)\n    if iterable == None:    # Comparison using '__eq__'\n        return [item for item in iterable if item]\n    else:\n        return [item for item in iterable if function(item)]\n\ndef filter2(function, iterable=None)\n    if iterable is None:    # Comparison using identity\n        return [item for item in iterable if item]\n    else:\n        return [item for item in iterable if function(item)]\n\n```\n\n## References\n* Python Language Reference: [Comparisons](http://docs.python.org/reference/expressions.html#is), [object.__eq__](http://docs.python.org/reference/datamodel.html#object.__eq__).\n","markdown":"# Testing equality to None\nWhen you compare an object to `None`, use `is` rather than `==`. `None` is a singleton object, comparing using `==` invokes the `__eq__` method on the object in question, which may be slower than identity comparison. Comparing to `None` using the `is` operator is also easier for other programmers to read.\n\n\n## Recommendation\nReplace `==` with `is`.\n\n\n## Example\nThe `filter2` function is likely to be more efficient than the `filter1` function because it uses an identity comparison.\n\n\n```python\n\ndef filter1(function, iterable=None)\n    if iterable == None:    # Comparison using '__eq__'\n        return [item for item in iterable if item]\n    else:\n        return [item for item in iterable if function(item)]\n\ndef filter2(function, iterable=None)\n    if iterable is None:    # Comparison using identity\n        return [item for item in iterable if item]\n    else:\n        return [item for item in iterable if function(item)]\n\n```\n\n## References\n* Python Language Reference: [Comparisons](http://docs.python.org/reference/expressions.html#is), [object.__eq__](http://docs.python.org/reference/datamodel.html#object.__eq__).\n"},"properties":{"tags":["quality","reliability","correctness","performance"],"description":"Testing whether an object is 'None' using the == operator is inefficient and potentially incorrect.","id":"py/test-equals-none","kind":"problem","name":"Testing equality to None","precision":"very-high","problem.severity":"recommendation","sub-severity":"high"}},{"id":"py/truncated-division","name":"py/truncated-division","shortDescription":{"text":"Result of integer division may be truncated"},"fullDescription":{"text":"The arguments to a division statement may be integers, which may cause the result to be truncated in Python 2."},"defaultConfiguration":{"enabled":true,"level":"warning"},"help":{"text":"# Result of integer division may be truncated\nIn Python 2, the result of dividing two integers is silently truncated into an integer. This may lead to unexpected behavior.\n\n\n## Recommendation\nIf the division should never be truncated, add `from __future__ import division` to the beginning of the file. If the division should always be truncated, replace the division operator `/` with the truncated division operator `//`.\n\n\n## Example\nThe first example shows a function for calculating the average of a sequence of numbers. When the function runs under Python 2, and the sequence contains only integers, an incorrect result may be returned because the result is truncated. The second example corrects this error by following the recommendation listed above.\n\n\n```python\n# Incorrect:\n\ndef average(l):\n    return sum(l) / len(l)\n\nprint average([1.0, 2.0])  # Prints \"1.5\".\nprint average([1, 2])      # Prints \"1\", which is incorrect.\n\n```\n\n```python\n# Correct:\nfrom __future__ import division\n\ndef average(l):\n    return sum(l) / len(l)\n\nprint average([1.0, 2.0])  # Prints \"1.5\".\nprint average([1, 2])      # Prints \"1.5\".\n\n```\n\n## References\n* Python Language Reference: [Binary arithmetic operations](https://docs.python.org/2/reference/expressions.html#binary-arithmetic-operations).\n* PEP 238: [Changing the Division Operator](https://www.python.org/dev/peps/pep-0238/).\n* PEP 236: [Back to the __future__](https://www.python.org/dev/peps/pep-0236/).\n","markdown":"# Result of integer division may be truncated\nIn Python 2, the result of dividing two integers is silently truncated into an integer. This may lead to unexpected behavior.\n\n\n## Recommendation\nIf the division should never be truncated, add `from __future__ import division` to the beginning of the file. If the division should always be truncated, replace the division operator `/` with the truncated division operator `//`.\n\n\n## Example\nThe first example shows a function for calculating the average of a sequence of numbers. When the function runs under Python 2, and the sequence contains only integers, an incorrect result may be returned because the result is truncated. The second example corrects this error by following the recommendation listed above.\n\n\n```python\n# Incorrect:\n\ndef average(l):\n    return sum(l) / len(l)\n\nprint average([1.0, 2.0])  # Prints \"1.5\".\nprint average([1, 2])      # Prints \"1\", which is incorrect.\n\n```\n\n```python\n# Correct:\nfrom __future__ import division\n\ndef average(l):\n    return sum(l) / len(l)\n\nprint average([1.0, 2.0])  # Prints \"1.5\".\nprint average([1, 2])      # Prints \"1.5\".\n\n```\n\n## References\n* Python Language Reference: [Binary arithmetic operations](https://docs.python.org/2/reference/expressions.html#binary-arithmetic-operations).\n* PEP 238: [Changing the Division Operator](https://www.python.org/dev/peps/pep-0238/).\n* PEP 236: [Back to the __future__](https://www.python.org/dev/peps/pep-0236/).\n"},"properties":{"tags":["maintainability","correctness"],"description":"The arguments to a division statement may be integers, which\n              may cause the result to be truncated in Python 2.","id":"py/truncated-division","kind":"problem","name":"Result of integer division may be truncated","precision":"very-high","problem.severity":"warning","sub-severity":"high"}},{"id":"py/percent-format/wrong-arguments","name":"py/percent-format/wrong-arguments","shortDescription":{"text":"Wrong number of arguments for format"},"fullDescription":{"text":"A string formatting operation, such as '\"%s: %s, %s\" % (a,b)', where the number of conversion specifiers in the format string differs from the number of values to be formatted will raise a TypeError."},"defaultConfiguration":{"enabled":true,"level":"error"},"help":{"text":"# Wrong number of arguments for format\nA formatting expression, that is an expression of the format `fmt % arguments` must have the correct number of arguments on the right hand side of the expression. Otherwise, a `TypeError` will be raised.\n\n\n## Recommendation\nChange the format to match the arguments and ensure that the right hand argument always has the correct number of elements.\n\n\n## Example\nIn the following example the right hand side of the formatting operation can be of length 2, which does not match the format string.\n\n\n```python\ndef unsafe_format():\n    if unlikely_condition():\n        args = (1,2)\n    else:\n        args = (1, 2, 3)\n    return \"%s %s %s\" % args\n\n```\n\n## References\n* Python Library Reference: [String Formatting.](http://docs.python.org/library/stdtypes.html#string-formatting)\n* Common Weakness Enumeration: [CWE-685](https://cwe.mitre.org/data/definitions/685.html).\n","markdown":"# Wrong number of arguments for format\nA formatting expression, that is an expression of the format `fmt % arguments` must have the correct number of arguments on the right hand side of the expression. Otherwise, a `TypeError` will be raised.\n\n\n## Recommendation\nChange the format to match the arguments and ensure that the right hand argument always has the correct number of elements.\n\n\n## Example\nIn the following example the right hand side of the formatting operation can be of length 2, which does not match the format string.\n\n\n```python\ndef unsafe_format():\n    if unlikely_condition():\n        args = (1,2)\n    else:\n        args = (1, 2, 3)\n    return \"%s %s %s\" % args\n\n```\n\n## References\n* Python Library Reference: [String Formatting.](http://docs.python.org/library/stdtypes.html#string-formatting)\n* Common Weakness Enumeration: [CWE-685](https://cwe.mitre.org/data/definitions/685.html).\n"},"properties":{"tags":["quality","reliability","correctness","external/cwe/cwe-685"],"description":"A string formatting operation, such as '\"%s: %s, %s\" % (a,b)', where the number of conversion specifiers in the\n              format string differs from the number of values to be formatted will raise a TypeError.","id":"py/percent-format/wrong-arguments","kind":"problem","name":"Wrong number of arguments for format","precision":"very-high","problem.severity":"error","sub-severity":"low"}},{"id":"py/call/wrong-named-argument","name":"py/call/wrong-named-argument","shortDescription":{"text":"Wrong name for an argument in a call"},"fullDescription":{"text":"Using a named argument whose name does not correspond to a parameter of the called function or method, will result in a TypeError at runtime."},"defaultConfiguration":{"enabled":true,"level":"error"},"help":{"text":"# Wrong name for an argument in a call\nUsing a named argument whose name does not correspond to a parameter of the called function (or method), will result in a `TypeError` at runtime.\n\n\n## Recommendation\nCheck for typos in the name of the arguments and fix those. If the name is clearly different, then this suggests a logical error. The change required to correct the error will depend on whether the wrong argument has been specified or whether the wrong function (or method) has been specified.\n\n\n## References\n* Python Glossary: [Arguments](https://docs.python.org/2/glossary.html#term-argument).\n* Python Glossary: [Parameters](https://docs.python.org/glossary.html#term-parameter).\n* Python Programming FAQ: [ What is the difference between arguments and parameters?](https://docs.python.org/2/faq/programming.html#faq-argument-vs-parameter).\n* Common Weakness Enumeration: [CWE-628](https://cwe.mitre.org/data/definitions/628.html).\n","markdown":"# Wrong name for an argument in a call\nUsing a named argument whose name does not correspond to a parameter of the called function (or method), will result in a `TypeError` at runtime.\n\n\n## Recommendation\nCheck for typos in the name of the arguments and fix those. If the name is clearly different, then this suggests a logical error. The change required to correct the error will depend on whether the wrong argument has been specified or whether the wrong function (or method) has been specified.\n\n\n## References\n* Python Glossary: [Arguments](https://docs.python.org/2/glossary.html#term-argument).\n* Python Glossary: [Parameters](https://docs.python.org/glossary.html#term-parameter).\n* Python Programming FAQ: [ What is the difference between arguments and parameters?](https://docs.python.org/2/faq/programming.html#faq-argument-vs-parameter).\n* Common Weakness Enumeration: [CWE-628](https://cwe.mitre.org/data/definitions/628.html).\n"},"properties":{"tags":["quality","reliability","correctness","external/cwe/cwe-628"],"description":"Using a named argument whose name does not correspond to a\n              parameter of the called function or method, will result in a\n              TypeError at runtime.","id":"py/call/wrong-named-argument","kind":"problem","name":"Wrong name for an argument in a call","precision":"very-high","problem.severity":"error","sub-severity":"low"}},{"id":"py/redundant-comparison","name":"py/redundant-comparison","shortDescription":{"text":"Redundant comparison"},"fullDescription":{"text":"The result of a comparison is implied by a previous comparison."},"defaultConfiguration":{"enabled":true,"level":"warning"},"help":{"text":"# Redundant comparison\nThe result of certain comparisons can sometimes be inferred from their context and the results of other comparisons. This can be an indication of faulty logic and may result in dead code or infinite loops if, for example, a loop condition never changes its value.\n\n\n## Recommendation\nInspect the code to check whether the logic is correct, and consider simplifying the logical expression.\n\n\n## Example\nIn the following (real world) example the test `obj1 < obj2` is repeated and thus the second test will always be false, and the function `_compare` will only ever return `0` or `-1`.\n\n\n```python\n  class KeySorter:\n\n      def __init__(self, obj):\n          self.obj = obj\n\n      def __lt__(self, other):\n          return self._compare(self.obj, other.obj) < 0\n\n      def _compare(self, obj1, obj2):\n          if obj1 < obj2:\n              return -1\n          elif obj1 < obj2:\n              return 1\n          else:\n              return 0\n\n```\n\n## References\n* Python Language Reference: [Comparisons](http://docs.python.org/2/reference/expressions.html#not-in).\n* Common Weakness Enumeration: [CWE-561](https://cwe.mitre.org/data/definitions/561.html).\n* Common Weakness Enumeration: [CWE-570](https://cwe.mitre.org/data/definitions/570.html).\n* Common Weakness Enumeration: [CWE-571](https://cwe.mitre.org/data/definitions/571.html).\n","markdown":"# Redundant comparison\nThe result of certain comparisons can sometimes be inferred from their context and the results of other comparisons. This can be an indication of faulty logic and may result in dead code or infinite loops if, for example, a loop condition never changes its value.\n\n\n## Recommendation\nInspect the code to check whether the logic is correct, and consider simplifying the logical expression.\n\n\n## Example\nIn the following (real world) example the test `obj1 < obj2` is repeated and thus the second test will always be false, and the function `_compare` will only ever return `0` or `-1`.\n\n\n```python\n  class KeySorter:\n\n      def __init__(self, obj):\n          self.obj = obj\n\n      def __lt__(self, other):\n          return self._compare(self.obj, other.obj) < 0\n\n      def _compare(self, obj1, obj2):\n          if obj1 < obj2:\n              return -1\n          elif obj1 < obj2:\n              return 1\n          else:\n              return 0\n\n```\n\n## References\n* Python Language Reference: [Comparisons](http://docs.python.org/2/reference/expressions.html#not-in).\n* Common Weakness Enumeration: [CWE-561](https://cwe.mitre.org/data/definitions/561.html).\n* Common Weakness Enumeration: [CWE-570](https://cwe.mitre.org/data/definitions/570.html).\n* Common Weakness Enumeration: [CWE-571](https://cwe.mitre.org/data/definitions/571.html).\n"},"properties":{"tags":["quality","maintainability","useless-code","external/cwe/cwe-561","external/cwe/cwe-570","external/cwe/cwe-571"],"description":"The result of a comparison is implied by a previous comparison.","id":"py/redundant-comparison","kind":"problem","name":"Redundant comparison","precision":"high","problem.severity":"warning","sub-severity":"high"}},{"id":"py/comparison-missing-self","name":"py/comparison-missing-self","shortDescription":{"text":"Maybe missing 'self' in comparison"},"fullDescription":{"text":"Comparison of identical values, the intent of which is unclear."},"defaultConfiguration":{"enabled":true,"level":"warning"},"help":{"text":"# Maybe missing 'self' in comparison\nWhen two identical expressions are compared it is typically an indication of a mistake, since the Boolean value of the comparison will always be the same. Often, it can indicate that `self` has been omitted.\n\n\n## Recommendation\nIt is never good practice to compare a value with itself. If `self` has been omitted, then insert it. If the constant behavior is indeed required, use the Boolean literals `True` or `False`, rather than encoding them obscurely as `x == x` or similar.\n\n\n## Example\n\n```python\n\nclass Customer:\n\n    def __init__(self, data):\n        self.data = data\n\n    def check_data(self, data):\n        if data != data:  # Forgotten 'self'\n            raise Exception(\"Invalid data!\")\n\n#Fixed version\n\nclass Customer:\n\n    def __init__(self, data):\n        self.data = data\n\n    def check_data(self, data):\n        if self.data != data:\n            raise Exception(\"Invalid data!\")\n\n```\n\n## References\n* Python Language Reference: [Comparisons](http://docs.python.org/2/reference/expressions.html#not-in).\n* Common Weakness Enumeration: [CWE-570](https://cwe.mitre.org/data/definitions/570.html).\n* Common Weakness Enumeration: [CWE-571](https://cwe.mitre.org/data/definitions/571.html).\n","markdown":"# Maybe missing 'self' in comparison\nWhen two identical expressions are compared it is typically an indication of a mistake, since the Boolean value of the comparison will always be the same. Often, it can indicate that `self` has been omitted.\n\n\n## Recommendation\nIt is never good practice to compare a value with itself. If `self` has been omitted, then insert it. If the constant behavior is indeed required, use the Boolean literals `True` or `False`, rather than encoding them obscurely as `x == x` or similar.\n\n\n## Example\n\n```python\n\nclass Customer:\n\n    def __init__(self, data):\n        self.data = data\n\n    def check_data(self, data):\n        if data != data:  # Forgotten 'self'\n            raise Exception(\"Invalid data!\")\n\n#Fixed version\n\nclass Customer:\n\n    def __init__(self, data):\n        self.data = data\n\n    def check_data(self, data):\n        if self.data != data:\n            raise Exception(\"Invalid data!\")\n\n```\n\n## References\n* Python Language Reference: [Comparisons](http://docs.python.org/2/reference/expressions.html#not-in).\n* Common Weakness Enumeration: [CWE-570](https://cwe.mitre.org/data/definitions/570.html).\n* Common Weakness Enumeration: [CWE-571](https://cwe.mitre.org/data/definitions/571.html).\n"},"properties":{"tags":["quality","reliability","correctness","external/cwe/cwe-570","external/cwe/cwe-571"],"description":"Comparison of identical values, the intent of which is unclear.","id":"py/comparison-missing-self","kind":"problem","name":"Maybe missing 'self' in comparison","precision":"very-high","problem.severity":"warning","sub-severity":"high"}},{"id":"py/comparison-of-constants","name":"py/comparison-of-constants","shortDescription":{"text":"Comparison of constants"},"fullDescription":{"text":"Comparison of constants is always constant, but is harder to read than a simple constant."},"defaultConfiguration":{"enabled":true,"level":"warning"},"help":{"text":"# Comparison of constants\nWhen two constants are compared it is typically an indication of a mistake, since the Boolean value of the comparison will always be the same. In very old code this may be used to initialize `True` and `False`.\n\n\n## Recommendation\nIt is never good practice to compare a value with itself. If the constant behavior is indeed required, use the Boolean literals `True` or `False`, rather than encoding them obscurely as `1 == 1` or similar. If there is a mistake, ascertain the desired behavior and correct it.\n\n\n## Example\nIn this example, old code uses `1==1` to initialize `__builtins__.True`. This code has been unnecessary on all versions of Python released since 2003 and can be deleted.\n\n\n```python\n\n#Interoperate with very old versions of Python (pre 2.3)\ntry:\n    True\nexcept NameError:\n    __builtins__.True = 1==1\n\n```\n\n## References\n* Python Language Reference: [Comparisons](http://docs.python.org/2/reference/expressions.html#not-in).\n* Common Weakness Enumeration: [CWE-570](https://cwe.mitre.org/data/definitions/570.html).\n* Common Weakness Enumeration: [CWE-571](https://cwe.mitre.org/data/definitions/571.html).\n","markdown":"# Comparison of constants\nWhen two constants are compared it is typically an indication of a mistake, since the Boolean value of the comparison will always be the same. In very old code this may be used to initialize `True` and `False`.\n\n\n## Recommendation\nIt is never good practice to compare a value with itself. If the constant behavior is indeed required, use the Boolean literals `True` or `False`, rather than encoding them obscurely as `1 == 1` or similar. If there is a mistake, ascertain the desired behavior and correct it.\n\n\n## Example\nIn this example, old code uses `1==1` to initialize `__builtins__.True`. This code has been unnecessary on all versions of Python released since 2003 and can be deleted.\n\n\n```python\n\n#Interoperate with very old versions of Python (pre 2.3)\ntry:\n    True\nexcept NameError:\n    __builtins__.True = 1==1\n\n```\n\n## References\n* Python Language Reference: [Comparisons](http://docs.python.org/2/reference/expressions.html#not-in).\n* Common Weakness Enumeration: [CWE-570](https://cwe.mitre.org/data/definitions/570.html).\n* Common Weakness Enumeration: [CWE-571](https://cwe.mitre.org/data/definitions/571.html).\n"},"properties":{"tags":["quality","maintainability","useless-code","external/cwe/cwe-570","external/cwe/cwe-571"],"description":"Comparison of constants is always constant, but is harder to read than a simple constant.","id":"py/comparison-of-constants","kind":"problem","name":"Comparison of constants","precision":"very-high","problem.severity":"warning","sub-severity":"low"}},{"id":"py/comparison-of-identical-expressions","name":"py/comparison-of-identical-expressions","shortDescription":{"text":"Comparison of identical values"},"fullDescription":{"text":"Comparison of identical values, the intent of which is unclear."},"defaultConfiguration":{"enabled":true,"level":"warning"},"help":{"text":"# Comparison of identical values\nWhen two identical expressions are compared it is typically an indication of a mistake, since the Boolean value of the comparison will always be the same, unless the value is the floating point value `float('nan')`.\n\n\n## Recommendation\nIt is not good practice to compare a value with itself, as it makes the code hard to read and can hide errors with classes that do not correctly implement equality. If testing whether a floating-point value is not-a-number, then use `math.isnan()`. If the value may be a complex number, then use `cmath.isnan()` instead.\n\n\n## Example\nIn this example `f == f` is used to check for `float('nan')`. This makes the code difficult to understand as the reader may not be immediately familiar with this pattern.\n\n\n```python\n\n#Using 'x == x' to check that 'x' is not a float('nan').\ndef is_normal(f):\n    return not cmath.isinf(f) and f == f\n\n#Improved version; intention is explicit.\ndef is_normal(f):\n    return not cmath.isinf(f) and not cmath.isnan(f)\n```\n\n## References\n* Python Language Reference: [Comparisons](http://docs.python.org/2/reference/expressions.html#not-in).\n* Python Library Reference: [math.isnan()](https://docs.python.org/2/library/math.html#math.isnan).\n* Python Library Reference: [cmath.isnan()](https://docs.python.org/2/library/cmath.html#cmath.isnan).\n* Common Weakness Enumeration: [CWE-570](https://cwe.mitre.org/data/definitions/570.html).\n* Common Weakness Enumeration: [CWE-571](https://cwe.mitre.org/data/definitions/571.html).\n","markdown":"# Comparison of identical values\nWhen two identical expressions are compared it is typically an indication of a mistake, since the Boolean value of the comparison will always be the same, unless the value is the floating point value `float('nan')`.\n\n\n## Recommendation\nIt is not good practice to compare a value with itself, as it makes the code hard to read and can hide errors with classes that do not correctly implement equality. If testing whether a floating-point value is not-a-number, then use `math.isnan()`. If the value may be a complex number, then use `cmath.isnan()` instead.\n\n\n## Example\nIn this example `f == f` is used to check for `float('nan')`. This makes the code difficult to understand as the reader may not be immediately familiar with this pattern.\n\n\n```python\n\n#Using 'x == x' to check that 'x' is not a float('nan').\ndef is_normal(f):\n    return not cmath.isinf(f) and f == f\n\n#Improved version; intention is explicit.\ndef is_normal(f):\n    return not cmath.isinf(f) and not cmath.isnan(f)\n```\n\n## References\n* Python Language Reference: [Comparisons](http://docs.python.org/2/reference/expressions.html#not-in).\n* Python Library Reference: [math.isnan()](https://docs.python.org/2/library/math.html#math.isnan).\n* Python Library Reference: [cmath.isnan()](https://docs.python.org/2/library/cmath.html#cmath.isnan).\n* Common Weakness Enumeration: [CWE-570](https://cwe.mitre.org/data/definitions/570.html).\n* Common Weakness Enumeration: [CWE-571](https://cwe.mitre.org/data/definitions/571.html).\n"},"properties":{"tags":["quality","maintainability","readability","external/cwe/cwe-570","external/cwe/cwe-571"],"description":"Comparison of identical values, the intent of which is unclear.","id":"py/comparison-of-identical-expressions","kind":"problem","name":"Comparison of identical values","precision":"very-high","problem.severity":"warning","sub-severity":"high"}},{"id":"py/regex/unmatchable-dollar","name":"py/regex/unmatchable-dollar","shortDescription":{"text":"Unmatchable dollar in regular expression"},"fullDescription":{"text":"Regular expressions containing a dollar '$' in the middle cannot be matched, whatever the input."},"defaultConfiguration":{"enabled":true,"level":"error"},"help":{"text":"# Unmatchable dollar in regular expression\nA dollar assertion `$` in a regular expression only matches at the end of the input, or (for multi-line regular expressions) at the end of a line. If it is followed by a pattern that must match a non-empty sequence of (non-newline) input characters, it cannot possibly match, rendering the entire regular expression unmatchable.\n\n\n## Recommendation\nExamine the regular expression to find and correct any typos.\n\n\n## Example\nIn the following example, the regular expression `r\"\\.\\(\\w+$\\)\"` cannot match any string, since it contains a dollar assertion followed by an escape sequence that matches a closing parenthesis.\n\nThe second regular expression, `r\"\\.\\(\\w+\\)$\"`, has the dollar at the end and will work as expected.\n\n\n```python\nimport re\n#Regular expression that includes a dollar, but not at the end.\nmatcher = re.compile(r\"\\.\\(\\w+$\\)\")\n\ndef find_it(filename):\n    if matcher.match(filename):\n        print(\"Found it!\")\n\n#Regular expression anchored to end of input.\nfixed_matcher = re.compile(r\"\\.\\(\\w+\\)$\")\n```\n\n## References\n* Python Standard Library: [Regular expression operations](https://docs.python.org/library/re.html).\n* Regular-Expressions.info: [Start of String and End of String Anchors](http://www.regular-expressions.info/anchors.html).\n","markdown":"# Unmatchable dollar in regular expression\nA dollar assertion `$` in a regular expression only matches at the end of the input, or (for multi-line regular expressions) at the end of a line. If it is followed by a pattern that must match a non-empty sequence of (non-newline) input characters, it cannot possibly match, rendering the entire regular expression unmatchable.\n\n\n## Recommendation\nExamine the regular expression to find and correct any typos.\n\n\n## Example\nIn the following example, the regular expression `r\"\\.\\(\\w+$\\)\"` cannot match any string, since it contains a dollar assertion followed by an escape sequence that matches a closing parenthesis.\n\nThe second regular expression, `r\"\\.\\(\\w+\\)$\"`, has the dollar at the end and will work as expected.\n\n\n```python\nimport re\n#Regular expression that includes a dollar, but not at the end.\nmatcher = re.compile(r\"\\.\\(\\w+$\\)\")\n\ndef find_it(filename):\n    if matcher.match(filename):\n        print(\"Found it!\")\n\n#Regular expression anchored to end of input.\nfixed_matcher = re.compile(r\"\\.\\(\\w+\\)$\")\n```\n\n## References\n* Python Standard Library: [Regular expression operations](https://docs.python.org/library/re.html).\n* Regular-Expressions.info: [Start of String and End of String Anchors](http://www.regular-expressions.info/anchors.html).\n"},"properties":{"tags":["quality","reliability","correctness"],"description":"Regular expressions containing a dollar '$' in the middle cannot be matched, whatever the input.","id":"py/regex/unmatchable-dollar","kind":"problem","name":"Unmatchable dollar in regular expression","precision":"high","problem.severity":"error","sub-severity":"low"}},{"id":"py/regex/incomplete-special-group","name":"py/regex/incomplete-special-group","shortDescription":{"text":"Missing part of special group in regular expression"},"fullDescription":{"text":"Incomplete special groups are parsed as normal groups and are unlikely to match the intended strings."},"defaultConfiguration":{"enabled":true,"level":"warning"},"help":{"text":"# Missing part of special group in regular expression\nOne of the problems with using regular expressions is that almost any sequence of characters is a valid pattern. This means that it is easy to omit a necessary character and still have a valid regular expression. Omitting a character in a named capturing group is a specific case which can dramatically change the meaning of a regular expression.\n\n\n## Recommendation\nExamine the regular expression to find and correct any typos.\n\n\n## Example\nIn the following example, the regular expression for `matcher`, `r\"(P<name>[\\w]+)\"`, is missing a \"?\" and will match only strings of letters that start with \"P&lt;name&gt;\", instead of matching any sequence of letters and placing the result in a named group. The fixed version, `fixed_matcher`, includes the \"?\" and will work as expected.\n\n\n```python\nimport re\nmatcher = re.compile(r'(P<name>[\\w]+)')\n\ndef only_letters(text):\n    m = matcher.match(text)\n    if m:\n        print(\"Letters are: \" + m.group('name'))\n\n#Fix the pattern by adding the missing '?'\nfixed_matcher = re.compile(r'(?P<name>[\\w]+)')\n```\n\n## References\n* Python Standard Library: [Regular expression operations](https://docs.python.org/library/re.html).\n* Regular-Expressions.info: [Named Capturing Groups](http://www.regular-expressions.info/named.html).\n","markdown":"# Missing part of special group in regular expression\nOne of the problems with using regular expressions is that almost any sequence of characters is a valid pattern. This means that it is easy to omit a necessary character and still have a valid regular expression. Omitting a character in a named capturing group is a specific case which can dramatically change the meaning of a regular expression.\n\n\n## Recommendation\nExamine the regular expression to find and correct any typos.\n\n\n## Example\nIn the following example, the regular expression for `matcher`, `r\"(P<name>[\\w]+)\"`, is missing a \"?\" and will match only strings of letters that start with \"P&lt;name&gt;\", instead of matching any sequence of letters and placing the result in a named group. The fixed version, `fixed_matcher`, includes the \"?\" and will work as expected.\n\n\n```python\nimport re\nmatcher = re.compile(r'(P<name>[\\w]+)')\n\ndef only_letters(text):\n    m = matcher.match(text)\n    if m:\n        print(\"Letters are: \" + m.group('name'))\n\n#Fix the pattern by adding the missing '?'\nfixed_matcher = re.compile(r'(?P<name>[\\w]+)')\n```\n\n## References\n* Python Standard Library: [Regular expression operations](https://docs.python.org/library/re.html).\n* Regular-Expressions.info: [Named Capturing Groups](http://www.regular-expressions.info/named.html).\n"},"properties":{"tags":["quality","reliability","correctness"],"description":"Incomplete special groups are parsed as normal groups and are unlikely to match the intended strings.","id":"py/regex/incomplete-special-group","kind":"problem","name":"Missing part of special group in regular expression","precision":"high","problem.severity":"warning","sub-severity":"high"}},{"id":"py/regex/backspace-escape","name":"py/regex/backspace-escape","shortDescription":{"text":"Backspace escape in regular expression"},"fullDescription":{"text":"Using '\\b' to escape the backspace character in a regular expression is confusing since it could be mistaken for a word boundary assertion."},"defaultConfiguration":{"enabled":true,"level":"note"},"help":{"text":"# Backspace escape in regular expression\nThe meaning of the `\\b` escape sequence inside a regular expression depends on its syntactic context: inside a character class, it matches the backspace character; outside of a character class, it matches a word boundary. This context dependency makes regular expressions hard to read, so the `\\b` escape sequence should not be used inside character classes.\n\n\n## Recommendation\nReplace `\\b` in character classes with the semantically identical escape sequence `\\x08`.\n\n\n## Example\nIn the following example, the regular expression contains two uses of `\\b`: in the first case, it matches a word boundary, in the second case it matches a backspace character.\n\n\n```python\nimport re\nmatcher = re.compile(r\"\\b[\\t\\b]\")\n\ndef match_data(data):\n    return bool(matcher.match(data))\n\n```\nYou can make the regular expression easier for other developers to interpret, by rewriting it as `r\"\\b[\\t\\x08]\"`.\n\n\n## References\n* Python Standard Library: [Regular expression operations](https://docs.python.org/library/re.html).\n","markdown":"# Backspace escape in regular expression\nThe meaning of the `\\b` escape sequence inside a regular expression depends on its syntactic context: inside a character class, it matches the backspace character; outside of a character class, it matches a word boundary. This context dependency makes regular expressions hard to read, so the `\\b` escape sequence should not be used inside character classes.\n\n\n## Recommendation\nReplace `\\b` in character classes with the semantically identical escape sequence `\\x08`.\n\n\n## Example\nIn the following example, the regular expression contains two uses of `\\b`: in the first case, it matches a word boundary, in the second case it matches a backspace character.\n\n\n```python\nimport re\nmatcher = re.compile(r\"\\b[\\t\\b]\")\n\ndef match_data(data):\n    return bool(matcher.match(data))\n\n```\nYou can make the regular expression easier for other developers to interpret, by rewriting it as `r\"\\b[\\t\\x08]\"`.\n\n\n## References\n* Python Standard Library: [Regular expression operations](https://docs.python.org/library/re.html).\n"},"properties":{"tags":["quality","maintainability","readability"],"description":"Using '\\b' to escape the backspace character in a regular expression is confusing\n              since it could be mistaken for a word boundary assertion.","id":"py/regex/backspace-escape","kind":"problem","name":"Backspace escape in regular expression","precision":"very-high","problem.severity":"recommendation","sub-severity":"high"}},{"id":"py/regex/unmatchable-caret","name":"py/regex/unmatchable-caret","shortDescription":{"text":"Unmatchable caret in regular expression"},"fullDescription":{"text":"Regular expressions containing a caret '^' in the middle cannot be matched, whatever the input."},"defaultConfiguration":{"enabled":true,"level":"error"},"help":{"text":"# Unmatchable caret in regular expression\nThe caret character `^` anchors a regular expression to the beginning of the input, or (for multi-line regular expressions) to the beginning of a line. If it is preceded by a pattern that must match a non-empty sequence of (non-newline) input characters, then the entire regular expression cannot match anything.\n\n\n## Recommendation\nExamine the regular expression to find and correct any typos.\n\n\n## Example\nIn the following example, the regular expression `r\"\\[^.]*\\.css\"` cannot match any string, since it contains a caret assertion preceded by an escape sequence that matches an opening bracket.\n\nIn the second regular expression, `r\"[^.]*\\.css\"`, the caret is part of a character class, and will not match the start of the string.\n\n\n```python\nimport re\n#Regular expression includes a caret, but not at the start.\nmatcher = re.compile(r\"\\[^.]*\\.css\")\n\ndef find_css(filename):\n    if matcher.match(filename):\n        print(\"Found it!\")\n        \n#Regular expression for a css file name\nfixed_matcher_css = re.compile(r\"[^.]*\\.css\")\n\n\n```\n\n## References\n* Python Standard Library: [Regular expression operations](https://docs.python.org/library/re.html).\n* Regular-Expressions.info: [Start of String and End of String Anchors](http://www.regular-expressions.info/anchors.html).\n","markdown":"# Unmatchable caret in regular expression\nThe caret character `^` anchors a regular expression to the beginning of the input, or (for multi-line regular expressions) to the beginning of a line. If it is preceded by a pattern that must match a non-empty sequence of (non-newline) input characters, then the entire regular expression cannot match anything.\n\n\n## Recommendation\nExamine the regular expression to find and correct any typos.\n\n\n## Example\nIn the following example, the regular expression `r\"\\[^.]*\\.css\"` cannot match any string, since it contains a caret assertion preceded by an escape sequence that matches an opening bracket.\n\nIn the second regular expression, `r\"[^.]*\\.css\"`, the caret is part of a character class, and will not match the start of the string.\n\n\n```python\nimport re\n#Regular expression includes a caret, but not at the start.\nmatcher = re.compile(r\"\\[^.]*\\.css\")\n\ndef find_css(filename):\n    if matcher.match(filename):\n        print(\"Found it!\")\n        \n#Regular expression for a css file name\nfixed_matcher_css = re.compile(r\"[^.]*\\.css\")\n\n\n```\n\n## References\n* Python Standard Library: [Regular expression operations](https://docs.python.org/library/re.html).\n* Regular-Expressions.info: [Start of String and End of String Anchors](http://www.regular-expressions.info/anchors.html).\n"},"properties":{"tags":["quality","reliability","correctness"],"description":"Regular expressions containing a caret '^' in the middle cannot be matched, whatever the input.","id":"py/regex/unmatchable-caret","kind":"problem","name":"Unmatchable caret in regular expression","precision":"high","problem.severity":"error","sub-severity":"low"}},{"id":"py/regex/duplicate-in-character-class","name":"py/regex/duplicate-in-character-class","shortDescription":{"text":"Duplication in regular expression character class"},"fullDescription":{"text":"Duplicate characters in a class have no effect and may indicate an error in the regular expression."},"defaultConfiguration":{"enabled":true,"level":"warning"},"help":{"text":"# Duplication in regular expression character class\nCharacter classes in regular expressions represent sets of characters, so there is no need to specify the same character twice in one character class. Duplicate characters in character classes are at best useless, and may even indicate a latent bug.\n\n\n## Recommendation\nDetermine whether a character is simply duplicated or whether the character class was in fact meant as a group. If it is just a duplicate, then remove the duplicate character. If was supposed to be a group, then replace the square brackets with parentheses.\n\n\n## Example\nIn the following example, the character class `[password|pwd]` contains two instances each of the characters `d`, `p`, `s`, and `w`. The programmer most likely meant to write `(password|pwd)` (a pattern that matches either the string `\"password\"` or the string `\"pwd\"`), and accidentally mistyped the enclosing brackets.\n\n\n```python\nimport re\nmatcher = re.compile(r\"[password|pwd]\")\n\ndef find_password(data):\n    if matcher.match(data):\n        print(\"Found password!\")\n\n```\nTo fix this problem, the regular expression should be rewritten to `r\"(password|pwd)\"`.\n\n\n## References\n* Python Standard Library: [Regular expression operations](https://docs.python.org/library/re.html).\n* Regular-Expressions.info: [Character Classes or Character Sets](http://www.regular-expressions.info/charclass.html).\n","markdown":"# Duplication in regular expression character class\nCharacter classes in regular expressions represent sets of characters, so there is no need to specify the same character twice in one character class. Duplicate characters in character classes are at best useless, and may even indicate a latent bug.\n\n\n## Recommendation\nDetermine whether a character is simply duplicated or whether the character class was in fact meant as a group. If it is just a duplicate, then remove the duplicate character. If was supposed to be a group, then replace the square brackets with parentheses.\n\n\n## Example\nIn the following example, the character class `[password|pwd]` contains two instances each of the characters `d`, `p`, `s`, and `w`. The programmer most likely meant to write `(password|pwd)` (a pattern that matches either the string `\"password\"` or the string `\"pwd\"`), and accidentally mistyped the enclosing brackets.\n\n\n```python\nimport re\nmatcher = re.compile(r\"[password|pwd]\")\n\ndef find_password(data):\n    if matcher.match(data):\n        print(\"Found password!\")\n\n```\nTo fix this problem, the regular expression should be rewritten to `r\"(password|pwd)\"`.\n\n\n## References\n* Python Standard Library: [Regular expression operations](https://docs.python.org/library/re.html).\n* Regular-Expressions.info: [Character Classes or Character Sets](http://www.regular-expressions.info/charclass.html).\n"},"properties":{"tags":["quality","maintainability","readability"],"description":"Duplicate characters in a class have no effect and may indicate an error in the regular expression.","id":"py/regex/duplicate-in-character-class","kind":"problem","name":"Duplication in regular expression character class","precision":"very-high","problem.severity":"warning","sub-severity":"low"}},{"id":"py/implicit-string-concatenation-in-list","name":"py/implicit-string-concatenation-in-list","shortDescription":{"text":"Implicit string concatenation in a list"},"fullDescription":{"text":"Omitting a comma between strings causes implicit concatenation which is confusing in a list."},"defaultConfiguration":{"enabled":true,"level":"warning"},"help":{"text":"# Implicit string concatenation in a list\nWhen two string literals abut each other the Python interpreter implicitly concatenates them into a single string. On occasion this can be useful, but is more commonly misleading or incorrect.\n\n\n## Recommendation\nIf the concatenation is deliberate, then use `+` to join the strings. This has no runtime overhead, and makes the intention clear.\n\n\n## Example\nIn the first function below, `unclear`, implicit string concatenation is used twice; once deliberately and once by accident. In the second function, `clarified`, the first concatenation is made explicit and the second is removed.\n\n\n```python\n\ndef unclear():\n    # Returns [ \"first part of long string and the second part\", \"/usr/local/usr/bin\" ]\n    return [\n\n        \"first part of long string\"\n        \" and the second part\",\n        \"/usr/local\"\n        \"/usr/bin\"\n    ]\n\ndef clarified():\n    # Returns [ \"first part of long string and the second part\", \"/usr/local\", \"/usr/bin\" ]\n    return [\n        \"first part of long string\" +\n        \" and the second part\",\n        \"/usr/local\",\n        \"/usr/bin\"\n    ]\n\n```\n\n## References\n* Python language reference: [String literal concatenation](https://docs.python.org/3/reference/lexical_analysis.html#string-literal-concatenation).\n* Common Weakness Enumeration: [CWE-665](https://cwe.mitre.org/data/definitions/665.html).\n","markdown":"# Implicit string concatenation in a list\nWhen two string literals abut each other the Python interpreter implicitly concatenates them into a single string. On occasion this can be useful, but is more commonly misleading or incorrect.\n\n\n## Recommendation\nIf the concatenation is deliberate, then use `+` to join the strings. This has no runtime overhead, and makes the intention clear.\n\n\n## Example\nIn the first function below, `unclear`, implicit string concatenation is used twice; once deliberately and once by accident. In the second function, `clarified`, the first concatenation is made explicit and the second is removed.\n\n\n```python\n\ndef unclear():\n    # Returns [ \"first part of long string and the second part\", \"/usr/local/usr/bin\" ]\n    return [\n\n        \"first part of long string\"\n        \" and the second part\",\n        \"/usr/local\"\n        \"/usr/bin\"\n    ]\n\ndef clarified():\n    # Returns [ \"first part of long string and the second part\", \"/usr/local\", \"/usr/bin\" ]\n    return [\n        \"first part of long string\" +\n        \" and the second part\",\n        \"/usr/local\",\n        \"/usr/bin\"\n    ]\n\n```\n\n## References\n* Python language reference: [String literal concatenation](https://docs.python.org/3/reference/lexical_analysis.html#string-literal-concatenation).\n* Common Weakness Enumeration: [CWE-665](https://cwe.mitre.org/data/definitions/665.html).\n"},"properties":{"tags":["quality","maintainability","readability","external/cwe/cwe-665"],"description":"Omitting a comma between strings causes implicit concatenation which is confusing in a list.","id":"py/implicit-string-concatenation-in-list","kind":"problem","name":"Implicit string concatenation in a list","precision":"high","problem.severity":"warning","sub-severity":"high"}},{"id":"py/unnecessary-lambda","name":"py/unnecessary-lambda","shortDescription":{"text":"Unnecessary lambda"},"fullDescription":{"text":"A lambda is used that calls through to a function without modifying any parameters"},"defaultConfiguration":{"enabled":true,"level":"note"},"help":{"text":"# Unnecessary lambda\nA lambda that calls a function without modifying any of its parameters is unnecessary. Python functions are first class objects and can be passed around in the same way as the resulting lambda.\n\n\n## Recommendation\nRemove the lambda, use the function directly.\n\n\n## Example\nIn this example a lambda is used unnecessarily in order to pass a method as an argument to ` call_with_x_squared`.\n\n\n```python\nimport math\n\ndef call_with_x_squared(x, function):\n    x = x*x\n    return function(x)\n\nprint call_with_x_squared(2, lambda x: math.factorial(x))\n```\nThis is not necessary as methods can be passed directly. They behave as callable objects.\n\n\n```python\nimport math\n\ndef call_with_x_squared(x, function):\n    x = x*x\n    return function(x)\n\nprint call_with_x_squared(2, math.factorial)\n```\n\n## References\n* Python: [lambdas](http://docs.python.org/2.7/reference/expressions.html#lambda).\n","markdown":"# Unnecessary lambda\nA lambda that calls a function without modifying any of its parameters is unnecessary. Python functions are first class objects and can be passed around in the same way as the resulting lambda.\n\n\n## Recommendation\nRemove the lambda, use the function directly.\n\n\n## Example\nIn this example a lambda is used unnecessarily in order to pass a method as an argument to ` call_with_x_squared`.\n\n\n```python\nimport math\n\ndef call_with_x_squared(x, function):\n    x = x*x\n    return function(x)\n\nprint call_with_x_squared(2, lambda x: math.factorial(x))\n```\nThis is not necessary as methods can be passed directly. They behave as callable objects.\n\n\n```python\nimport math\n\ndef call_with_x_squared(x, function):\n    x = x*x\n    return function(x)\n\nprint call_with_x_squared(2, math.factorial)\n```\n\n## References\n* Python: [lambdas](http://docs.python.org/2.7/reference/expressions.html#lambda).\n"},"properties":{"tags":["quality","maintainability","useless-code"],"description":"A lambda is used that calls through to a function without modifying any parameters","id":"py/unnecessary-lambda","kind":"problem","name":"Unnecessary lambda","precision":"high","problem.severity":"recommendation","sub-severity":"high"}},{"id":"py/empty-except","name":"py/empty-except","shortDescription":{"text":"Empty except"},"fullDescription":{"text":"Except doesn't do anything and has no comment"},"defaultConfiguration":{"enabled":true,"level":"note"},"help":{"text":"# Empty except\nIgnoring exceptions that should be dealt with in some way is almost always a bad idea. The loss of information can lead to hard to debug errors and incomplete log files. It is even possible that ignoring an exception can cause a security vulnerability. An empty `except` block may be an indication that the programmer intended to handle the exception, but never wrote the code to do so.\n\n\n## Recommendation\nEnsure all exceptions are handled correctly.\n\n\n## Example\nIn this example, the program keeps running with the same privileges if it fails to drop to lower privileges.\n\n\n```python\n# ...\ntry:\n    security_manager.drop_privileges()\nexcept SecurityError:\n    pass\n# ...\n```\n\n## References\n* Common Weakness Enumeration: [CWE-390](https://cwe.mitre.org/data/definitions/390.html).\n","markdown":"# Empty except\nIgnoring exceptions that should be dealt with in some way is almost always a bad idea. The loss of information can lead to hard to debug errors and incomplete log files. It is even possible that ignoring an exception can cause a security vulnerability. An empty `except` block may be an indication that the programmer intended to handle the exception, but never wrote the code to do so.\n\n\n## Recommendation\nEnsure all exceptions are handled correctly.\n\n\n## Example\nIn this example, the program keeps running with the same privileges if it fails to drop to lower privileges.\n\n\n```python\n# ...\ntry:\n    security_manager.drop_privileges()\nexcept SecurityError:\n    pass\n# ...\n```\n\n## References\n* Common Weakness Enumeration: [CWE-390](https://cwe.mitre.org/data/definitions/390.html).\n"},"properties":{"tags":["quality","reliability","error-handling","external/cwe/cwe-390"],"description":"Except doesn't do anything and has no comment","id":"py/empty-except","kind":"problem","name":"Empty except","precision":"high","problem.severity":"recommendation","sub-severity":"high"}},{"id":"py/useless-except","name":"py/useless-except","shortDescription":{"text":"Non-exception in 'except' clause"},"fullDescription":{"text":"An exception handler specifying a non-exception type will never handle any exception."},"defaultConfiguration":{"enabled":true,"level":"error"},"help":{"text":"# Non-exception in 'except' clause\nIf the class specified in an `except` handler (within a `try` statement) is not a legal exception class, then it will never match a raised exception and never be executed\n\nLegal exception classes are:\n\n* Any old-style classes (Python 2 only)\n* Any subclass of the builtin class `BaseException`\nHowever, it recommended that you only use subclasses of the builtin class `Exception` (which is itself a subclass of `BaseException`).\n\n\n## Recommendation\nEnsure that the specified class is the one intended. If it is not then replace it with the correct one. Otherwise the entire `except` block can be deleted.\n\n\n## Example\n\n```python\ndef handle_int():\n    try:\n        raise_int()\n    #This will not cause an exception, but it will be ignored\n    except int:\n        print(\"This will never be printed\")\n\n\n```\n\n## References\n* Python Language Reference: [Exceptions](https://docs.python.org/reference/executionmodel.html#exceptions).\n* Python Tutorial: [Handling Exceptions](https://docs.python.org/tutorial/errors.html#handling-exceptions).\n","markdown":"# Non-exception in 'except' clause\nIf the class specified in an `except` handler (within a `try` statement) is not a legal exception class, then it will never match a raised exception and never be executed\n\nLegal exception classes are:\n\n* Any old-style classes (Python 2 only)\n* Any subclass of the builtin class `BaseException`\nHowever, it recommended that you only use subclasses of the builtin class `Exception` (which is itself a subclass of `BaseException`).\n\n\n## Recommendation\nEnsure that the specified class is the one intended. If it is not then replace it with the correct one. Otherwise the entire `except` block can be deleted.\n\n\n## Example\n\n```python\ndef handle_int():\n    try:\n        raise_int()\n    #This will not cause an exception, but it will be ignored\n    except int:\n        print(\"This will never be printed\")\n\n\n```\n\n## References\n* Python Language Reference: [Exceptions](https://docs.python.org/reference/executionmodel.html#exceptions).\n* Python Tutorial: [Handling Exceptions](https://docs.python.org/tutorial/errors.html#handling-exceptions).\n"},"properties":{"tags":["quality","reliability","error-handling"],"description":"An exception handler specifying a non-exception type will never handle any exception.","id":"py/useless-except","kind":"problem","name":"Non-exception in 'except' clause","precision":"very-high","problem.severity":"error","sub-severity":"low"}},{"id":"py/raises-tuple","name":"py/raises-tuple","shortDescription":{"text":"Raising a tuple"},"fullDescription":{"text":"Raising a tuple will result in all but the first element being discarded"},"defaultConfiguration":{"enabled":true,"level":"warning"},"help":{"text":"# Raising a tuple\nIn Python 2, if a tuple is raised then all elements but the first are ignored and only the first part is raised. If the first element is itself a tuple, then the first element of that is used and so on. This unlikely to be the intended effect and will most likely indicate some sort of error.\n\nIt is important to note that the exception in `raise Exception, message` is *not* a tuple, whereas the exception in `ex = Exception, message; raise ex` *is* a tuple.\n\nIn Python 3, raising a tuple is an error.\n\n\n## Recommendation\nGiven that all but the first element of the tuple is ignored, the tuple should be replaced with its first element in order to improve the clarity of the code. If the subsequent parts of the tuple were intended to form the message, then they should be passed as an argument when creating the exception.\n\n\n## Example\nIn the following example the intended error message is mistakenly used to form a tuple.\n\n\n```python\n\n\ndef raise_tuple():\n    ex = Exception, \"Important diagnostic information\"\n    raise ex\n\n```\nThis can be fixed, either by using the message to create the exception or using the message in the raise statement, as shown below.\n\n\n```python\n\n\ndef fixed_raise_tuple1():\n    ex = Exception(\"Important diagnostic information\")\n    raise ex\n\n\ndef fixed_raise_tuple2():\n    raise Exception, \"Important diagnostic information\"\n\n```\n\n## References\n* Python Language Reference: [Exceptions](https://docs.python.org/reference/executionmodel.html#exceptions).\n* Python Tutorial: [Handling Exceptions](https://docs.python.org/tutorial/errors.html#handling-exceptions).\n","markdown":"# Raising a tuple\nIn Python 2, if a tuple is raised then all elements but the first are ignored and only the first part is raised. If the first element is itself a tuple, then the first element of that is used and so on. This unlikely to be the intended effect and will most likely indicate some sort of error.\n\nIt is important to note that the exception in `raise Exception, message` is *not* a tuple, whereas the exception in `ex = Exception, message; raise ex` *is* a tuple.\n\nIn Python 3, raising a tuple is an error.\n\n\n## Recommendation\nGiven that all but the first element of the tuple is ignored, the tuple should be replaced with its first element in order to improve the clarity of the code. If the subsequent parts of the tuple were intended to form the message, then they should be passed as an argument when creating the exception.\n\n\n## Example\nIn the following example the intended error message is mistakenly used to form a tuple.\n\n\n```python\n\n\ndef raise_tuple():\n    ex = Exception, \"Important diagnostic information\"\n    raise ex\n\n```\nThis can be fixed, either by using the message to create the exception or using the message in the raise statement, as shown below.\n\n\n```python\n\n\ndef fixed_raise_tuple1():\n    ex = Exception(\"Important diagnostic information\")\n    raise ex\n\n\ndef fixed_raise_tuple2():\n    raise Exception, \"Important diagnostic information\"\n\n```\n\n## References\n* Python Language Reference: [Exceptions](https://docs.python.org/reference/executionmodel.html#exceptions).\n* Python Tutorial: [Handling Exceptions](https://docs.python.org/tutorial/errors.html#handling-exceptions).\n"},"properties":{"tags":["maintainability"],"description":"Raising a tuple will result in all but the first element being discarded","id":"py/raises-tuple","kind":"problem","name":"Raising a tuple","precision":"very-high","problem.severity":"warning","sub-severity":"high"}},{"id":"py/unreachable-except","name":"py/unreachable-except","shortDescription":{"text":"Unreachable 'except' block"},"fullDescription":{"text":"Handling general exceptions before specific exceptions means that the specific handlers are never executed."},"defaultConfiguration":{"enabled":true,"level":"error"},"help":{"text":"# Unreachable 'except' block\nWhen handling an exception, Python searches the except blocks in source code order until it finds a matching `except` block for the exception. An except block, `except E:`, specifies a class `E` and will match any exception that is an instance of `E`.\n\nIf a more general except block precedes a more specific except block, then the more general block is always executed and the more specific block is never executed. An except block, `except A:`, is more general than another except block, `except B:`, if `A` is a super class of `B`.\n\nFor example: `except Exception:` is more general than `except Error:` as `Exception` is a super class of `Error`.\n\n\n## Recommendation\nReorganize the `except` blocks so that the more specific `except` is defined first. Alternatively, if the more specific `except` block is no longer required then it should be deleted.\n\n\n## Example\nIn this example the `except Exception:` will handle `AttributeError` preventing the subsequent handler from ever executing.\n\n\n```python\n\n\ndef incorrect_except_order(val):\n    try:\n        val.attr\n    except Exception:\n        print (\"Exception\")\n    except AttributeError:\n        print (\"AttributeError\")\n        \n\n```\n\n## References\n* Python Language Reference: [The try statement](http://docs.python.org/2.7/reference/compound_stmts.html#try), [Exceptions](http://docs.python.org/2.7/reference/executionmodel.html#exceptions).\n* Common Weakness Enumeration: [CWE-561](https://cwe.mitre.org/data/definitions/561.html).\n","markdown":"# Unreachable 'except' block\nWhen handling an exception, Python searches the except blocks in source code order until it finds a matching `except` block for the exception. An except block, `except E:`, specifies a class `E` and will match any exception that is an instance of `E`.\n\nIf a more general except block precedes a more specific except block, then the more general block is always executed and the more specific block is never executed. An except block, `except A:`, is more general than another except block, `except B:`, if `A` is a super class of `B`.\n\nFor example: `except Exception:` is more general than `except Error:` as `Exception` is a super class of `Error`.\n\n\n## Recommendation\nReorganize the `except` blocks so that the more specific `except` is defined first. Alternatively, if the more specific `except` block is no longer required then it should be deleted.\n\n\n## Example\nIn this example the `except Exception:` will handle `AttributeError` preventing the subsequent handler from ever executing.\n\n\n```python\n\n\ndef incorrect_except_order(val):\n    try:\n        val.attr\n    except Exception:\n        print (\"Exception\")\n    except AttributeError:\n        print (\"AttributeError\")\n        \n\n```\n\n## References\n* Python Language Reference: [The try statement](http://docs.python.org/2.7/reference/compound_stmts.html#try), [Exceptions](http://docs.python.org/2.7/reference/executionmodel.html#exceptions).\n* Common Weakness Enumeration: [CWE-561](https://cwe.mitre.org/data/definitions/561.html).\n"},"properties":{"tags":["quality","reliability","error-handling","external/cwe/cwe-561"],"description":"Handling general exceptions before specific exceptions means that the specific\n              handlers are never executed.","id":"py/unreachable-except","kind":"problem","name":"Unreachable 'except' block","precision":"very-high","problem.severity":"error","sub-severity":"low"}},{"id":"py/unguarded-next-in-generator","name":"py/unguarded-next-in-generator","shortDescription":{"text":"Unguarded next in generator"},"fullDescription":{"text":"Calling next() in a generator may cause unintended early termination of an iteration."},"defaultConfiguration":{"enabled":true,"level":"warning"},"help":{"text":"# Unguarded next in generator\nThe function `next()` will raise a `StopIteration` exception if the underlying iterator is exhausted. Normally this is fine, but in a generator may cause problems. Since the `StopIteration` is an exception it will be propagated out of the generator causing termination of the generator. This is unlikely to be the expected behavior and may mask errors.\n\nThis problem is considered sufficiently serious that [PEP 479](https://www.python.org/dev/peps/pep-0479) has been accepted to modify the handling of `StopIteration` in generators. Consequently, code that does not handle `StopIteration` properly is likely to fail in future versions of Python.\n\n\n## Recommendation\nEach call to `next()` should be wrapped in a `try-except` to explicitly handle `StopIteration` exceptions.\n\n\n## Example\nIn the following example, an empty file part way through iteration will silently truncate the output as the `StopIteration` exception propagates to the top level.\n\n\n```python\n\ntest_files = [\n    [\"header1\", \"text10\", \"text11\", \"text12\"],\n    [\"header2\", \"text20\", \"text21\", \"text22\"],\n    [],\n    [\"header4\", \"text40\", \"text41\", \"text42\"],\n]\n\ndef separate_headers(files):\n    for file in files:\n        lines = iter(file)\n        header = next(lines) # Will raise StopIteration if lines is exhausted\n        body = [ l for l in lines ]\n        yield header, body\n\ndef process_files(files):\n    for header, body in separate_headers(files):\n        print(format_page(header, body))\n\n\n```\nIn the following example `StopIteration` exception is explicitly handled, allowing all the files to be processed.\n\n\n```python\n\ndef separate_headers(files):\n    for file in files:\n        lines = iter(file)\n        try:\n            header = next(lines) # Will raise StopIteration if lines is exhausted\n        except StopIteration:\n            #Empty file -- Just ignore\n            continue\n        body = [ l for l in lines ]\n        yield header, body\n\n```\n\n## References\n* Python PEP index: [PEP 479](https://www.python.org/dev/peps/pep-0479).\n","markdown":"# Unguarded next in generator\nThe function `next()` will raise a `StopIteration` exception if the underlying iterator is exhausted. Normally this is fine, but in a generator may cause problems. Since the `StopIteration` is an exception it will be propagated out of the generator causing termination of the generator. This is unlikely to be the expected behavior and may mask errors.\n\nThis problem is considered sufficiently serious that [PEP 479](https://www.python.org/dev/peps/pep-0479) has been accepted to modify the handling of `StopIteration` in generators. Consequently, code that does not handle `StopIteration` properly is likely to fail in future versions of Python.\n\n\n## Recommendation\nEach call to `next()` should be wrapped in a `try-except` to explicitly handle `StopIteration` exceptions.\n\n\n## Example\nIn the following example, an empty file part way through iteration will silently truncate the output as the `StopIteration` exception propagates to the top level.\n\n\n```python\n\ntest_files = [\n    [\"header1\", \"text10\", \"text11\", \"text12\"],\n    [\"header2\", \"text20\", \"text21\", \"text22\"],\n    [],\n    [\"header4\", \"text40\", \"text41\", \"text42\"],\n]\n\ndef separate_headers(files):\n    for file in files:\n        lines = iter(file)\n        header = next(lines) # Will raise StopIteration if lines is exhausted\n        body = [ l for l in lines ]\n        yield header, body\n\ndef process_files(files):\n    for header, body in separate_headers(files):\n        print(format_page(header, body))\n\n\n```\nIn the following example `StopIteration` exception is explicitly handled, allowing all the files to be processed.\n\n\n```python\n\ndef separate_headers(files):\n    for file in files:\n        lines = iter(file)\n        try:\n            header = next(lines) # Will raise StopIteration if lines is exhausted\n        except StopIteration:\n            #Empty file -- Just ignore\n            continue\n        body = [ l for l in lines ]\n        yield header, body\n\n```\n\n## References\n* Python PEP index: [PEP 479](https://www.python.org/dev/peps/pep-0479).\n"},"properties":{"tags":["maintainability","portability"],"description":"Calling next() in a generator may cause unintended early termination of an iteration.","id":"py/unguarded-next-in-generator","kind":"problem","name":"Unguarded next in generator","precision":"very-high","problem.severity":"warning","sub-severity":"low"}},{"id":"py/raise-not-implemented","name":"py/raise-not-implemented","shortDescription":{"text":"Raising `NotImplemented`"},"fullDescription":{"text":"Using `NotImplemented` as an exception will result in a type error."},"defaultConfiguration":{"enabled":true,"level":"warning"},"help":{"text":"# Raising `NotImplemented`\nThe constant `NotImplemented` is not an `Exception`, but is often confused for `NotImplementedError`. If it is used as an exception, such as in `raise NotImplemented` or `raise NotImplemented(\"message\")`, a `TypeError` will be raised rather than the expected `NotImplemented`. This may make debugging more difficult.\n\n`NotImplemented` should only be used as a special return value for implementing special methods such as `__lt__`. Code that is not intended to be called should raise `NotImplementedError`.\n\n\n## Recommendation\nIf a `NotImplementedError` is intended to be raised, replace the use of `NotImplemented` with that. If `NotImplemented` is intended to be returned rather than raised, replace the `raise` with `return NotImplemented`.\n\n\n## Example\nIn the following example, the method `wrong` will incorrectly raise a `TypeError` when called. The method `right` will raise a `NotImplementedError`.\n\n\n```python\n\nclass Abstract(object):\n\n    def wrong(self):\n        # Will raise a TypeError\n        raise NotImplemented()\n\n    def right(self):\n        raise NotImplementedError()\n\n```\n\n## References\n* Python Language Reference: [The NotImplementedError exception](https://docs.python.org/library/exceptions.html#NotImplementedError).\n* Python Language Reference: [The NotImplemented constant](https://docs.python.org/3/library/constants.html#NotImplemented).\n* Python Language Reference: [Emulating numeric types](https://docs.python.org/3/reference/datamodel.html#emulating-numeric-types).\n","markdown":"# Raising `NotImplemented`\nThe constant `NotImplemented` is not an `Exception`, but is often confused for `NotImplementedError`. If it is used as an exception, such as in `raise NotImplemented` or `raise NotImplemented(\"message\")`, a `TypeError` will be raised rather than the expected `NotImplemented`. This may make debugging more difficult.\n\n`NotImplemented` should only be used as a special return value for implementing special methods such as `__lt__`. Code that is not intended to be called should raise `NotImplementedError`.\n\n\n## Recommendation\nIf a `NotImplementedError` is intended to be raised, replace the use of `NotImplemented` with that. If `NotImplemented` is intended to be returned rather than raised, replace the `raise` with `return NotImplemented`.\n\n\n## Example\nIn the following example, the method `wrong` will incorrectly raise a `TypeError` when called. The method `right` will raise a `NotImplementedError`.\n\n\n```python\n\nclass Abstract(object):\n\n    def wrong(self):\n        # Will raise a TypeError\n        raise NotImplemented()\n\n    def right(self):\n        raise NotImplementedError()\n\n```\n\n## References\n* Python Language Reference: [The NotImplementedError exception](https://docs.python.org/library/exceptions.html#NotImplementedError).\n* Python Language Reference: [The NotImplemented constant](https://docs.python.org/3/library/constants.html#NotImplemented).\n* Python Language Reference: [Emulating numeric types](https://docs.python.org/3/reference/datamodel.html#emulating-numeric-types).\n"},"properties":{"tags":["quality","reliability","error-handling"],"description":"Using `NotImplemented` as an exception will result in a type error.","id":"py/raise-not-implemented","kind":"problem","name":"Raising `NotImplemented`","precision":"very-high","problem.severity":"warning","sub-severity":"high"}},{"id":"py/illegal-raise","name":"py/illegal-raise","shortDescription":{"text":"Illegal raise"},"fullDescription":{"text":"Raising a non-exception object or type will result in a TypeError being raised instead."},"defaultConfiguration":{"enabled":true,"level":"error"},"help":{"text":"# Illegal raise\nIf the object raised is not a legal Exception class or an instance of one, then a `TypeError` will be raised instead.\n\nLegal exception classes are:\n\n* Any old-style classes (Python 2 only)\n* Any subclass of the builtin class `BaseException`\nHowever, it recommended that you only use subclasses of the builtin class `Exception` (which is itself a subclass of `BaseException`).\n\n\n## Recommendation\nChange the expression in the `raise` statement to be a legal exception.\n\n\n## Example\n\n```python\n#Cannot raise an int, even if we want to\ndef raise_int():\n    #Will raise a TypeError\n    raise 4\n\n\n```\n\n## References\n* Python Language Reference: [Exceptions](https://docs.python.org/reference/executionmodel.html#exceptions).\n* Python Tutorial: [Handling Exceptions](https://docs.python.org/tutorial/errors.html#handling-exceptions).\n","markdown":"# Illegal raise\nIf the object raised is not a legal Exception class or an instance of one, then a `TypeError` will be raised instead.\n\nLegal exception classes are:\n\n* Any old-style classes (Python 2 only)\n* Any subclass of the builtin class `BaseException`\nHowever, it recommended that you only use subclasses of the builtin class `Exception` (which is itself a subclass of `BaseException`).\n\n\n## Recommendation\nChange the expression in the `raise` statement to be a legal exception.\n\n\n## Example\n\n```python\n#Cannot raise an int, even if we want to\ndef raise_int():\n    #Will raise a TypeError\n    raise 4\n\n\n```\n\n## References\n* Python Language Reference: [Exceptions](https://docs.python.org/reference/executionmodel.html#exceptions).\n* Python Tutorial: [Handling Exceptions](https://docs.python.org/tutorial/errors.html#handling-exceptions).\n"},"properties":{"tags":["quality","reliability","error-handling"],"description":"Raising a non-exception object or type will result in a TypeError being raised instead.","id":"py/illegal-raise","kind":"problem","name":"Illegal raise","precision":"very-high","problem.severity":"error","sub-severity":"high"}},{"id":"py/catch-base-exception","name":"py/catch-base-exception","shortDescription":{"text":"Except block handles 'BaseException'"},"fullDescription":{"text":"Handling 'BaseException' means that system exits and keyboard interrupts may be mis-handled."},"defaultConfiguration":{"enabled":true,"level":"note"},"help":{"text":"# Except block handles 'BaseException'\nAll exception classes in Python derive from `BaseException`. `BaseException` has three important subclasses, `Exception` from which all errors and normal exceptions derive, `KeyboardInterrupt` which is raised when the user interrupts the program from the keyboard and `SystemExit` which is raised by the `sys.exit()` function to terminate the program.\n\nSince `KeyboardInterrupt` and `SystemExit` are special they should not be grouped together with other `Exception` classes.\n\nCatching `BaseException`, rather than its subclasses may prevent proper handling of `KeyboardInterrupt` or `SystemExit`. It is easy to catch `BaseException` accidentally as it is caught implicitly by an empty `except:` statement.\n\n\n## Recommendation\nHandle `Exception`, `KeyboardInterrupt` and `SystemExit` separately. Do not use the plain `except:` form.\n\n\n## Example\nIn these examples, a function `application.main()` is called that might raise `SystemExit`. In the first two functions, `BaseException` is caught, but this will discard `KeyboardInterrupt`. In the third function, `call_main_program_fixed` only `SystemExit` is caught, leaving `KeyboardInterrupt` to propagate.\n\nIn these examples `KeyboardInterrupt` is accidentally ignored.\n\n\n```python\n\ndef call_main_program_implicit_handle_base_exception():\n    try:\n        #application.main calls sys.exit() when done.\n        application.main()\n    except Exception as ex:\n        log(ex)\n    except:\n        pass\n\ndef call_main_program_explicit_handle_base_exception():\n    try:\n        #application.main calls sys.exit() when done.\n        application.main()\n    except Exception as ex:\n        log(ex)\n    except BaseException:\n        pass\n\ndef call_main_program_fixed():\n    try:\n        #application.main calls sys.exit() when done.\n        application.main()\n    except Exception as ex:\n        log(ex)\n    except SystemExit:\n        pass\n\n```\n\n## References\n* Python Language Reference: [The try statement](http://docs.python.org/3/reference/compound_stmts.html#try), [Exceptions](http://docs.python.org/3/reference/executionmodel.html#exceptions).\n* M. Lutz, Learning Python, Section 35.3: Exception Design Tips and Gotchas, O'Reilly Media, 2013.\n* Python Tutorial: [Errors and Exceptions](https://docs.python.org/3/tutorial/errors.html).\n* Common Weakness Enumeration: [CWE-396](https://cwe.mitre.org/data/definitions/396.html).\n","markdown":"# Except block handles 'BaseException'\nAll exception classes in Python derive from `BaseException`. `BaseException` has three important subclasses, `Exception` from which all errors and normal exceptions derive, `KeyboardInterrupt` which is raised when the user interrupts the program from the keyboard and `SystemExit` which is raised by the `sys.exit()` function to terminate the program.\n\nSince `KeyboardInterrupt` and `SystemExit` are special they should not be grouped together with other `Exception` classes.\n\nCatching `BaseException`, rather than its subclasses may prevent proper handling of `KeyboardInterrupt` or `SystemExit`. It is easy to catch `BaseException` accidentally as it is caught implicitly by an empty `except:` statement.\n\n\n## Recommendation\nHandle `Exception`, `KeyboardInterrupt` and `SystemExit` separately. Do not use the plain `except:` form.\n\n\n## Example\nIn these examples, a function `application.main()` is called that might raise `SystemExit`. In the first two functions, `BaseException` is caught, but this will discard `KeyboardInterrupt`. In the third function, `call_main_program_fixed` only `SystemExit` is caught, leaving `KeyboardInterrupt` to propagate.\n\nIn these examples `KeyboardInterrupt` is accidentally ignored.\n\n\n```python\n\ndef call_main_program_implicit_handle_base_exception():\n    try:\n        #application.main calls sys.exit() when done.\n        application.main()\n    except Exception as ex:\n        log(ex)\n    except:\n        pass\n\ndef call_main_program_explicit_handle_base_exception():\n    try:\n        #application.main calls sys.exit() when done.\n        application.main()\n    except Exception as ex:\n        log(ex)\n    except BaseException:\n        pass\n\ndef call_main_program_fixed():\n    try:\n        #application.main calls sys.exit() when done.\n        application.main()\n    except Exception as ex:\n        log(ex)\n    except SystemExit:\n        pass\n\n```\n\n## References\n* Python Language Reference: [The try statement](http://docs.python.org/3/reference/compound_stmts.html#try), [Exceptions](http://docs.python.org/3/reference/executionmodel.html#exceptions).\n* M. Lutz, Learning Python, Section 35.3: Exception Design Tips and Gotchas, O'Reilly Media, 2013.\n* Python Tutorial: [Errors and Exceptions](https://docs.python.org/3/tutorial/errors.html).\n* Common Weakness Enumeration: [CWE-396](https://cwe.mitre.org/data/definitions/396.html).\n"},"properties":{"tags":["quality","reliability","error-handling","external/cwe/cwe-396"],"description":"Handling 'BaseException' means that system exits and keyboard interrupts may be mis-handled.","id":"py/catch-base-exception","kind":"problem","name":"Except block handles 'BaseException'","precision":"very-high","problem.severity":"recommendation","sub-severity":"high"}},{"id":"py/inheritance/incorrect-overriding-signature","name":"py/inheritance/incorrect-overriding-signature","shortDescription":{"text":"Mismatch between signature and use of an overriding method"},"fullDescription":{"text":"Method has a different signature from the overridden method and, if it were called, would be likely to cause an error."},"defaultConfiguration":{"enabled":true,"level":"error"},"help":{"text":"# Mismatch between signature and use of an overriding method\nThere is a call to the overridden method, and potentially the overriding method, with arguments that are not legal for the overriding method. This will cause an error if the overriding method is called and is a violation of the Liskov substitution principle.\n\n\n## Recommendation\nEnsure that the overriding method accepts all the parameters that are legal for the overridden method.\n\n\n## Example\nIn this example there is a mismatch between the legal parameters for the base class method `(self, source, filename, symbol)` and the extension method `(self, source)`. The extension method can be used to override the base method as long as values are not specified for the `filename` and (optional) `symbol` parameters. If the extension method was passed the additional parameters accepted by the base method then an error would occur.\n\n\n```python\n\nclass BaseClass(object):\n\n    def run(self, source, filename, symbol=\"single\"):\n        ... # Definition\n\n    def load_and_run(self, filename):\n        source = self.load(filename)\n        self.run(source, filename) # Matches signature in this class, but not in the derived class.\n\nclass DerivedClass(BaseClass):\n\n    def run(self, source):\n        ... # Definition\n\n```\nThe extension method should be updated to support the `filename` and `symbol` parameters supported by the overridden method.\n\n\n## References\n* Wikipedia: [Liskov Substitution Principle](http://en.wikipedia.org/wiki/Liskov_substitution_principle), [Method overriding](http://en.wikipedia.org/wiki/Method_overriding#Python).\n","markdown":"# Mismatch between signature and use of an overriding method\nThere is a call to the overridden method, and potentially the overriding method, with arguments that are not legal for the overriding method. This will cause an error if the overriding method is called and is a violation of the Liskov substitution principle.\n\n\n## Recommendation\nEnsure that the overriding method accepts all the parameters that are legal for the overridden method.\n\n\n## Example\nIn this example there is a mismatch between the legal parameters for the base class method `(self, source, filename, symbol)` and the extension method `(self, source)`. The extension method can be used to override the base method as long as values are not specified for the `filename` and (optional) `symbol` parameters. If the extension method was passed the additional parameters accepted by the base method then an error would occur.\n\n\n```python\n\nclass BaseClass(object):\n\n    def run(self, source, filename, symbol=\"single\"):\n        ... # Definition\n\n    def load_and_run(self, filename):\n        source = self.load(filename)\n        self.run(source, filename) # Matches signature in this class, but not in the derived class.\n\nclass DerivedClass(BaseClass):\n\n    def run(self, source):\n        ... # Definition\n\n```\nThe extension method should be updated to support the `filename` and `symbol` parameters supported by the overridden method.\n\n\n## References\n* Wikipedia: [Liskov Substitution Principle](http://en.wikipedia.org/wiki/Liskov_substitution_principle), [Method overriding](http://en.wikipedia.org/wiki/Method_overriding#Python).\n"},"properties":{"tags":["quality","reliability","correctness"],"description":"Method has a different signature from the overridden method and, if it were called, would be likely to cause an error.","id":"py/inheritance/incorrect-overriding-signature","kind":"problem","name":"Mismatch between signature and use of an overriding method","precision":"high","problem.severity":"error","sub-severity":"low"}},{"id":"py/iter-returns-non-self","name":"py/iter-returns-non-self","shortDescription":{"text":"Iterator does not return self from `__iter__` method"},"fullDescription":{"text":"Iterator does not return self from `__iter__` method, violating the iterator protocol."},"defaultConfiguration":{"enabled":true,"level":"error"},"help":{"text":"# Iterator does not return self from `__iter__` method\nIterator classes (classes defining a `__next__` method) should have an `__iter__` method that returns the iterator itself. This ensures that the object is also an iterable; and behaves as expected when used anywhere an iterator or iterable is expected, such as in `for` loops.\n\n\n## Recommendation\nEnsure that the `__iter__` method returns `self`, or is otherwise equivalent as an iterator to `self`.\n\n\n## Example\nIn the following example, the `MyRange` class's `__iter__` method does not return `self`. This would lead to unexpected results when used with a `for` loop or `in` statement.\n\n\n```python\nclass MyRange(object):\n    def __init__(self, low, high):\n        self.current = low\n        self.high = high\n\n    def __iter__(self):\n        return (self.current, self.high) # BAD: does not return `self`.\n\n    def __next__(self):\n        if self.current > self.high:\n            return None\n        self.current += 1\n        return self.current - 1\n```\n\n## References\n* Python Language Reference: [object.__iter__](http://docs.python.org/3/reference/datamodel.html#object.__iter__).\n* Python Standard Library: [Iterators](http://docs.python.org/3/library/stdtypes.html#typeiter).\n","markdown":"# Iterator does not return self from `__iter__` method\nIterator classes (classes defining a `__next__` method) should have an `__iter__` method that returns the iterator itself. This ensures that the object is also an iterable; and behaves as expected when used anywhere an iterator or iterable is expected, such as in `for` loops.\n\n\n## Recommendation\nEnsure that the `__iter__` method returns `self`, or is otherwise equivalent as an iterator to `self`.\n\n\n## Example\nIn the following example, the `MyRange` class's `__iter__` method does not return `self`. This would lead to unexpected results when used with a `for` loop or `in` statement.\n\n\n```python\nclass MyRange(object):\n    def __init__(self, low, high):\n        self.current = low\n        self.high = high\n\n    def __iter__(self):\n        return (self.current, self.high) # BAD: does not return `self`.\n\n    def __next__(self):\n        if self.current > self.high:\n            return None\n        self.current += 1\n        return self.current - 1\n```\n\n## References\n* Python Language Reference: [object.__iter__](http://docs.python.org/3/reference/datamodel.html#object.__iter__).\n* Python Standard Library: [Iterators](http://docs.python.org/3/library/stdtypes.html#typeiter).\n"},"properties":{"tags":["reliability","correctness","quality"],"description":"Iterator does not return self from `__iter__` method, violating the iterator protocol.","id":"py/iter-returns-non-self","kind":"problem","name":"Iterator does not return self from `__iter__` method","precision":"high","problem.severity":"error","sub-severity":"low"}},{"id":"py/overly-complex-delete","name":"py/overly-complex-delete","shortDescription":{"text":"Overly complex `__del__` method"},"fullDescription":{"text":"`__del__` methods may be called at arbitrary times, perhaps never called at all, and should be simple."},"defaultConfiguration":{"enabled":true,"level":"note"},"help":{"text":"# Overly complex `__del__` method\nThe `__del__` method exists to release any resources held by an object when that object is deleted. The `__del__` is called only by the garbage collector which may call it after an indefinite delay or never.\n\nConsequently, `__del__` method should not be relied on to release resources, such as file descriptors. Rather, these resources should be released explicitly.\n\nThe existence of a complex `__del__` method suggests that this is the main or only way to release resources associated with the object.\n\n\n## Recommendation\nIn order to ensure correct cleanup of the object add an explicit close(), or similar, method. Possibly make the object a context manager.\n\nThe __del__ method should just call close()\n\n\n## Example\nThe first example below shows a class which relies on `__del__` to release resources. The second example shows an improved version of the class where `__del__` simply calls close.\n\n\n```python\n\n#Relies on __del__ being called by the garbage collector.\nclass CachedPreferencesFile\n\n    ...\n\n    def __del__(self):\n        for key, value in self.preferences.items():\n            self.write_pair(key, value)\n        self.backing.close()\n\n\n#Better version\nclass CachedPreferencesFile\n\n    ...\n\n    def close(self):\n        for key, value in self.preferences.items():\n            self.write_pair(key, value)\n        self.backing.close()\n\n    def __del__(self):\n        self.close()\n\n```\n\n## References\n* Python Standard Library: [Context manager](http://docs.python.org/library/stdtypes.html#context-manager-types).\n","markdown":"# Overly complex `__del__` method\nThe `__del__` method exists to release any resources held by an object when that object is deleted. The `__del__` is called only by the garbage collector which may call it after an indefinite delay or never.\n\nConsequently, `__del__` method should not be relied on to release resources, such as file descriptors. Rather, these resources should be released explicitly.\n\nThe existence of a complex `__del__` method suggests that this is the main or only way to release resources associated with the object.\n\n\n## Recommendation\nIn order to ensure correct cleanup of the object add an explicit close(), or similar, method. Possibly make the object a context manager.\n\nThe __del__ method should just call close()\n\n\n## Example\nThe first example below shows a class which relies on `__del__` to release resources. The second example shows an improved version of the class where `__del__` simply calls close.\n\n\n```python\n\n#Relies on __del__ being called by the garbage collector.\nclass CachedPreferencesFile\n\n    ...\n\n    def __del__(self):\n        for key, value in self.preferences.items():\n            self.write_pair(key, value)\n        self.backing.close()\n\n\n#Better version\nclass CachedPreferencesFile\n\n    ...\n\n    def close(self):\n        for key, value in self.preferences.items():\n            self.write_pair(key, value)\n        self.backing.close()\n\n    def __del__(self):\n        self.close()\n\n```\n\n## References\n* Python Standard Library: [Context manager](http://docs.python.org/library/stdtypes.html#context-manager-types).\n"},"properties":{"tags":["quality","maintainability","complexity"],"description":"`__del__` methods may be called at arbitrary times, perhaps never called at all, and should be simple.","id":"py/overly-complex-delete","kind":"problem","name":"Overly complex `__del__` method","precision":"high","problem.severity":"recommendation","sub-severity":"low"}},{"id":"py/modification-of-default-value","name":"py/modification-of-default-value","shortDescription":{"text":"Modification of parameter with default"},"fullDescription":{"text":"Modifying the default value of a parameter can lead to unexpected results."},"defaultConfiguration":{"enabled":true,"level":"error"},"help":{"text":"# Modification of parameter with default\nThe default value of a parameter is computed once when the function is created, not for every invocation. The \"pre-computed\" value is then used for every subsequent call to the function. Consequently, if you modify the default value for a parameter this \"modified\" default value is used for the parameter in future calls to the function. This means that the function may not behave as expected in future calls and also makes the function more difficult to understand.\n\n\n## Recommendation\nIf a parameter has a default value, do not modify the default value. When you use a mutable object as a default value, you should use a placeholder value instead of modifying the default value. This is a particular problem when you work with lists and dictionaries but there are standard methods of avoiding modifying the default parameter (see References).\n\n\n## Example\nIn the following example, the `default` parameter is set with a default value of an empty list. Other commands in the function then append values to the list. The next time the function is called, the list will contain values, which may not have been intended.\n\n\n```python\n\n    def __init__(self, name, choices=[], default=[], shortDesc=None,\n                 longDesc=None, hints=None, allowNone=1):   # 'default' parameter assigned a value\n        self.choices = choices\n        if choices and not default:\n            default.append(choices[0][1])                   # value of 'default' parameter modified\n        Argument.__init__(self, name, default, shortDesc, longDesc, hints, allowNone=allowNone)\n```\nThe recommended workaround is use a placeholder value. That is, define the function with a default of `default=None`, check if the parameter is `None` and then set the parameter to a list.\n\n\n## References\n* Effbot: [Default Parameter Values in Python](https://web.archive.org/web/20201112004749/http://effbot.org/zone/default-values.htm).\n* Python Language Reference: [Function definitions](http://docs.python.org/3/reference/compound_stmts.html#function-definitions).\n","markdown":"# Modification of parameter with default\nThe default value of a parameter is computed once when the function is created, not for every invocation. The \"pre-computed\" value is then used for every subsequent call to the function. Consequently, if you modify the default value for a parameter this \"modified\" default value is used for the parameter in future calls to the function. This means that the function may not behave as expected in future calls and also makes the function more difficult to understand.\n\n\n## Recommendation\nIf a parameter has a default value, do not modify the default value. When you use a mutable object as a default value, you should use a placeholder value instead of modifying the default value. This is a particular problem when you work with lists and dictionaries but there are standard methods of avoiding modifying the default parameter (see References).\n\n\n## Example\nIn the following example, the `default` parameter is set with a default value of an empty list. Other commands in the function then append values to the list. The next time the function is called, the list will contain values, which may not have been intended.\n\n\n```python\n\n    def __init__(self, name, choices=[], default=[], shortDesc=None,\n                 longDesc=None, hints=None, allowNone=1):   # 'default' parameter assigned a value\n        self.choices = choices\n        if choices and not default:\n            default.append(choices[0][1])                   # value of 'default' parameter modified\n        Argument.__init__(self, name, default, shortDesc, longDesc, hints, allowNone=allowNone)\n```\nThe recommended workaround is use a placeholder value. That is, define the function with a default of `default=None`, check if the parameter is `None` and then set the parameter to a list.\n\n\n## References\n* Effbot: [Default Parameter Values in Python](https://web.archive.org/web/20201112004749/http://effbot.org/zone/default-values.htm).\n* Python Language Reference: [Function definitions](http://docs.python.org/3/reference/compound_stmts.html#function-definitions).\n"},"properties":{"tags":["quality","reliability","correctness"],"description":"Modifying the default value of a parameter can lead to unexpected\n              results.","id":"py/modification-of-default-value","kind":"path-problem","name":"Modification of parameter with default","precision":"high","problem.severity":"error","sub-severity":"low"}},{"id":"py/not-named-cls","name":"py/not-named-cls","shortDescription":{"text":"First parameter of a class method is not named 'cls'"},"fullDescription":{"text":"By the PEP8 style guide, the first parameter of a class method should be named `cls`."},"defaultConfiguration":{"enabled":true,"level":"note"},"help":{"text":"# First parameter of a class method is not named 'cls'\nThe first parameter of a class method (including certain special methods such as `__new__`), or a method of a metaclass, should be named `cls`.\n\n\n## Recommendation\nEnsure that the first parameter of class methods is named `cls`, as recommended by the style guidelines in PEP 8.\n\n\n## Example\nIn the following example, the first parameter of the class method `make` is named `self` instead of `cls`.\n\n\n```python\nclass Entry(object):\n    @classmethod\n    def make(self):\n        return Entry()\n\n```\n\n## References\n* Python PEP 8: [Function and method arguments](http://www.python.org/dev/peps/pep-0008/#function-and-method-arguments).\n* Python Tutorial: [Classes](http://docs.python.org/2/tutorial/classes.html).\n* Python Docs: [classmethod](https://docs.python.org/3/library/functions.html#classmethod).\n","markdown":"# First parameter of a class method is not named 'cls'\nThe first parameter of a class method (including certain special methods such as `__new__`), or a method of a metaclass, should be named `cls`.\n\n\n## Recommendation\nEnsure that the first parameter of class methods is named `cls`, as recommended by the style guidelines in PEP 8.\n\n\n## Example\nIn the following example, the first parameter of the class method `make` is named `self` instead of `cls`.\n\n\n```python\nclass Entry(object):\n    @classmethod\n    def make(self):\n        return Entry()\n\n```\n\n## References\n* Python PEP 8: [Function and method arguments](http://www.python.org/dev/peps/pep-0008/#function-and-method-arguments).\n* Python Tutorial: [Classes](http://docs.python.org/2/tutorial/classes.html).\n* Python Docs: [classmethod](https://docs.python.org/3/library/functions.html#classmethod).\n"},"properties":{"tags":["maintainability","readability","convention","quality"],"description":"By the PEP8 style guide, the first parameter of a class method should be named `cls`.","id":"py/not-named-cls","kind":"problem","name":"First parameter of a class method is not named 'cls'","precision":"high","problem.severity":"recommendation","sub-severity":"high"}},{"id":"py/inheritance/signature-mismatch","name":"py/inheritance/signature-mismatch","shortDescription":{"text":"Signature mismatch in overriding method"},"fullDescription":{"text":"Overriding a method without ensuring that both methods accept the same number and type of parameters has the potential to cause an error when there is a mismatch."},"defaultConfiguration":{"enabled":true,"level":"warning"},"help":{"text":"# Signature mismatch in overriding method\nThere are one (or more) legal parameters for an overridden method that are not legal for an overriding method. This will cause an error when the overriding method is called with a number of parameters that is legal for the overridden method. This violates the Liskov substitution principle.\n\n\n## Recommendation\nEnsure that the overriding method accepts all the parameters that are legal for overridden method.\n\n\n## Example\nIn this example there is a mismatch between the legal parameters for the base class method `(self, source, filename, symbol)` and the extension method `(self, source)`. The extension method can be used to override the base method as long as values are not specified for the `filename` and `symbol` parameters. If the extension method was passed the additional parameters accepted by the base method then an error would occur.\n\n\n```python\n\n# Base class method\ndef runsource(self, source, filename=\"<input>\", symbol=\"single\"):\n    ... # Definition\n    \n    \n# Extend base class method\ndef runsource(self, source):\n    ... # Definition\n```\nThe extension method should be updated to support the `filename` and `symbol` parameters supported by the overridden method.\n\n\n## References\n* Wikipedia: [Liskov Substitution Principle](http://en.wikipedia.org/wiki/Liskov_substitution_principle), [Method overriding](http://en.wikipedia.org/wiki/Method_overriding#Python).\n","markdown":"# Signature mismatch in overriding method\nThere are one (or more) legal parameters for an overridden method that are not legal for an overriding method. This will cause an error when the overriding method is called with a number of parameters that is legal for the overridden method. This violates the Liskov substitution principle.\n\n\n## Recommendation\nEnsure that the overriding method accepts all the parameters that are legal for overridden method.\n\n\n## Example\nIn this example there is a mismatch between the legal parameters for the base class method `(self, source, filename, symbol)` and the extension method `(self, source)`. The extension method can be used to override the base method as long as values are not specified for the `filename` and `symbol` parameters. If the extension method was passed the additional parameters accepted by the base method then an error would occur.\n\n\n```python\n\n# Base class method\ndef runsource(self, source, filename=\"<input>\", symbol=\"single\"):\n    ... # Definition\n    \n    \n# Extend base class method\ndef runsource(self, source):\n    ... # Definition\n```\nThe extension method should be updated to support the `filename` and `symbol` parameters supported by the overridden method.\n\n\n## References\n* Wikipedia: [Liskov Substitution Principle](http://en.wikipedia.org/wiki/Liskov_substitution_principle), [Method overriding](http://en.wikipedia.org/wiki/Method_overriding#Python).\n"},"properties":{"tags":["quality","reliability","correctness"],"description":"Overriding a method without ensuring that both methods accept the same\n              number and type of parameters has the potential to cause an error when there is a mismatch.","id":"py/inheritance/signature-mismatch","kind":"problem","name":"Signature mismatch in overriding method","precision":"very-high","problem.severity":"warning","sub-severity":"high"}},{"id":"py/procedure-return-value-used","name":"py/procedure-return-value-used","shortDescription":{"text":"Use of the return value of a procedure"},"fullDescription":{"text":"The return value of a procedure (a function that does not return a value) is used. This is confusing to the reader as the value (None) has no meaning."},"defaultConfiguration":{"enabled":true,"level":"warning"},"help":{"text":"# Use of the return value of a procedure\nAll functions in Python return a value. If a function has no `return` statements or none of the `return` statements return a value then the function will return `None`. However, this value has no meaning and should be ignored.\n\nUsing the return value of such a 'procedure' is confusing to the reader as it suggests that the value is significant.\n\n\n## Recommendation\nDo not use the return value of a procedure; replace `x = proc()` with `proc()` and replace any use of the value with `None`.\n\n\n## Example\nIn this example, the `my_print` function is a procedure as it returns no value of any meaning. Using the return value is misleading in subsequent code.\n\n\n```python\n\nimport sys\n\ndef my_print(*args):\n    print (args)\n\ndef main():\n    err = my_print(sys.argv)\n    if err:\n        sys.exit(err)\n\n\n#FIXED VERSION\ndef main():\n    my_print(sys.argv)\n    #The rest of the code can be removed as None as always false\n\n\n```\n\n## References\n* Python Library Reference: [None](http://docs.python.org/library/constants.html#None).\n","markdown":"# Use of the return value of a procedure\nAll functions in Python return a value. If a function has no `return` statements or none of the `return` statements return a value then the function will return `None`. However, this value has no meaning and should be ignored.\n\nUsing the return value of such a 'procedure' is confusing to the reader as it suggests that the value is significant.\n\n\n## Recommendation\nDo not use the return value of a procedure; replace `x = proc()` with `proc()` and replace any use of the value with `None`.\n\n\n## Example\nIn this example, the `my_print` function is a procedure as it returns no value of any meaning. Using the return value is misleading in subsequent code.\n\n\n```python\n\nimport sys\n\ndef my_print(*args):\n    print (args)\n\ndef main():\n    err = my_print(sys.argv)\n    if err:\n        sys.exit(err)\n\n\n#FIXED VERSION\ndef main():\n    my_print(sys.argv)\n    #The rest of the code can be removed as None as always false\n\n\n```\n\n## References\n* Python Library Reference: [None](http://docs.python.org/library/constants.html#None).\n"},"properties":{"tags":["quality","maintainability","readability"],"description":"The return value of a procedure (a function that does not return a value) is used. This is confusing to the reader as the value (None) has no meaning.","id":"py/procedure-return-value-used","kind":"problem","name":"Use of the return value of a procedure","precision":"high","problem.severity":"warning","sub-severity":"low"}},{"id":"py/not-named-self","name":"py/not-named-self","shortDescription":{"text":"First parameter of a method is not named 'self'"},"fullDescription":{"text":"By the PEP8 style guide, the first parameter of a normal method should be named `self`."},"defaultConfiguration":{"enabled":true,"level":"note"},"help":{"text":"# First parameter of a method is not named 'self'\nNormal methods should have at least one parameter and the first parameter should be called `self`.\n\n\n## Recommendation\nEnsure that the first parameter of a normal method is named `self`, as recommended by the style guidelines in PEP 8.\n\nIf a `self` parameter is unneeded, the method should be decorated with `staticmethod`, or moved out of the class as a regular function.\n\n\n## Example\nIn the following cases, the first argument of `Point.__init__` is named `val` instead; whereas in `Point2.__init__` it is correctly named `self`.\n\n\n```python\nclass Point:\n    def __init__(val, x, y):  # BAD: first parameter is mis-named 'val'\n        val._x = x\n        val._y = y\n\nclass Point2:\n    def __init__(self, x, y):  # GOOD: first parameter is correctly named 'self'\n        self._x = x\n        self._y = y\n```\n\n## References\n* Python PEP 8: [Function and method arguments](http://www.python.org/dev/peps/pep-0008/#function-and-method-arguments).\n* Python Tutorial: [Classes](http://docs.python.org/2/tutorial/classes.html).\n* Python Docs: [staticmethod](https://docs.python.org/3/library/functions.html#staticmethod).\n","markdown":"# First parameter of a method is not named 'self'\nNormal methods should have at least one parameter and the first parameter should be called `self`.\n\n\n## Recommendation\nEnsure that the first parameter of a normal method is named `self`, as recommended by the style guidelines in PEP 8.\n\nIf a `self` parameter is unneeded, the method should be decorated with `staticmethod`, or moved out of the class as a regular function.\n\n\n## Example\nIn the following cases, the first argument of `Point.__init__` is named `val` instead; whereas in `Point2.__init__` it is correctly named `self`.\n\n\n```python\nclass Point:\n    def __init__(val, x, y):  # BAD: first parameter is mis-named 'val'\n        val._x = x\n        val._y = y\n\nclass Point2:\n    def __init__(self, x, y):  # GOOD: first parameter is correctly named 'self'\n        self._x = x\n        self._y = y\n```\n\n## References\n* Python PEP 8: [Function and method arguments](http://www.python.org/dev/peps/pep-0008/#function-and-method-arguments).\n* Python Tutorial: [Classes](http://docs.python.org/2/tutorial/classes.html).\n* Python Docs: [staticmethod](https://docs.python.org/3/library/functions.html#staticmethod).\n"},"properties":{"tags":["maintainability","readability","convention","quality"],"description":"By the PEP8 style guide, the first parameter of a normal method should be named `self`.","id":"py/not-named-self","kind":"problem","name":"First parameter of a method is not named 'self'","precision":"very-high","problem.severity":"recommendation","sub-severity":"high"}},{"id":"py/special-method-wrong-signature","name":"py/special-method-wrong-signature","shortDescription":{"text":"Special method has incorrect signature"},"fullDescription":{"text":"Special method has incorrect signature"},"defaultConfiguration":{"enabled":true,"level":"error"},"help":{"text":"# Special method has incorrect signature\nSpecial methods (sometimes also called magic methods) are how user defined classes interact with the Python virtual machine. For example, for a class to support addition it must implement the `__add__` and `__radd__` special methods. When the expression `a + b` is evaluated the Python virtual machine will call `type(a).__add__(a, b)` and if that is not implemented it will call `type(b).__radd__(b, a)`.\n\nSince these special methods are always called by the virtual machine with a fixed number of parameters, if the method is implemented with a different number of parameters it will fail at runtime with a `TypeError`.\n\n\n## Recommendation\nEnsure that the method has the correct number of parameters\n\n\n## Example\nIn the example the `__str__` method has an extra parameter. This means that if `str(p)` is called when `p` is a `Point` then it will fail with a `TypeError`.\n\n\n```python\n#-*- coding: utf-8 -*-\n\nclass Point(object):\n\n    def __init__(self, x, y):\n        self.x\n        self.y\n\n    def __add__(self, other):\n        if not isinstance(other, Point):\n            return NotImplemented\n        return Point(self.x + other.x, self.y + other.y)\n\n    def __str__(self, style): #Spurious extra parameter\n        if style == 'polar':\n            u\"%s @ %s\\u00b0\" % (abs(self), self.angle())\n        else:\n            return \"[%s, %s]\" % (self.x, self.y)\n\n```\n\n## References\n* Python Language Reference: [Special Method Names](http://docs.python.org/dev/reference/datamodel.html#special-method-names).\n","markdown":"# Special method has incorrect signature\nSpecial methods (sometimes also called magic methods) are how user defined classes interact with the Python virtual machine. For example, for a class to support addition it must implement the `__add__` and `__radd__` special methods. When the expression `a + b` is evaluated the Python virtual machine will call `type(a).__add__(a, b)` and if that is not implemented it will call `type(b).__radd__(b, a)`.\n\nSince these special methods are always called by the virtual machine with a fixed number of parameters, if the method is implemented with a different number of parameters it will fail at runtime with a `TypeError`.\n\n\n## Recommendation\nEnsure that the method has the correct number of parameters\n\n\n## Example\nIn the example the `__str__` method has an extra parameter. This means that if `str(p)` is called when `p` is a `Point` then it will fail with a `TypeError`.\n\n\n```python\n#-*- coding: utf-8 -*-\n\nclass Point(object):\n\n    def __init__(self, x, y):\n        self.x\n        self.y\n\n    def __add__(self, other):\n        if not isinstance(other, Point):\n            return NotImplemented\n        return Point(self.x + other.x, self.y + other.y)\n\n    def __str__(self, style): #Spurious extra parameter\n        if style == 'polar':\n            u\"%s @ %s\\u00b0\" % (abs(self), self.angle())\n        else:\n            return \"[%s, %s]\" % (self.x, self.y)\n\n```\n\n## References\n* Python Language Reference: [Special Method Names](http://docs.python.org/dev/reference/datamodel.html#special-method-names).\n"},"properties":{"tags":["reliability","correctness","quality"],"description":"Special method has incorrect signature","id":"py/special-method-wrong-signature","kind":"problem","name":"Special method has incorrect signature","precision":"high","problem.severity":"error","sub-severity":"low"}},{"id":"py/unexpected-raise-in-special-method","name":"py/unexpected-raise-in-special-method","shortDescription":{"text":"Non-standard exception raised in special method"},"fullDescription":{"text":"Raising a non-standard exception in a special method alters the expected interface of that method."},"defaultConfiguration":{"enabled":true,"level":"note"},"help":{"text":"# Non-standard exception raised in special method\nUser-defined classes interact with the Python virtual machine via special methods (also called \"magic methods\"). For example, for a class to support addition it must implement the `__add__` and `__radd__` special methods. When the expression `a + b` is evaluated, the Python virtual machine will call `type(a).__add__(a, b)`, and if that is not implemented it will call `type(b).__radd__(b, a)`.\n\nSince the virtual machine calls these special methods for common expressions, users of the class will expect these operations to raise standard exceptions. For example, users would expect that the expression `a.b` may raise an `AttributeError` if the object `a` does not have an attribute `b`. If a `KeyError` were raised instead, then this would be unexpected and may break code that expected an `AttributeError`, but not a `KeyError`.\n\nTherefore, if a method is unable to perform the expected operation then its response should conform to the standard protocol, described below.\n\n* Attribute access, `a.b` (`__getattr__`): Raise `AttributeError`.\n* Arithmetic operations, `a + b` (`__add__`): Do not raise an exception, return `NotImplemented` instead.\n* Indexing, `a[b]` (`__getitem__`): Raise `KeyError` or `IndexError`.\n* Hashing, `hash(a)` (`__hash__`): Should not raise an exception. Use `__hash__ = None` to indicate that an object is unhashable rather than raising an exception.\n* Equality methods, `a == b` (`__eq__`): Never raise an exception, always return `True` or `False`.\n* Ordering comparison methods, `a < b` (`__lt__`): Raise a `TypeError` if the objects cannot be ordered.\n* Most others: If the operation is never supported, the method often does not need to be implemented at all; otherwise a `TypeError` should be raised.\n\n## Recommendation\nIf the method always raises as exception, then if it is intended to be an abstract method, the `@abstractmethod` decorator should be used. Otherwise, ensure that the method raises an exception of the correct type, or remove the method if the operation does not need to be supported.\n\n\n## Example\nIn the following example, the `__add__` method of `A` raises a `TypeError` if `other` is of the wrong type. However, it should return `NotImplemented` instead of rising an exception, to allow other classes to support adding to `A`. This is demonstrated in the class `B`.\n\n\n```python\nclass A:\n    def __init__(self, a):\n        self.a = a \n\n    def __add__(self, other):\n        # BAD: Should return NotImplemented instead of raising\n        if not isinstance(other,A):\n            raise TypeError(f\"Cannot add A to {other.__class__}\")\n        return A(self.a + other.a)\n\nclass B:\n    def __init__(self, a):\n        self.a = a \n\n    def __add__(self, other):\n        # GOOD: Returning NotImplemented allows for the operation to fallback to other implementations to allow other classes to support adding to B.\n        if not isinstance(other,B):\n            return NotImplemented\n        return B(self.a + other.a)\n    \n\n        \n\n```\nIn the following example, the `__getitem__` method of `C` raises a `ValueError`, rather than a `KeyError` or `IndexError` as expected.\n\n\n```python\nclass C:\n    def __getitem__(self, idx):\n        if self.idx < 0:\n            # BAD: Should raise a KeyError or IndexError instead.\n            raise ValueError(\"Invalid index\")\n        return self.lookup(idx)\n \n\n```\nIn the following example, the class `__hash__` method of `D` raises `NotImplementedError`. This causes `D` to be incorrectly identified as hashable by `isinstance(obj, collections.abc.Hashable)`; so the correct way to make a class unhashable is to set `__hash__ = None`.\n\n\n```python\nclass D:\n    def __hash__(self):\n        # BAD: Use `__hash__ = None` instead.\n        raise NotImplementedError(f\"{self.__class__} is unhashable.\")\n```\n\n## References\n* Python Language Reference: [Special Method Names](http://docs.python.org/dev/reference/datamodel.html#special-method-names).\n* Python Library Reference: [Exceptions](https://docs.python.org/3/library/exceptions.html).\n","markdown":"# Non-standard exception raised in special method\nUser-defined classes interact with the Python virtual machine via special methods (also called \"magic methods\"). For example, for a class to support addition it must implement the `__add__` and `__radd__` special methods. When the expression `a + b` is evaluated, the Python virtual machine will call `type(a).__add__(a, b)`, and if that is not implemented it will call `type(b).__radd__(b, a)`.\n\nSince the virtual machine calls these special methods for common expressions, users of the class will expect these operations to raise standard exceptions. For example, users would expect that the expression `a.b` may raise an `AttributeError` if the object `a` does not have an attribute `b`. If a `KeyError` were raised instead, then this would be unexpected and may break code that expected an `AttributeError`, but not a `KeyError`.\n\nTherefore, if a method is unable to perform the expected operation then its response should conform to the standard protocol, described below.\n\n* Attribute access, `a.b` (`__getattr__`): Raise `AttributeError`.\n* Arithmetic operations, `a + b` (`__add__`): Do not raise an exception, return `NotImplemented` instead.\n* Indexing, `a[b]` (`__getitem__`): Raise `KeyError` or `IndexError`.\n* Hashing, `hash(a)` (`__hash__`): Should not raise an exception. Use `__hash__ = None` to indicate that an object is unhashable rather than raising an exception.\n* Equality methods, `a == b` (`__eq__`): Never raise an exception, always return `True` or `False`.\n* Ordering comparison methods, `a < b` (`__lt__`): Raise a `TypeError` if the objects cannot be ordered.\n* Most others: If the operation is never supported, the method often does not need to be implemented at all; otherwise a `TypeError` should be raised.\n\n## Recommendation\nIf the method always raises as exception, then if it is intended to be an abstract method, the `@abstractmethod` decorator should be used. Otherwise, ensure that the method raises an exception of the correct type, or remove the method if the operation does not need to be supported.\n\n\n## Example\nIn the following example, the `__add__` method of `A` raises a `TypeError` if `other` is of the wrong type. However, it should return `NotImplemented` instead of rising an exception, to allow other classes to support adding to `A`. This is demonstrated in the class `B`.\n\n\n```python\nclass A:\n    def __init__(self, a):\n        self.a = a \n\n    def __add__(self, other):\n        # BAD: Should return NotImplemented instead of raising\n        if not isinstance(other,A):\n            raise TypeError(f\"Cannot add A to {other.__class__}\")\n        return A(self.a + other.a)\n\nclass B:\n    def __init__(self, a):\n        self.a = a \n\n    def __add__(self, other):\n        # GOOD: Returning NotImplemented allows for the operation to fallback to other implementations to allow other classes to support adding to B.\n        if not isinstance(other,B):\n            return NotImplemented\n        return B(self.a + other.a)\n    \n\n        \n\n```\nIn the following example, the `__getitem__` method of `C` raises a `ValueError`, rather than a `KeyError` or `IndexError` as expected.\n\n\n```python\nclass C:\n    def __getitem__(self, idx):\n        if self.idx < 0:\n            # BAD: Should raise a KeyError or IndexError instead.\n            raise ValueError(\"Invalid index\")\n        return self.lookup(idx)\n \n\n```\nIn the following example, the class `__hash__` method of `D` raises `NotImplementedError`. This causes `D` to be incorrectly identified as hashable by `isinstance(obj, collections.abc.Hashable)`; so the correct way to make a class unhashable is to set `__hash__ = None`.\n\n\n```python\nclass D:\n    def __hash__(self):\n        # BAD: Use `__hash__ = None` instead.\n        raise NotImplementedError(f\"{self.__class__} is unhashable.\")\n```\n\n## References\n* Python Language Reference: [Special Method Names](http://docs.python.org/dev/reference/datamodel.html#special-method-names).\n* Python Library Reference: [Exceptions](https://docs.python.org/3/library/exceptions.html).\n"},"properties":{"tags":["quality","reliability","error-handling"],"description":"Raising a non-standard exception in a special method alters the expected interface of that method.","id":"py/unexpected-raise-in-special-method","kind":"problem","name":"Non-standard exception raised in special method","precision":"high","problem.severity":"recommendation","sub-severity":"high"}},{"id":"py/explicit-return-in-init","name":"py/explicit-return-in-init","shortDescription":{"text":"`__init__` method returns a value"},"fullDescription":{"text":"Explicitly returning a value from an `__init__` method will raise a TypeError."},"defaultConfiguration":{"enabled":true,"level":"error"},"help":{"text":"# `__init__` method returns a value\nThe `__init__` method of a class is used to initialize new objects, not create them. As such, it should not return any value. Returning `None` is correct in the sense that no runtime error will occur, but it suggests that the returned value is meaningful, which it is not.\n\n\n## Recommendation\nConvert the `return expr` statement to a plain `return` statement, or omit it altogether if it is at the end of the method.\n\n\n## Example\nIn this example, the `__init__` method attempts to return the newly created object. This is an error and the return method should be removed.\n\n\n```python\nclass ExplicitReturnInInit(object):\n    def __init__(self, i):\n        self.i = i\n        return self\n```\n\n## References\n* Python: [The __init__ method](http://docs.python.org/2.7/reference/datamodel.html#object.__init__).\n","markdown":"# `__init__` method returns a value\nThe `__init__` method of a class is used to initialize new objects, not create them. As such, it should not return any value. Returning `None` is correct in the sense that no runtime error will occur, but it suggests that the returned value is meaningful, which it is not.\n\n\n## Recommendation\nConvert the `return expr` statement to a plain `return` statement, or omit it altogether if it is at the end of the method.\n\n\n## Example\nIn this example, the `__init__` method attempts to return the newly created object. This is an error and the return method should be removed.\n\n\n```python\nclass ExplicitReturnInInit(object):\n    def __init__(self, i):\n        self.i = i\n        return self\n```\n\n## References\n* Python: [The __init__ method](http://docs.python.org/2.7/reference/datamodel.html#object.__init__).\n"},"properties":{"tags":["quality","reliability","correctness"],"description":"Explicitly returning a value from an `__init__` method will raise a TypeError.","id":"py/explicit-return-in-init","kind":"problem","name":"`__init__` method returns a value","precision":"very-high","problem.severity":"error","sub-severity":"low"}},{"id":"py/init-method-is-generator","name":"py/init-method-is-generator","shortDescription":{"text":"`__init__` method is a generator"},"fullDescription":{"text":"`__init__` method is a generator."},"defaultConfiguration":{"enabled":true,"level":"error"},"help":{"text":"# `__init__` method is a generator\nThe `__init__` method of a class is used to initialize new objects, not create them. As such, it should not return any value. By including a `yield` expression in the method turns it into a generator method. On calling it will return a generator resulting in a runtime error.\n\n\n## Recommendation\nThe presence of a `yield` expression in an `__init__` method suggests a logical error, so it is not possible to suggest a general fix.\n\n\n## Example\nIn this example the `__init__` method contains a yield expression. This is not logical in the context of an initializer.\n\n\n```python\nclass InitIsGenerator(object):\n    def __init__(self, i):\n        yield i\n```\n\n## References\n* Python: [The __init__ method](http://docs.python.org/3/reference/datamodel.html#object.__init__).\n","markdown":"# `__init__` method is a generator\nThe `__init__` method of a class is used to initialize new objects, not create them. As such, it should not return any value. By including a `yield` expression in the method turns it into a generator method. On calling it will return a generator resulting in a runtime error.\n\n\n## Recommendation\nThe presence of a `yield` expression in an `__init__` method suggests a logical error, so it is not possible to suggest a general fix.\n\n\n## Example\nIn this example the `__init__` method contains a yield expression. This is not logical in the context of an initializer.\n\n\n```python\nclass InitIsGenerator(object):\n    def __init__(self, i):\n        yield i\n```\n\n## References\n* Python: [The __init__ method](http://docs.python.org/3/reference/datamodel.html#object.__init__).\n"},"properties":{"tags":["quality","reliability","correctness"],"description":"`__init__` method is a generator.","id":"py/init-method-is-generator","kind":"problem","name":"`__init__` method is a generator","precision":"very-high","problem.severity":"error","sub-severity":"low"}},{"id":"py/inheritance/incorrect-overridden-signature","name":"py/inheritance/incorrect-overridden-signature","shortDescription":{"text":"Mismatch between signature and use of an overridden method"},"fullDescription":{"text":"Method has a signature that differs from both the signature of its overriding methods and the arguments with which it is called, and if it were called, would be likely to cause an error."},"defaultConfiguration":{"enabled":true,"level":"note"},"help":{"text":"# Mismatch between signature and use of an overridden method\nThere is a call to the overriding method, and potentially the overridden method, with arguments that are not legal for the overridden method. This will cause an error if the overridden method is called and is a violation of the Liskov substitution principle.\n\n\n## Recommendation\nEnsure that the overridden method accepts all the parameters that are legal for overriding method(s).\n\n\n## Example\nIn this example there is a mismatch between the legal parameters for the base class method `(self, source, filename)` and the extension method `(self, source)`. Since there is a call that uses the signature of the extension method then it can be inferred that the base signature is erroneous and should be updated to match that of the extension method.\n\n\n```python\n\nclass BaseClass(object):\n\n    def run(self, source, filename, symbol=\"single\"):\n        ... # Definition\n\n    def load_and_run(self, filename):\n        source = self.load(filename)\n        self.run(source) # Matches signature in derived class, but not in this class.\n\nclass DerivedClass(BaseClass):\n\n    def run(self, source):\n        ... # Definition\n\n```\nThe base method should be updated to either remove the `filename` parameters, or add a default value for it.\n\n\n## References\n* Wikipedia: [Liskov Substitution Principle](http://en.wikipedia.org/wiki/Liskov_substitution_principle), [Method overriding](http://en.wikipedia.org/wiki/Method_overriding#Python).\n","markdown":"# Mismatch between signature and use of an overridden method\nThere is a call to the overriding method, and potentially the overridden method, with arguments that are not legal for the overridden method. This will cause an error if the overridden method is called and is a violation of the Liskov substitution principle.\n\n\n## Recommendation\nEnsure that the overridden method accepts all the parameters that are legal for overriding method(s).\n\n\n## Example\nIn this example there is a mismatch between the legal parameters for the base class method `(self, source, filename)` and the extension method `(self, source)`. Since there is a call that uses the signature of the extension method then it can be inferred that the base signature is erroneous and should be updated to match that of the extension method.\n\n\n```python\n\nclass BaseClass(object):\n\n    def run(self, source, filename, symbol=\"single\"):\n        ... # Definition\n\n    def load_and_run(self, filename):\n        source = self.load(filename)\n        self.run(source) # Matches signature in derived class, but not in this class.\n\nclass DerivedClass(BaseClass):\n\n    def run(self, source):\n        ... # Definition\n\n```\nThe base method should be updated to either remove the `filename` parameters, or add a default value for it.\n\n\n## References\n* Wikipedia: [Liskov Substitution Principle](http://en.wikipedia.org/wiki/Liskov_substitution_principle), [Method overriding](http://en.wikipedia.org/wiki/Method_overriding#Python).\n"},"properties":{"tags":["quality","reliability","correctness"],"description":"Method has a signature that differs from both the signature of its overriding methods and\n              the arguments with which it is called, and if it were called, would be likely to cause an error.","id":"py/inheritance/incorrect-overridden-signature","kind":"problem","name":"Mismatch between signature and use of an overridden method","precision":"high","problem.severity":"recommendation","sub-severity":"high"}},{"id":"py/mixed-returns","name":"py/mixed-returns","shortDescription":{"text":"Explicit returns mixed with implicit (fall through) returns"},"fullDescription":{"text":"Mixing implicit and explicit returns indicates a likely error as implicit returns always return `None`."},"defaultConfiguration":{"enabled":true,"level":"note"},"help":{"text":"# Explicit returns mixed with implicit (fall through) returns\nWhen a function contains both explicit returns (`return value`) and implicit returns (where code falls off the end of a function), this often indicates that a return statement has been forgotten. It is best to return an explicit return value even when returning `None` because this makes it easier for other developers to read your code.\n\n\n## Recommendation\nAdd an explicit return at the end of the function.\n\n\n## Example\nIn the `check_state1` function, the developer probably did intend to use an implicit return value of `None` as this equates to `False`. However, the function in `check_state2` is easier to read.\n\n\n```python\n    def check_state1(state, interactive=True):\n        if not state['good'] or not state['bad']:\n            if (good or bad or skip or reset) and interactive:\n                return                                          # implicitly return None\n            if not state['good']:\n                raise util.Abort(_('cannot bisect (no known good revisions)'))\n            else:\n                raise util.Abort(_('cannot bisect (no known bad revisions)')) \n        return True  \t\t\t\t\t\t\t                              \n           \n    def check_state2(state, interactive=True):\n        if not state['good'] or not state['bad']:\n            if (good or bad or skip or reset) and interactive:\n                return False                                    # return an explicit value\n            if not state['good']:\n                raise util.Abort(_('cannot bisect (no known good revisions)'))\n            else:\n                raise util.Abort(_('cannot bisect (no known bad revisions)'))\n        return True\n\n```\n\n## References\n* Python Language Reference: [Function definitions](http://docs.python.org/3/reference/compound_stmts.html#function).\n","markdown":"# Explicit returns mixed with implicit (fall through) returns\nWhen a function contains both explicit returns (`return value`) and implicit returns (where code falls off the end of a function), this often indicates that a return statement has been forgotten. It is best to return an explicit return value even when returning `None` because this makes it easier for other developers to read your code.\n\n\n## Recommendation\nAdd an explicit return at the end of the function.\n\n\n## Example\nIn the `check_state1` function, the developer probably did intend to use an implicit return value of `None` as this equates to `False`. However, the function in `check_state2` is easier to read.\n\n\n```python\n    def check_state1(state, interactive=True):\n        if not state['good'] or not state['bad']:\n            if (good or bad or skip or reset) and interactive:\n                return                                          # implicitly return None\n            if not state['good']:\n                raise util.Abort(_('cannot bisect (no known good revisions)'))\n            else:\n                raise util.Abort(_('cannot bisect (no known bad revisions)')) \n        return True  \t\t\t\t\t\t\t                              \n           \n    def check_state2(state, interactive=True):\n        if not state['good'] or not state['bad']:\n            if (good or bad or skip or reset) and interactive:\n                return False                                    # return an explicit value\n            if not state['good']:\n                raise util.Abort(_('cannot bisect (no known good revisions)'))\n            else:\n                raise util.Abort(_('cannot bisect (no known bad revisions)'))\n        return True\n\n```\n\n## References\n* Python Language Reference: [Function definitions](http://docs.python.org/3/reference/compound_stmts.html#function).\n"},"properties":{"tags":["quality","reliability","correctness"],"description":"Mixing implicit and explicit returns indicates a likely error as implicit returns always return `None`.","id":"py/mixed-returns","kind":"problem","name":"Explicit returns mixed with implicit (fall through) returns","precision":"high","problem.severity":"recommendation","sub-severity":"high"}},{"id":"py/deprecated-slice-method","name":"py/deprecated-slice-method","shortDescription":{"text":"Deprecated slice method"},"fullDescription":{"text":"Defining special methods for slicing has been deprecated since Python 2.0."},"defaultConfiguration":{"enabled":true,"level":"warning"},"help":{"text":"# Deprecated slice method\nThe `__getslice__`, `__setslice__` and `__delslice__` methods have been deprecated since Python 2.0. In general, no class should implement these methods.\n\nThe only exceptions to this rule are classes that inherit from `list` and override `__getitem__`, `__setitem__` or `__delitem__`. Since `list` implements the slicing methods any class inheriting from `list` must implement the the slicing methods to ensure correct behavior of `__getitem__`, `__setitem__` and `__delitem__`. These exceptions to the rule will not be treated as violations.\n\n\n## Recommendation\nDelete the slicing method. Any functionality should be moved to the equivalent `__xxxitem__` method:\n\n* `__getslice__` should be replaced with `__getitem__`\n* `__setslice__` should be replaced with `__setitem__`\n* `__delslice__` should be replaced with `__delitem__`\n\n## References\n* Python Language Reference: [ Additional methods for emulation of sequence types](https://docs.python.org/2/reference/datamodel.html#additional-methods-for-emulation-of-sequence-types).\n","markdown":"# Deprecated slice method\nThe `__getslice__`, `__setslice__` and `__delslice__` methods have been deprecated since Python 2.0. In general, no class should implement these methods.\n\nThe only exceptions to this rule are classes that inherit from `list` and override `__getitem__`, `__setitem__` or `__delitem__`. Since `list` implements the slicing methods any class inheriting from `list` must implement the the slicing methods to ensure correct behavior of `__getitem__`, `__setitem__` and `__delitem__`. These exceptions to the rule will not be treated as violations.\n\n\n## Recommendation\nDelete the slicing method. Any functionality should be moved to the equivalent `__xxxitem__` method:\n\n* `__getslice__` should be replaced with `__getitem__`\n* `__setslice__` should be replaced with `__setitem__`\n* `__delslice__` should be replaced with `__delitem__`\n\n## References\n* Python Language Reference: [ Additional methods for emulation of sequence types](https://docs.python.org/2/reference/datamodel.html#additional-methods-for-emulation-of-sequence-types).\n"},"properties":{"tags":["maintainability"],"description":"Defining special methods for slicing has been deprecated since Python 2.0.","id":"py/deprecated-slice-method","kind":"problem","name":"Deprecated slice method","precision":"very-high","problem.severity":"warning","sub-severity":"high"}},{"id":"py/mixed-tuple-returns","name":"py/mixed-tuple-returns","shortDescription":{"text":"Returning tuples with varying lengths"},"fullDescription":{"text":"A function that potentially returns tuples of different lengths may indicate a problem."},"defaultConfiguration":{"enabled":true,"level":"note"},"help":{"text":"# Returning tuples with varying lengths\nA common pattern for functions returning multiple arguments is to return a single tuple containing said arguments. If the function has multiple return points, care must be taken to ensure that the tuples returned have the same length.\n\n\n## Recommendation\nEnsure that the function returns tuples of similar lengths.\n\n\n## Example\nIn this example, the `sum_length_product1` function simultaneously calculates the sum, length, and product of the values in the given list. For empty lists, however, the returned tuple only contains the sum and length of the list. In `sum_length_product2` this error has been corrected.\n\n\n```python\ndef sum_length_product1(l):\n    if l == []:\n        return 0, 0                              # this tuple has the wrong length\n    else:\n        val = l[0]\n        restsum, restlength, restproduct = sum_length_product1(l[1:])\n        return restsum + val, restlength + 1, restproduct * val\n\ndef sum_length_product2(l):\n    if l == []:\n        return 0, 0, 1                           # this tuple has the correct length\n    else:\n        val = l[0]\n        restsum, restlength, restproduct = sum_length_product2(l[1:])\n        return restsum + val, restlength + 1, restproduct * val\n\n```\n\n## References\n* Python Language Reference: [Function definitions](http://docs.python.org/2/reference/compound_stmts.html#function).\n","markdown":"# Returning tuples with varying lengths\nA common pattern for functions returning multiple arguments is to return a single tuple containing said arguments. If the function has multiple return points, care must be taken to ensure that the tuples returned have the same length.\n\n\n## Recommendation\nEnsure that the function returns tuples of similar lengths.\n\n\n## Example\nIn this example, the `sum_length_product1` function simultaneously calculates the sum, length, and product of the values in the given list. For empty lists, however, the returned tuple only contains the sum and length of the list. In `sum_length_product2` this error has been corrected.\n\n\n```python\ndef sum_length_product1(l):\n    if l == []:\n        return 0, 0                              # this tuple has the wrong length\n    else:\n        val = l[0]\n        restsum, restlength, restproduct = sum_length_product1(l[1:])\n        return restsum + val, restlength + 1, restproduct * val\n\ndef sum_length_product2(l):\n    if l == []:\n        return 0, 0, 1                           # this tuple has the correct length\n    else:\n        val = l[0]\n        restsum, restlength, restproduct = sum_length_product2(l[1:])\n        return restsum + val, restlength + 1, restproduct * val\n\n```\n\n## References\n* Python Language Reference: [Function definitions](http://docs.python.org/2/reference/compound_stmts.html#function).\n"},"properties":{"tags":["quality","reliability","correctness"],"description":"A function that potentially returns tuples of different lengths may indicate a problem.","id":"py/mixed-tuple-returns","kind":"problem","name":"Returning tuples with varying lengths","precision":"high","problem.severity":"recommendation","sub-severity":"high"}},{"id":"py/iter-returns-non-iterator","name":"py/iter-returns-non-iterator","shortDescription":{"text":"`__iter__` method returns a non-iterator"},"fullDescription":{"text":"The `__iter__` method returns a non-iterator which, if used in a 'for' loop, would raise a 'TypeError'."},"defaultConfiguration":{"enabled":true,"level":"error"},"help":{"text":"# `__iter__` method returns a non-iterator\nThe `__iter__` method of a class should always return an iterator.\n\nIterators must implement both `__next__` and `__iter__` for Python 3, or both `next` and `__iter__` for Python 2. The `__iter__` method of the iterator must return the iterator object itself.\n\nIteration in Python relies on this behavior and attempting to iterate over an instance of a class with an incorrect `__iter__` method can raise a `TypeError`.\n\n\n## Recommendation\nMake sure the value returned by `__iter__` implements the full iterator protocol.\n\n\n## Example\nIn this example, we have implemented our own version of `range`, extending the normal functionality with the ability to skip some elements by using the `skip` method. However, the iterator `MyRangeIterator` does not fully implement the iterator protocol (namely it is missing `__iter__`).\n\nIterating over the elements in the range seems to work on the surface, for example the code `x = sum(my_range)` gives the expected result. However, if we run `sum(iter(my_range))` we get a `TypeError: 'MyRangeIterator' object is not iterable`.\n\nIf we try to skip some elements using our custom method, for example `y = sum(my_range.skip({6,9}))`, this also raises a `TypeError`.\n\nThe fix is to implement the `__iter__` method in `MyRangeIterator`.\n\n\n```python\nclass MyRange(object):\n    def __init__(self, low, high):\n        self.low = low\n        self.high = high\n\n    def __iter__(self):\n        return MyRangeIterator(self.low, self.high)\n\n    def skip(self, to_skip):\n        return MyRangeIterator(self.low, self.high, to_skip)\n\nclass MyRangeIterator(object):\n    def __init__(self, low, high, skip=None):\n        self.current = low\n        self.high = high\n        self.skip = skip\n\n    def __next__(self):\n        if self.current >= self.high:\n            raise StopIteration\n        to_return = self.current\n        self.current += 1\n        if self.skip and to_return in self.skip:\n            return self.__next__()\n        return to_return\n\n    # Problem is fixed by uncommenting these lines\n    # def __iter__(self):\n    #     return self\n\nmy_range = MyRange(0,10)\nx = sum(my_range) # x = 45\ny = sum(my_range.skip({6,9})) # TypeError: 'MyRangeIterator' object is not iterable\n\n```\n\n## References\n* Python Language Reference: [object.__iter__](https://docs.python.org/3/reference/datamodel.html#object.__iter__).\n* Python Standard Library: [Iterator Types](https://docs.python.org/3/library/stdtypes.html#typeiter).\n","markdown":"# `__iter__` method returns a non-iterator\nThe `__iter__` method of a class should always return an iterator.\n\nIterators must implement both `__next__` and `__iter__` for Python 3, or both `next` and `__iter__` for Python 2. The `__iter__` method of the iterator must return the iterator object itself.\n\nIteration in Python relies on this behavior and attempting to iterate over an instance of a class with an incorrect `__iter__` method can raise a `TypeError`.\n\n\n## Recommendation\nMake sure the value returned by `__iter__` implements the full iterator protocol.\n\n\n## Example\nIn this example, we have implemented our own version of `range`, extending the normal functionality with the ability to skip some elements by using the `skip` method. However, the iterator `MyRangeIterator` does not fully implement the iterator protocol (namely it is missing `__iter__`).\n\nIterating over the elements in the range seems to work on the surface, for example the code `x = sum(my_range)` gives the expected result. However, if we run `sum(iter(my_range))` we get a `TypeError: 'MyRangeIterator' object is not iterable`.\n\nIf we try to skip some elements using our custom method, for example `y = sum(my_range.skip({6,9}))`, this also raises a `TypeError`.\n\nThe fix is to implement the `__iter__` method in `MyRangeIterator`.\n\n\n```python\nclass MyRange(object):\n    def __init__(self, low, high):\n        self.low = low\n        self.high = high\n\n    def __iter__(self):\n        return MyRangeIterator(self.low, self.high)\n\n    def skip(self, to_skip):\n        return MyRangeIterator(self.low, self.high, to_skip)\n\nclass MyRangeIterator(object):\n    def __init__(self, low, high, skip=None):\n        self.current = low\n        self.high = high\n        self.skip = skip\n\n    def __next__(self):\n        if self.current >= self.high:\n            raise StopIteration\n        to_return = self.current\n        self.current += 1\n        if self.skip and to_return in self.skip:\n            return self.__next__()\n        return to_return\n\n    # Problem is fixed by uncommenting these lines\n    # def __iter__(self):\n    #     return self\n\nmy_range = MyRange(0,10)\nx = sum(my_range) # x = 45\ny = sum(my_range.skip({6,9})) # TypeError: 'MyRangeIterator' object is not iterable\n\n```\n\n## References\n* Python Language Reference: [object.__iter__](https://docs.python.org/3/reference/datamodel.html#object.__iter__).\n* Python Standard Library: [Iterator Types](https://docs.python.org/3/library/stdtypes.html#typeiter).\n"},"properties":{"tags":["quality","reliability","correctness"],"description":"The `__iter__` method returns a non-iterator which, if used in a 'for' loop, would raise a 'TypeError'.","id":"py/iter-returns-non-iterator","kind":"problem","name":"`__iter__` method returns a non-iterator","precision":"high","problem.severity":"error","sub-severity":"low"}},{"id":"py/pythagorean","name":"py/pythagorean","shortDescription":{"text":"Pythagorean calculation with sub-optimal numerics"},"fullDescription":{"text":"Calculating the length of the hypotenuse using the standard formula may lead to overflow."},"defaultConfiguration":{"enabled":true,"level":"warning"},"help":{"text":"# Pythagorean calculation with sub-optimal numerics\nCalculating the length of the hypotenuse using the standard formula `c = sqrt(a**2 + b**2)` may lead to overflow if the two other sides are both very large. Even though `c` will not be much bigger than `max(a, b)`, either `a**2` or `b**2` (or both) will. Thus, the calculation could overflow, even though the result is well within representable range.\n\n\n## Recommendation\nRather than `sqrt(a**2 + b**2)`, use the built-in function `hypot(a,b)` from the `math` library.\n\n\n## Example\nThe following code shows two different ways of computing the hypotenuse. The first is a direct rewrite of the Pythagorean theorem, the second uses the built-in function.\n\n\n```python\n# We know that a^2 + b^2 = c^2, and wish to use this to compute c\nfrom math import sqrt, hypot\n\na = 3e154 # a^2 > 1e308\nb = 4e154 # b^2 > 1e308\n# with these, c = 5e154 which is less that 1e308\n\ndef longSideDirect():\n    return sqrt(a**2 + b**2) # this will overflow\n\ndef longSideBuiltin():\n    return hypot(a, b) # better to use built-in function\n```\n\n## References\n* Python Language Reference: [The hypot function](https://docs.python.org/library/math.html#math.hypot)\n* Wikipedia: [Hypot](https://en.wikipedia.org/wiki/Hypot).\n","markdown":"# Pythagorean calculation with sub-optimal numerics\nCalculating the length of the hypotenuse using the standard formula `c = sqrt(a**2 + b**2)` may lead to overflow if the two other sides are both very large. Even though `c` will not be much bigger than `max(a, b)`, either `a**2` or `b**2` (or both) will. Thus, the calculation could overflow, even though the result is well within representable range.\n\n\n## Recommendation\nRather than `sqrt(a**2 + b**2)`, use the built-in function `hypot(a,b)` from the `math` library.\n\n\n## Example\nThe following code shows two different ways of computing the hypotenuse. The first is a direct rewrite of the Pythagorean theorem, the second uses the built-in function.\n\n\n```python\n# We know that a^2 + b^2 = c^2, and wish to use this to compute c\nfrom math import sqrt, hypot\n\na = 3e154 # a^2 > 1e308\nb = 4e154 # b^2 > 1e308\n# with these, c = 5e154 which is less that 1e308\n\ndef longSideDirect():\n    return sqrt(a**2 + b**2) # this will overflow\n\ndef longSideBuiltin():\n    return hypot(a, b) # better to use built-in function\n```\n\n## References\n* Python Language Reference: [The hypot function](https://docs.python.org/library/math.html#math.hypot)\n* Wikipedia: [Hypot](https://en.wikipedia.org/wiki/Hypot).\n"},"properties":{"tags":["accuracy"],"description":"Calculating the length of the hypotenuse using the standard formula may lead to overflow.","id":"py/pythagorean","kind":"problem","name":"Pythagorean calculation with sub-optimal numerics","precision":"medium","problem.severity":"warning","sub-severity":"low"}},{"id":"py/use-of-exit-or-quit","name":"py/use-of-exit-or-quit","shortDescription":{"text":"Use of exit() or quit()"},"fullDescription":{"text":"exit() or quit() may fail if the interpreter is run with the -S option."},"defaultConfiguration":{"enabled":true,"level":"warning"},"help":{"text":"# Use of exit() or quit()\nThe `exit` and `quit` \"functions\" are actually `site.Quitter` objects and are loaded, at interpreter start up, from `site.py`. However, if the interpreter is started with the `-S` flag, or a custom `site.py` is used then `exit` and `quit` may not be present.\n\n\n## Recommendation\nReplace uses of `exit()` and `quit()` with `sys.exit()` which is built into the interpreter and is guaranteed to be present.\n\n\n## Example\nIn this example, `exit()` is used and will fail if the interpreter is passed the `-S` option.\n\n\n```python\n\ndef main():\n    try:\n        process()\n    except Exception as ex:\n        print(ex)\n        exit(1)\n\n```\nIn this example, `sys.exit()` is used and will behave the same regardless of the interpreter options.\n\n\n```python\nimport sys\n\ndef main():\n    try:\n        process()\n    except Exception as ex:\n        print(ex)\n        sys.exit(1)\n\n```\n\n## References\n* Python Documentation: [Command line and environment](https://docs.python.org/using/cmdline.html#cmdoption-S).\n* Python Documentation: [Site-specific configuration hook](https://docs.python.org/library/site.html#module-site).\n","markdown":"# Use of exit() or quit()\nThe `exit` and `quit` \"functions\" are actually `site.Quitter` objects and are loaded, at interpreter start up, from `site.py`. However, if the interpreter is started with the `-S` flag, or a custom `site.py` is used then `exit` and `quit` may not be present.\n\n\n## Recommendation\nReplace uses of `exit()` and `quit()` with `sys.exit()` which is built into the interpreter and is guaranteed to be present.\n\n\n## Example\nIn this example, `exit()` is used and will fail if the interpreter is passed the `-S` option.\n\n\n```python\n\ndef main():\n    try:\n        process()\n    except Exception as ex:\n        print(ex)\n        exit(1)\n\n```\nIn this example, `sys.exit()` is used and will behave the same regardless of the interpreter options.\n\n\n```python\nimport sys\n\ndef main():\n    try:\n        process()\n    except Exception as ex:\n        print(ex)\n        sys.exit(1)\n\n```\n\n## References\n* Python Documentation: [Command line and environment](https://docs.python.org/using/cmdline.html#cmdoption-S).\n* Python Documentation: [Site-specific configuration hook](https://docs.python.org/library/site.html#module-site).\n"},"properties":{"tags":["quality","reliability","correctness"],"description":"exit() or quit() may fail if the interpreter is run with the -S option.","id":"py/use-of-exit-or-quit","kind":"problem","name":"Use of exit() or quit()","precision":"very-high","problem.severity":"warning","sub-severity":"low"}},{"id":"py/constant-conditional-expression","name":"py/constant-conditional-expression","shortDescription":{"text":"Constant in conditional expression or statement"},"fullDescription":{"text":"The conditional is always true or always false"},"defaultConfiguration":{"enabled":true,"level":"warning"},"help":{"text":"# Constant in conditional expression or statement\nUsing a constant value as a test in a conditional statement renders the statement pointless as only one branch will be run regardless of any other factors.\n\n\n## Recommendation\nIf the conditional statement is required for debugging or similar then use a variable instead. Otherwise, remove the conditional statement and any associated dead code.\n\n\n## Example\nIn the first example the `if` statement will always be executed and therefore can be removed. The contents of the statement should be kept though.\n\nIn the second example the statement `l = 100` is never executed because `1 > 100` is always false. However, it is likely that the intention was `l > 100` (the number '1' being misread as the letter 'l') and that the test should be corrected, rather than deleted.\n\n\n```python\nif True:\n    print \"True is true!\"\n\ndef limit(l):\n    if l < -100:\n        l = -100\n    if 1 > 100:\n        l = 100\n    return l\n\n```\n\n## References\n* Python: [The If Statement](http://docs.python.org/reference/compound_stmts.html#the-if-statement).\n* Python: [The While Statement](http://docs.python.org/reference/compound_stmts.html#the-while-statement).\n* Python: [Literals (constant values)](http://docs.python.org/reference/expressions.html#literals).\n* Common Weakness Enumeration: [CWE-561](https://cwe.mitre.org/data/definitions/561.html).\n* Common Weakness Enumeration: [CWE-570](https://cwe.mitre.org/data/definitions/570.html).\n* Common Weakness Enumeration: [CWE-571](https://cwe.mitre.org/data/definitions/571.html).\n","markdown":"# Constant in conditional expression or statement\nUsing a constant value as a test in a conditional statement renders the statement pointless as only one branch will be run regardless of any other factors.\n\n\n## Recommendation\nIf the conditional statement is required for debugging or similar then use a variable instead. Otherwise, remove the conditional statement and any associated dead code.\n\n\n## Example\nIn the first example the `if` statement will always be executed and therefore can be removed. The contents of the statement should be kept though.\n\nIn the second example the statement `l = 100` is never executed because `1 > 100` is always false. However, it is likely that the intention was `l > 100` (the number '1' being misread as the letter 'l') and that the test should be corrected, rather than deleted.\n\n\n```python\nif True:\n    print \"True is true!\"\n\ndef limit(l):\n    if l < -100:\n        l = -100\n    if 1 > 100:\n        l = 100\n    return l\n\n```\n\n## References\n* Python: [The If Statement](http://docs.python.org/reference/compound_stmts.html#the-if-statement).\n* Python: [The While Statement](http://docs.python.org/reference/compound_stmts.html#the-while-statement).\n* Python: [Literals (constant values)](http://docs.python.org/reference/expressions.html#literals).\n* Common Weakness Enumeration: [CWE-561](https://cwe.mitre.org/data/definitions/561.html).\n* Common Weakness Enumeration: [CWE-570](https://cwe.mitre.org/data/definitions/570.html).\n* Common Weakness Enumeration: [CWE-571](https://cwe.mitre.org/data/definitions/571.html).\n"},"properties":{"tags":["quality","maintainability","useless-code","external/cwe/cwe-561","external/cwe/cwe-570","external/cwe/cwe-571"],"description":"The conditional is always true or always false","id":"py/constant-conditional-expression","kind":"problem","name":"Constant in conditional expression or statement","precision":"very-high","problem.severity":"warning","sub-severity":"low"}},{"id":"py/return-or-yield-outside-function","name":"py/return-or-yield-outside-function","shortDescription":{"text":"Use of 'return' or 'yield' outside a function"},"fullDescription":{"text":"Using 'return' or 'yield' outside a function causes a 'SyntaxError' at runtime."},"defaultConfiguration":{"enabled":true,"level":"error"},"help":{"text":"# Use of 'return' or 'yield' outside a function\nIn Python, `return` and `yield` statements and the `yield from` expression can only be used within a function. Using them outside a function or a class method results in a `SyntaxError` at runtime.\n\n\n## Recommendation\nUsing these elements outside a function or a class method usually indicates an error in the logic. Consequently, it is not possible to suggest a general fix.\n\n\n## Example\nIn this example, a `return` statement is used outside a class method in a class and a `yield` statement is used outside a function in a scope of a module which would result in a `SyntaxError` when running this code. In this example, the invalid class could be corrected by placing the `return` statement in a class method, or by refactoring the class into a function. The invalid `yield` statement could become part of a new generator function containing the `for` loop.\n\n\n```python\n# invalid class with return outside a function\nclass InvalidClass1(object):\n    if [1, 2, 3]:\n        return \"Exists\"\n\n# invalid statement with yield outside a function\nfor i in [1, 2, 3]:\n    yield i\n\n```\n\n## References\n* Python reference: [ The return statement](https://docs.python.org/3.7/reference/simple_stmts.html#the-return-statement).\n* Python reference: [ The yield statement](https://docs.python.org/3.7/reference/simple_stmts.html#yield).\n* Python PEP-380: [ The yield from expression](https://docs.python.org/3/whatsnew/3.3.html#pep-380).\n","markdown":"# Use of 'return' or 'yield' outside a function\nIn Python, `return` and `yield` statements and the `yield from` expression can only be used within a function. Using them outside a function or a class method results in a `SyntaxError` at runtime.\n\n\n## Recommendation\nUsing these elements outside a function or a class method usually indicates an error in the logic. Consequently, it is not possible to suggest a general fix.\n\n\n## Example\nIn this example, a `return` statement is used outside a class method in a class and a `yield` statement is used outside a function in a scope of a module which would result in a `SyntaxError` when running this code. In this example, the invalid class could be corrected by placing the `return` statement in a class method, or by refactoring the class into a function. The invalid `yield` statement could become part of a new generator function containing the `for` loop.\n\n\n```python\n# invalid class with return outside a function\nclass InvalidClass1(object):\n    if [1, 2, 3]:\n        return \"Exists\"\n\n# invalid statement with yield outside a function\nfor i in [1, 2, 3]:\n    yield i\n\n```\n\n## References\n* Python reference: [ The return statement](https://docs.python.org/3.7/reference/simple_stmts.html#the-return-statement).\n* Python reference: [ The yield statement](https://docs.python.org/3.7/reference/simple_stmts.html#yield).\n* Python PEP-380: [ The yield from expression](https://docs.python.org/3/whatsnew/3.3.html#pep-380).\n"},"properties":{"tags":["reliability","correctness"],"description":"Using 'return' or 'yield' outside a function causes a 'SyntaxError' at runtime.","id":"py/return-or-yield-outside-function","kind":"problem","name":"Use of 'return' or 'yield' outside a function","precision":"medium","problem.severity":"error","sub-severity":"low"}},{"id":"py/redundant-else","name":"py/redundant-else","shortDescription":{"text":"Unnecessary 'else' clause in loop"},"fullDescription":{"text":"An 'else' clause in a 'for' or 'while' statement that does not contain a 'break' is redundant."},"defaultConfiguration":{"enabled":true,"level":"warning"},"help":{"text":"# Unnecessary 'else' clause in loop\nThe `else` clause of a loop (either a `for` or a `while` statement) executes immediately after the loop terminates normally. If there is a `break` statement in the loop body, then the `else` clause is skipped. If there is no `break` statement, then the `else` clause will always be executed after the loop, unless it exits with a `return` or `raise`. Therefore, if there is no `break` statement in the loop body then the `else` clause can be replaced with unindented code.\n\nGenerally the use of `else` clauses should be avoided where possible, as they are likely to be misunderstood.\n\n\n## Recommendation\nReplace the `else` clause with unindented code.\n\n\n## Example\nIn this example, the `pointless_else` function contains a redundant `else` clause. The `else` clause can be simplified, as shown in the `no_else` function, which has the same semantics, but has no `else` clause. The third example function, `with_break`, shows a version where the `else` clause is necessary, as the `break` statement skips the `else` clause.\n\n\n```python\ndef pointless_else(container):\n    for item in container:\n        if of_interest(item):\n            return item\n    else:\n        raise NotFoundException()\n\ndef no_else(container):\n    for item in container:\n        if of_interest(item):\n            return item\n    raise NotFoundException()\n\ndef with_break(container):\n    for item in container:\n        if of_interest(item):\n            found = item\n            break\n    else:\n        raise NotFoundException()\n    return found\n\n```\n\n## References\n* Python Language Reference: [The while statement](http://docs.python.org/2/reference/compound_stmts.html#the-while-statement).\n* Python Tutorial: [Break and continue statements, and else clauses on loops](http://docs.python.org/2/tutorial/controlflow.html#break-and-continue-statements-and-else-clauses-on-loops).\n","markdown":"# Unnecessary 'else' clause in loop\nThe `else` clause of a loop (either a `for` or a `while` statement) executes immediately after the loop terminates normally. If there is a `break` statement in the loop body, then the `else` clause is skipped. If there is no `break` statement, then the `else` clause will always be executed after the loop, unless it exits with a `return` or `raise`. Therefore, if there is no `break` statement in the loop body then the `else` clause can be replaced with unindented code.\n\nGenerally the use of `else` clauses should be avoided where possible, as they are likely to be misunderstood.\n\n\n## Recommendation\nReplace the `else` clause with unindented code.\n\n\n## Example\nIn this example, the `pointless_else` function contains a redundant `else` clause. The `else` clause can be simplified, as shown in the `no_else` function, which has the same semantics, but has no `else` clause. The third example function, `with_break`, shows a version where the `else` clause is necessary, as the `break` statement skips the `else` clause.\n\n\n```python\ndef pointless_else(container):\n    for item in container:\n        if of_interest(item):\n            return item\n    else:\n        raise NotFoundException()\n\ndef no_else(container):\n    for item in container:\n        if of_interest(item):\n            return item\n    raise NotFoundException()\n\ndef with_break(container):\n    for item in container:\n        if of_interest(item):\n            found = item\n            break\n    else:\n        raise NotFoundException()\n    return found\n\n```\n\n## References\n* Python Language Reference: [The while statement](http://docs.python.org/2/reference/compound_stmts.html#the-while-statement).\n* Python Tutorial: [Break and continue statements, and else clauses on loops](http://docs.python.org/2/tutorial/controlflow.html#break-and-continue-statements-and-else-clauses-on-loops).\n"},"properties":{"tags":["quality","maintainability","useless-code"],"description":"An 'else' clause in a 'for' or 'while' statement that does not contain a 'break' is redundant.","id":"py/redundant-else","kind":"problem","name":"Unnecessary 'else' clause in loop","precision":"very-high","problem.severity":"warning","sub-severity":"low"}},{"id":"py/nested-loops-with-same-variable","name":"py/nested-loops-with-same-variable","shortDescription":{"text":"Nested loops with same variable"},"fullDescription":{"text":"Nested loops in which the target variable is the same for each loop make the behavior of the loops difficult to understand."},"defaultConfiguration":{"enabled":true,"level":"note"},"help":{"text":"# Nested loops with same variable\nIn Python variables have function-wide scope which means that if two variables have the same name in the same scope, they are in fact one variable. Consequently, nested loops in which the target variables have the same name in fact share a single variable. Such loops are difficult to understand as the inner loop will modify the target variable of the outer loop; this may be a typographical error.\n\n\n## Recommendation\nCarefully examine the code and check for possible errors, particularly considering what would happen if the inner or outer variable were renamed.\n\n\n## Example\n\n```python\n\nfor var in range(3):\n    for var in range(3):\n        pass\n    print (var) # Prints 2 2 2 not 0 1 2 as might be expected\n\n\n```\n\n## References\n* Python Language Reference: [The for statement](http://docs.python.org/2/reference/compound_stmts.html#the-for-statement).\n* Python Tutorial: [for statements](http://docs.python.org/2/tutorial/controlflow.html#for-statements).\n","markdown":"# Nested loops with same variable\nIn Python variables have function-wide scope which means that if two variables have the same name in the same scope, they are in fact one variable. Consequently, nested loops in which the target variables have the same name in fact share a single variable. Such loops are difficult to understand as the inner loop will modify the target variable of the outer loop; this may be a typographical error.\n\n\n## Recommendation\nCarefully examine the code and check for possible errors, particularly considering what would happen if the inner or outer variable were renamed.\n\n\n## Example\n\n```python\n\nfor var in range(3):\n    for var in range(3):\n        pass\n    print (var) # Prints 2 2 2 not 0 1 2 as might be expected\n\n\n```\n\n## References\n* Python Language Reference: [The for statement](http://docs.python.org/2/reference/compound_stmts.html#the-for-statement).\n* Python Tutorial: [for statements](http://docs.python.org/2/tutorial/controlflow.html#for-statements).\n"},"properties":{"tags":["quality","maintainability","readability"],"description":"Nested loops in which the target variable is the same for each loop make\n              the behavior of the loops difficult to understand.","id":"py/nested-loops-with-same-variable","kind":"problem","name":"Nested loops with same variable","precision":"very-high","problem.severity":"recommendation","sub-severity":"high"}},{"id":"py/redundant-assignment","name":"py/redundant-assignment","shortDescription":{"text":"Redundant assignment"},"fullDescription":{"text":"Assigning a variable to itself is useless and very likely indicates an error in the code."},"defaultConfiguration":{"enabled":true,"level":"error"},"help":{"text":"# Redundant assignment\nAssigning a variable to itself is redundant and often an indication of a mistake in the code.\n\n\n## Recommendation\nCheck the assignment carefully for mistakes. If the assignment is truly redundant and not simply incorrect then remove it.\n\n\n## Example\nIn this example the programmer clearly intends to assign to `self.eggs` but made a mistake.\n\n\n```python\nclass Spam:\n\n    def __init__(self, eggs):\n        eggs = eggs\n\n\n```\n\n## References\n* Python Language Reference: [ The assignment statement](http://docs.python.org/reference/simple_stmts.html#assignment-statements).\n* Common Weakness Enumeration: [CWE-563](https://cwe.mitre.org/data/definitions/563.html).\n","markdown":"# Redundant assignment\nAssigning a variable to itself is redundant and often an indication of a mistake in the code.\n\n\n## Recommendation\nCheck the assignment carefully for mistakes. If the assignment is truly redundant and not simply incorrect then remove it.\n\n\n## Example\nIn this example the programmer clearly intends to assign to `self.eggs` but made a mistake.\n\n\n```python\nclass Spam:\n\n    def __init__(self, eggs):\n        eggs = eggs\n\n\n```\n\n## References\n* Python Language Reference: [ The assignment statement](http://docs.python.org/reference/simple_stmts.html#assignment-statements).\n* Common Weakness Enumeration: [CWE-563](https://cwe.mitre.org/data/definitions/563.html).\n"},"properties":{"tags":["quality","reliability","correctness","external/cwe/cwe-563"],"description":"Assigning a variable to itself is useless and very likely indicates an error in the code.","id":"py/redundant-assignment","kind":"problem","name":"Redundant assignment","precision":"very-high","problem.severity":"error","sub-severity":"low"}},{"id":"py/unreachable-statement","name":"py/unreachable-statement","shortDescription":{"text":"Unreachable code"},"fullDescription":{"text":"Code is unreachable"},"defaultConfiguration":{"enabled":true,"level":"warning"},"help":{"text":"# Unreachable code\nUnreachable code makes the code more difficult to understand and may slow down loading of modules.\n\n\n## Recommendation\nDeleting the unreachable code will make the code clearer and preserve the meaning of the code. However, it is possible that the original intention was that the code should execute and that it is unreachable signifies some other error.\n\n\n## Example\nIn this example the assignment to `remainder` is never reached because there is a ` return` statement on the previous line.\n\n\n```python\nimport math\n\ndef my_div(x, y):\n    return math.floor(x / y)\n    remainder = x - math.floor(x / y) * y\n\n```\n\n## References\n* Wikipedia: [Unreachable Code](http://en.wikipedia.org/wiki/Unreachable_code).\n* Common Weakness Enumeration: [CWE-561](https://cwe.mitre.org/data/definitions/561.html).\n","markdown":"# Unreachable code\nUnreachable code makes the code more difficult to understand and may slow down loading of modules.\n\n\n## Recommendation\nDeleting the unreachable code will make the code clearer and preserve the meaning of the code. However, it is possible that the original intention was that the code should execute and that it is unreachable signifies some other error.\n\n\n## Example\nIn this example the assignment to `remainder` is never reached because there is a ` return` statement on the previous line.\n\n\n```python\nimport math\n\ndef my_div(x, y):\n    return math.floor(x / y)\n    remainder = x - math.floor(x / y) * y\n\n```\n\n## References\n* Wikipedia: [Unreachable Code](http://en.wikipedia.org/wiki/Unreachable_code).\n* Common Weakness Enumeration: [CWE-561](https://cwe.mitre.org/data/definitions/561.html).\n"},"properties":{"tags":["quality","maintainability","useless-code","external/cwe/cwe-561"],"description":"Code is unreachable","id":"py/unreachable-statement","kind":"problem","name":"Unreachable code","precision":"very-high","problem.severity":"warning","sub-severity":"low"}},{"id":"py/print-during-import","name":"py/print-during-import","shortDescription":{"text":"Use of a print statement at module level"},"fullDescription":{"text":"Using a print statement at module scope (except when guarded by `if __name__ == '__main__'`) will cause surprising output when the module is imported."},"defaultConfiguration":{"enabled":true,"level":"note"},"help":{"text":"# Use of a print statement at module level\nUsing `print` statements in level scope may result in surprising output at import time. This in turn means that other code cannot safely import the module in question if the program may only write real output to standard out.\n\n\n## Recommendation\nReplace the `print` statements with calls to some form of logging function or use the `warnings` module.\n\n\n## Example\nIn the example, importing the module may cause a message to be printed, which may interfere with the operation of the program.\n\n\n```python\n\ntry:\n    import fast_system as system\nexcept ImportError:\n    print (\"Cannot import fast system, falling back on slow system\")\n    import slow_system as system\n\n#Fixed version\nimport logging\n\ntry:\n    import fast_system as system\nexcept ImportError:\n    logging.info(\"Cannot import fast system, falling back on slow system\")\n    import slow_system as system\n\n```\n\n## References\n* Python Language Reference: [The print statement](http://docs.python.org/2/reference/simple_stmts.html#the-print-statement).\n* Python Standard Library: [The print function](http://docs.python.org/3/library/functions.html#print).\n* Python tutorial: [Modules](http://docs.python.org/2/tutorial/modules.html).\n","markdown":"# Use of a print statement at module level\nUsing `print` statements in level scope may result in surprising output at import time. This in turn means that other code cannot safely import the module in question if the program may only write real output to standard out.\n\n\n## Recommendation\nReplace the `print` statements with calls to some form of logging function or use the `warnings` module.\n\n\n## Example\nIn the example, importing the module may cause a message to be printed, which may interfere with the operation of the program.\n\n\n```python\n\ntry:\n    import fast_system as system\nexcept ImportError:\n    print (\"Cannot import fast system, falling back on slow system\")\n    import slow_system as system\n\n#Fixed version\nimport logging\n\ntry:\n    import fast_system as system\nexcept ImportError:\n    logging.info(\"Cannot import fast system, falling back on slow system\")\n    import slow_system as system\n\n```\n\n## References\n* Python Language Reference: [The print statement](http://docs.python.org/2/reference/simple_stmts.html#the-print-statement).\n* Python Standard Library: [The print function](http://docs.python.org/3/library/functions.html#print).\n* Python tutorial: [Modules](http://docs.python.org/2/tutorial/modules.html).\n"},"properties":{"tags":["quality","reliability","correctness"],"description":"Using a print statement at module scope (except when guarded by `if __name__ == '__main__'`) will cause surprising output when the module is imported.","id":"py/print-during-import","kind":"problem","name":"Use of a print statement at module level","precision":"high","problem.severity":"recommendation","sub-severity":"high"}},{"id":"py/exit-from-finally","name":"py/exit-from-finally","shortDescription":{"text":"'break' or 'return' statement in finally"},"fullDescription":{"text":"Using a Break or Return statement in a finally block causes the Try-finally block to exit, discarding the exception."},"defaultConfiguration":{"enabled":true,"level":"warning"},"help":{"text":"# 'break' or 'return' statement in finally\nWhen a `break` or `return` statement is used in a `finally` block this causes the `try-finally` block to exit immediately discarding the exception. This is unlikely to be the intention of the developer and makes the code more difficult to read.\n\n\n## Recommendation\nEither move the `break` or `return` statement to immediately after the `finally` block or use an explicit `except` block to handle the exception.\n\nThese modifications are behavior changing so you must take care to ensure that the resulting behavior is correct.\n\n\n## References\n* Python Language Reference: [ The try statement](http://docs.python.org/2.7/reference/compound_stmts.html#the-try-statement), [ The break statement](http://docs.python.org/2/reference/simple_stmts.html#break), [ The return statement](http://docs.python.org/2/reference/simple_stmts.html#return).\n* Common Weakness Enumeration: [CWE-584](https://cwe.mitre.org/data/definitions/584.html).\n","markdown":"# 'break' or 'return' statement in finally\nWhen a `break` or `return` statement is used in a `finally` block this causes the `try-finally` block to exit immediately discarding the exception. This is unlikely to be the intention of the developer and makes the code more difficult to read.\n\n\n## Recommendation\nEither move the `break` or `return` statement to immediately after the `finally` block or use an explicit `except` block to handle the exception.\n\nThese modifications are behavior changing so you must take care to ensure that the resulting behavior is correct.\n\n\n## References\n* Python Language Reference: [ The try statement](http://docs.python.org/2.7/reference/compound_stmts.html#the-try-statement), [ The break statement](http://docs.python.org/2/reference/simple_stmts.html#break), [ The return statement](http://docs.python.org/2/reference/simple_stmts.html#return).\n* Common Weakness Enumeration: [CWE-584](https://cwe.mitre.org/data/definitions/584.html).\n"},"properties":{"tags":["reliability","maintainability","external/cwe/cwe-584"],"description":"Using a Break or Return statement in a finally block causes the\n              Try-finally block to exit, discarding the exception.","id":"py/exit-from-finally","kind":"problem","name":"'break' or 'return' statement in finally","precision":"medium","problem.severity":"warning","sub-severity":"low"}},{"id":"py/side-effect-in-assert","name":"py/side-effect-in-assert","shortDescription":{"text":"An assert statement has a side-effect"},"fullDescription":{"text":"Side-effects in assert statements result in differences between normal and optimized behavior."},"defaultConfiguration":{"enabled":true,"level":"error"},"help":{"text":"# An assert statement has a side-effect\nAll code defined in assert statements is ignored when optimization is requested, that is, the program is run with the `-O` flag. If an assert statement has any side-effects then the behavior of the program changes when optimization is requested.\n\n\n## Recommendation\nMove all expressions with side-effects out of assert statements.\n\n\n## Example\nIn the example, the exit code from `subprocess.call()` is checked against 0, but the entire expression is called from within an `assert` statement. If the code is ever run, then the not only the assertion itself, but also the external call, will be discarded. It is better to save the result of `subprocess.call()` to a temporary variable, and to assert that variable to be 0.\n\n\n```python\nassert subprocess.call(['run-backup']) == 0\n\n```\n\n## References\n* Python Language Reference: [The assert statement](http://docs.python.org/2/reference/simple_stmts.html#assert).\n* TutorialsPoint, Python Programming: [Assertions in Python](http://www.tutorialspoint.com/python/assertions_in_python.htm).\n","markdown":"# An assert statement has a side-effect\nAll code defined in assert statements is ignored when optimization is requested, that is, the program is run with the `-O` flag. If an assert statement has any side-effects then the behavior of the program changes when optimization is requested.\n\n\n## Recommendation\nMove all expressions with side-effects out of assert statements.\n\n\n## Example\nIn the example, the exit code from `subprocess.call()` is checked against 0, but the entire expression is called from within an `assert` statement. If the code is ever run, then the not only the assertion itself, but also the external call, will be discarded. It is better to save the result of `subprocess.call()` to a temporary variable, and to assert that variable to be 0.\n\n\n```python\nassert subprocess.call(['run-backup']) == 0\n\n```\n\n## References\n* Python Language Reference: [The assert statement](http://docs.python.org/2/reference/simple_stmts.html#assert).\n* TutorialsPoint, Python Programming: [Assertions in Python](http://www.tutorialspoint.com/python/assertions_in_python.htm).\n"},"properties":{"tags":["quality","reliability","correctness"],"description":"Side-effects in assert statements result in differences between normal\n              and optimized behavior.","id":"py/side-effect-in-assert","kind":"problem","name":"An assert statement has a side-effect","precision":"high","problem.severity":"error","sub-severity":"low"}},{"id":"py/should-use-with","name":"py/should-use-with","shortDescription":{"text":"Should use a 'with' statement"},"fullDescription":{"text":"Using a 'try-finally' block to ensure only that a resource is closed makes code more difficult to read."},"defaultConfiguration":{"enabled":true,"level":"note"},"help":{"text":"# Should use a 'with' statement\nThe `with` statement was introduced by PEP343 to allow standard uses of `try-finally` statements to be factored out. Using this simplification makes code easier to read.\n\n\n## Recommendation\nReview the code and determine whether or not the `try-finally` is used only to ensure that a resource is closed. If the only purpose is to ensure that a resource is closed, then replace the `try-finally` statement with a `with` statement.\n\n\n## Example\nThe following code shows examples of different ways of ensuring that a file is always closed, even when an error is generated. In the second example, the `try-finally` block is replaced by a simpler `with` statement.\n\n\n```python\n\nf = open(\"filename\")\ntry:                         # Method of ensuring file closure\n    f.write(...)\nfinally:\n    f.close()\n\n\nwith open(\"filename\") as f:  # Simpler method of ensuring file closure\n    f.write(...)\n```\n\n## References\n* Python Language Reference: [The with statement](http://docs.python.org/reference/compound_stmts.html#the-with-statement).\n* Python Standard Library: [Context manager ](http://docs.python.org/library/stdtypes.html#context-manager-types).\n* Python PEP 343: [The \"with\" Statement](http://www.python.org/dev/peps/pep-0343).\n","markdown":"# Should use a 'with' statement\nThe `with` statement was introduced by PEP343 to allow standard uses of `try-finally` statements to be factored out. Using this simplification makes code easier to read.\n\n\n## Recommendation\nReview the code and determine whether or not the `try-finally` is used only to ensure that a resource is closed. If the only purpose is to ensure that a resource is closed, then replace the `try-finally` statement with a `with` statement.\n\n\n## Example\nThe following code shows examples of different ways of ensuring that a file is always closed, even when an error is generated. In the second example, the `try-finally` block is replaced by a simpler `with` statement.\n\n\n```python\n\nf = open(\"filename\")\ntry:                         # Method of ensuring file closure\n    f.write(...)\nfinally:\n    f.close()\n\n\nwith open(\"filename\") as f:  # Simpler method of ensuring file closure\n    f.write(...)\n```\n\n## References\n* Python Language Reference: [The with statement](http://docs.python.org/reference/compound_stmts.html#the-with-statement).\n* Python Standard Library: [Context manager ](http://docs.python.org/library/stdtypes.html#context-manager-types).\n* Python PEP 343: [The \"with\" Statement](http://www.python.org/dev/peps/pep-0343).\n"},"properties":{"tags":["quality","maintainability","readability"],"description":"Using a 'try-finally' block to ensure only that a resource is closed makes code more\n              difficult to read.","id":"py/should-use-with","kind":"problem","name":"Should use a 'with' statement","precision":"very-high","problem.severity":"recommendation","sub-severity":"high"}},{"id":"py/unnecessary-pass","name":"py/unnecessary-pass","shortDescription":{"text":"Unnecessary pass"},"fullDescription":{"text":"Unnecessary 'pass' statement"},"defaultConfiguration":{"enabled":true,"level":"warning"},"help":{"text":"# Unnecessary pass\nA `pass` statement is only necessary when it is the only statement in a block (the list of statements forming part of a compound statement). This is because the purpose of the ` pass` statement is to allow empty blocks where they would otherwise be syntactically invalid. If the block already contains other statements then the `pass` statement is unnecessary.\n\n\n## Recommendation\nRemove the `pass` statement.\n\n\n## References\n* Python: [pass](http://docs.python.org/2/tutorial/controlflow.html#pass-statements).\n","markdown":"# Unnecessary pass\nA `pass` statement is only necessary when it is the only statement in a block (the list of statements forming part of a compound statement). This is because the purpose of the ` pass` statement is to allow empty blocks where they would otherwise be syntactically invalid. If the block already contains other statements then the `pass` statement is unnecessary.\n\n\n## Recommendation\nRemove the `pass` statement.\n\n\n## References\n* Python: [pass](http://docs.python.org/2/tutorial/controlflow.html#pass-statements).\n"},"properties":{"tags":["quality","maintainability","useless-code"],"description":"Unnecessary 'pass' statement","id":"py/unnecessary-pass","kind":"problem","name":"Unnecessary pass","precision":"very-high","problem.severity":"warning","sub-severity":"low"}},{"id":"py/iteration-string-and-sequence","name":"py/iteration-string-and-sequence","shortDescription":{"text":"Iterable can be either a string or a sequence"},"fullDescription":{"text":"Iteration over either a string or a sequence in the same loop can cause errors that are hard to find."},"defaultConfiguration":{"enabled":true,"level":"error"},"help":{"text":"# Iterable can be either a string or a sequence\nThe `for` statement is designed to allow you to iterate over the elements of a sequence or other iterable object. Strings in Python are iterable, and often used as such. However, they are also often considered, not as sequences of characters, but as atomic entities.\n\nOne source of defects in Python is mistakenly iterating over a non-iterable object such as an integer. This sort of defect is easily detected as a `TypeError` will be raised. However, if a string is mistakenly used as the iterable in a `for` statement, which also receives other sequences (such as lists) then the code will iterate over the string one character at a time. This is probably not what the programmer intended and results in errors that are hard to find.\n\n\n## Recommendation\nSince this defect usually indicates a logical error, it is not possible to give a general method for addressing the defect. However, adding a guard that checks that the iterator is not a string could be worthwhile.\n\n\n## Example\nIn this example, the loop may iterate over `\"Hello\"` producing one character per line, as well as over `[ \"Hello\", \"World\" ]` It is likely that the programmer forgot to wrap the `\"Hello\"` in brackets.\n\n\n```python\n\n#Mistakenly mixed list and string\ndef greeting():\n    if is_global():\n        greet = [ \"Hello\", \"World\" ]\n    else:\n        greet = \"Hello\"\n    for word in greet:\n        print(word)\n\n#Only use list\ndef fixed_greeting():\n    if is_global():\n        greet = [ \"Hello\", \"World\" ]\n    else:\n        greet = [ \"Hello\" ]\n    for word in greet:\n        print(word)\n\n```\n\n## References\n* Python Language Reference: [The for statement](http://docs.python.org/reference/compound_stmts.html#the-for-statement), [object.__iter__](http://docs.python.org/2.7/reference/datamodel.html#object.__iter__).\n* Python Standard Library: [Iterator types](http://docs.python.org/dev/library/stdtypes.html#iterator-types).\n* Scipy lecture notes: [Iterators, generator expressions and generators](http://scipy-lectures.github.io/advanced/advanced_python/#iterators).\n","markdown":"# Iterable can be either a string or a sequence\nThe `for` statement is designed to allow you to iterate over the elements of a sequence or other iterable object. Strings in Python are iterable, and often used as such. However, they are also often considered, not as sequences of characters, but as atomic entities.\n\nOne source of defects in Python is mistakenly iterating over a non-iterable object such as an integer. This sort of defect is easily detected as a `TypeError` will be raised. However, if a string is mistakenly used as the iterable in a `for` statement, which also receives other sequences (such as lists) then the code will iterate over the string one character at a time. This is probably not what the programmer intended and results in errors that are hard to find.\n\n\n## Recommendation\nSince this defect usually indicates a logical error, it is not possible to give a general method for addressing the defect. However, adding a guard that checks that the iterator is not a string could be worthwhile.\n\n\n## Example\nIn this example, the loop may iterate over `\"Hello\"` producing one character per line, as well as over `[ \"Hello\", \"World\" ]` It is likely that the programmer forgot to wrap the `\"Hello\"` in brackets.\n\n\n```python\n\n#Mistakenly mixed list and string\ndef greeting():\n    if is_global():\n        greet = [ \"Hello\", \"World\" ]\n    else:\n        greet = \"Hello\"\n    for word in greet:\n        print(word)\n\n#Only use list\ndef fixed_greeting():\n    if is_global():\n        greet = [ \"Hello\", \"World\" ]\n    else:\n        greet = [ \"Hello\" ]\n    for word in greet:\n        print(word)\n\n```\n\n## References\n* Python Language Reference: [The for statement](http://docs.python.org/reference/compound_stmts.html#the-for-statement), [object.__iter__](http://docs.python.org/2.7/reference/datamodel.html#object.__iter__).\n* Python Standard Library: [Iterator types](http://docs.python.org/dev/library/stdtypes.html#iterator-types).\n* Scipy lecture notes: [Iterators, generator expressions and generators](http://scipy-lectures.github.io/advanced/advanced_python/#iterators).\n"},"properties":{"tags":["quality","reliability","correctness"],"description":"Iteration over either a string or a sequence in the same loop can cause errors that are hard to find.","id":"py/iteration-string-and-sequence","kind":"problem","name":"Iterable can be either a string or a sequence","precision":"high","problem.severity":"error","sub-severity":"low"}},{"id":"py/nested-loops-with-same-variable-reused","name":"py/nested-loops-with-same-variable-reused","shortDescription":{"text":"Nested loops with same variable reused after inner loop body"},"fullDescription":{"text":"Redefining a variable in an inner loop and then using the variable in an outer loop causes unexpected behavior."},"defaultConfiguration":{"enabled":true,"level":"error"},"help":{"text":"# Nested loops with same variable reused after inner loop body\nIn Python variables have function-wide scope which means that if two variables have the same name in the same scope, they are in fact one variable. Consequently, nested loops in which the target variables have the same name in fact share a single variable. Such loops are difficult to understand as the inner loop will modify the target variable of the outer loop. This may lead to unexpected behavior if the loop variable is used after the inner loop has terminated.\n\n\n## Recommendation\nRename the inner loop variable.\n\n\n## Example\nThis example shows a function that processes a sequence of lists of numbers. It prints out the largest element from each of the lists. In the first version, the variable `x` gets overwritten by the inner loop, resulting in the wrong output. In the second function, the error has been fixed by renaming the inner loop variable to stop it overwriting the outer loop variable.\n\n\n```python\ndef largest_elements(l):\n    for x in l:\n        maxnum = 0\n        for x in x:\n            maxnum = max(x, maxnum)\n        # The outer loop variable x has now been overwritten by the inner loop.\n        print \"The largest element in the list\", x, \"is\", maxnum\n\n\ndef largest_elements_correct(l):\n    for x in l:\n        maxnum = 0\n        for y in x:\n            maxnum = max(y, maxnum)\n        print \"The largest element in the list\", x, \"is\", maxnum\n\n\n```\n\n## References\n* Python Language Reference: [The for statement](http://docs.python.org/2/reference/compound_stmts.html#the-for-statement).\n* Python Tutorial: [for statements](http://docs.python.org/2/tutorial/controlflow.html#for-statements).\n","markdown":"# Nested loops with same variable reused after inner loop body\nIn Python variables have function-wide scope which means that if two variables have the same name in the same scope, they are in fact one variable. Consequently, nested loops in which the target variables have the same name in fact share a single variable. Such loops are difficult to understand as the inner loop will modify the target variable of the outer loop. This may lead to unexpected behavior if the loop variable is used after the inner loop has terminated.\n\n\n## Recommendation\nRename the inner loop variable.\n\n\n## Example\nThis example shows a function that processes a sequence of lists of numbers. It prints out the largest element from each of the lists. In the first version, the variable `x` gets overwritten by the inner loop, resulting in the wrong output. In the second function, the error has been fixed by renaming the inner loop variable to stop it overwriting the outer loop variable.\n\n\n```python\ndef largest_elements(l):\n    for x in l:\n        maxnum = 0\n        for x in x:\n            maxnum = max(x, maxnum)\n        # The outer loop variable x has now been overwritten by the inner loop.\n        print \"The largest element in the list\", x, \"is\", maxnum\n\n\ndef largest_elements_correct(l):\n    for x in l:\n        maxnum = 0\n        for y in x:\n            maxnum = max(y, maxnum)\n        print \"The largest element in the list\", x, \"is\", maxnum\n\n\n```\n\n## References\n* Python Language Reference: [The for statement](http://docs.python.org/2/reference/compound_stmts.html#the-for-statement).\n* Python Tutorial: [for statements](http://docs.python.org/2/tutorial/controlflow.html#for-statements).\n"},"properties":{"tags":["quality","reliability","correctness"],"description":"Redefining a variable in an inner loop and then using\n              the variable in an outer loop causes unexpected behavior.","id":"py/nested-loops-with-same-variable-reused","kind":"problem","name":"Nested loops with same variable reused after inner loop body","precision":"very-high","problem.severity":"error","sub-severity":"low"}},{"id":"py/unused-exception-object","name":"py/unused-exception-object","shortDescription":{"text":"Unused exception object"},"fullDescription":{"text":"An exception object is created, but is not used."},"defaultConfiguration":{"enabled":true,"level":"error"},"help":{"text":"# Unused exception object\nCreating a new exception object is no different from creating any other object. The exception needs to be raised to have an effect.\n\n\n## Recommendation\nInsert a `raise` before the exception.\n\n\n## Example\nIn this example, the first function `do_action_forgotten_raise()` silently ignores any erroneous input. Whereas, the second function `do_action` correctly raises an exception if the 'action' is not understood.\n\n\n```python\n\ndef do_action_forgotten_raise(action):\n    if action == \"go\":\n        start()\n    elif action == \"stop\":\n        stop()\n    else:\n        ValueError(action)\n\ndef do_action(action):\n    if action == \"go\":\n        start()\n    elif action == \"stop\":\n        stop()\n    else:\n        raise ValueError(action)\n\n```\n","markdown":"# Unused exception object\nCreating a new exception object is no different from creating any other object. The exception needs to be raised to have an effect.\n\n\n## Recommendation\nInsert a `raise` before the exception.\n\n\n## Example\nIn this example, the first function `do_action_forgotten_raise()` silently ignores any erroneous input. Whereas, the second function `do_action` correctly raises an exception if the 'action' is not understood.\n\n\n```python\n\ndef do_action_forgotten_raise(action):\n    if action == \"go\":\n        start()\n    elif action == \"stop\":\n        stop()\n    else:\n        ValueError(action)\n\ndef do_action(action):\n    if action == \"go\":\n        start()\n    elif action == \"stop\":\n        stop()\n    else:\n        raise ValueError(action)\n\n```\n"},"properties":{"tags":["quality","reliability","error-handling"],"description":"An exception object is created, but is not used.","id":"py/unused-exception-object","kind":"problem","name":"Unused exception object","precision":"very-high","problem.severity":"error","sub-severity":"low"}},{"id":"py/non-iterable-in-for-loop","name":"py/non-iterable-in-for-loop","shortDescription":{"text":"Non-iterable used in for loop"},"fullDescription":{"text":"Using a non-iterable as the object in a 'for' loop causes a TypeError."},"defaultConfiguration":{"enabled":true,"level":"error"},"help":{"text":"# Non-iterable used in for loop\nThe `for` statement is designed to allow you to iterate over the elements of a sequence or other iterable object. If a non-iterable object is used in a `for` statement (`for var in object:`) then a TypeError will be raised.\n\n\n## Recommendation\nSince this defect usually indicates a logical error, it is not possible to give a general method for addressing the defect.\n\n\n## Example\nIn this example, the loop may attempt to iterate over `None`, which is not an iterable. It is likely that the programmer forgot to test for `None` before the loop.\n\n\n```python\n\n\ndef illegal_for_loop(seq = None):\n    for x in seq:\n        print (x)\n\n\n```\n\n## References\n* Python Language Reference: [The for statement](http://docs.python.org/reference/compound_stmts.html#the-for-statement), [object.__iter__](http://docs.python.org/2.7/reference/datamodel.html#object.__iter__).\n* Python Standard Library: [Iterator types](http://docs.python.org/dev/library/stdtypes.html#iterator-types).\n* Scipy lecture notes: [Iterators, generator expressions and generators](http://scipy-lectures.github.io/advanced/advanced_python/#iterators).\n","markdown":"# Non-iterable used in for loop\nThe `for` statement is designed to allow you to iterate over the elements of a sequence or other iterable object. If a non-iterable object is used in a `for` statement (`for var in object:`) then a TypeError will be raised.\n\n\n## Recommendation\nSince this defect usually indicates a logical error, it is not possible to give a general method for addressing the defect.\n\n\n## Example\nIn this example, the loop may attempt to iterate over `None`, which is not an iterable. It is likely that the programmer forgot to test for `None` before the loop.\n\n\n```python\n\n\ndef illegal_for_loop(seq = None):\n    for x in seq:\n        print (x)\n\n\n```\n\n## References\n* Python Language Reference: [The for statement](http://docs.python.org/reference/compound_stmts.html#the-for-statement), [object.__iter__](http://docs.python.org/2.7/reference/datamodel.html#object.__iter__).\n* Python Standard Library: [Iterator types](http://docs.python.org/dev/library/stdtypes.html#iterator-types).\n* Scipy lecture notes: [Iterators, generator expressions and generators](http://scipy-lectures.github.io/advanced/advanced_python/#iterators).\n"},"properties":{"tags":["quality","reliability","correctness"],"description":"Using a non-iterable as the object in a 'for' loop causes a TypeError.","id":"py/non-iterable-in-for-loop","kind":"problem","name":"Non-iterable used in for loop","precision":"high","problem.severity":"error","sub-severity":"low"}},{"id":"py/ineffectual-statement","name":"py/ineffectual-statement","shortDescription":{"text":"Statement has no effect"},"fullDescription":{"text":"A statement has no effect"},"defaultConfiguration":{"enabled":true,"level":"note"},"help":{"text":"# Statement has no effect\nAn expression statement without side effects is just clutter. It confuses the reader and may have a slight impact on performance.\n\n\n## Recommendation\nFirst determine what the intention of the code was, if there is no intention of a side effect, then just delete the statement. However, it is probable that there is a mistake in the code and some effect was intended.\n\nThis query will not flag a statement consisting solely of a string as having no side effect, as these are often used as comments. If you want to use strings as comments, the most common convention is to use triple quoted strings rather than single quoted ones. Although consistency is more important than conforming to any particular style.\n\n\n## Example\nIn this example neither line of the `increment_and_show()` function has any effect.\n\nThe first line, `++x`, has no effect as it applies the unary plus operator twice. Probably the programmer intended `x += 1`\n\nThe second line, `x.show`, has no observable effect, but it is likely that `x.show()` was intended.\n\n\n```python\n\ndef increment_and_show(x):\n    ++x\n    x.show\n\n```\n","markdown":"# Statement has no effect\nAn expression statement without side effects is just clutter. It confuses the reader and may have a slight impact on performance.\n\n\n## Recommendation\nFirst determine what the intention of the code was, if there is no intention of a side effect, then just delete the statement. However, it is probable that there is a mistake in the code and some effect was intended.\n\nThis query will not flag a statement consisting solely of a string as having no side effect, as these are often used as comments. If you want to use strings as comments, the most common convention is to use triple quoted strings rather than single quoted ones. Although consistency is more important than conforming to any particular style.\n\n\n## Example\nIn this example neither line of the `increment_and_show()` function has any effect.\n\nThe first line, `++x`, has no effect as it applies the unary plus operator twice. Probably the programmer intended `x += 1`\n\nThe second line, `x.show`, has no observable effect, but it is likely that `x.show()` was intended.\n\n\n```python\n\ndef increment_and_show(x):\n    ++x\n    x.show\n\n```\n"},"properties":{"tags":["quality","maintainability","useless-code","external/cwe/cwe-561"],"description":"A statement has no effect","id":"py/ineffectual-statement","kind":"problem","name":"Statement has no effect","precision":"high","problem.severity":"recommendation","sub-severity":"high"}},{"id":"py/mismatched-multiple-assignment","name":"py/mismatched-multiple-assignment","shortDescription":{"text":"Mismatch in multiple assignment"},"fullDescription":{"text":"Assigning multiple variables without ensuring that you define a value for each variable causes an exception at runtime."},"defaultConfiguration":{"enabled":true,"level":"error"},"help":{"text":"# Mismatch in multiple assignment\nAn assignment statement evaluates a sequence expression and assigns each item of the sequence to one of the variables on the left. If there is a mismatch between the number of variables on the left and the values in the sequence on the right of the statement, then an exception is raised at runtime.\n\n\n## Recommendation\nEnsure that the number of variables on either side of the assignment match.\n\n\n## Example\nThe following examples show a simple definition of the Fibonacci series. In the first example, one of the values in the assignment has been duplicated, causing an exception at runtime.\n\n\n```python\n# Fibonacci series 1:\n# the sum of two elements defines the next\n\na, b = 0, 1, 1  # Assignment fails: accidentally put three values on right\nwhile b < 10:\n     print b\n     a, b = b, a+b\n\n# Fibonacci series 2:\n# the sum of two elements defines the next\na, b = 0, 1   # Assignment succeeds: two variables on left and two values on right\nwhile b < 10:\n     print b\n     a, b = b, a+b\n\n```\n\n## References\n* Python Language Reference: [ Assignment statements](http://docs.python.org/2/reference/simple_stmts.html#grammar-token-assignment_stmt).\n* Python Tutorial: [ First steps towards programming](http://docs.python.org/2/tutorial/introduction.html#first-steps-towards-programming).\n","markdown":"# Mismatch in multiple assignment\nAn assignment statement evaluates a sequence expression and assigns each item of the sequence to one of the variables on the left. If there is a mismatch between the number of variables on the left and the values in the sequence on the right of the statement, then an exception is raised at runtime.\n\n\n## Recommendation\nEnsure that the number of variables on either side of the assignment match.\n\n\n## Example\nThe following examples show a simple definition of the Fibonacci series. In the first example, one of the values in the assignment has been duplicated, causing an exception at runtime.\n\n\n```python\n# Fibonacci series 1:\n# the sum of two elements defines the next\n\na, b = 0, 1, 1  # Assignment fails: accidentally put three values on right\nwhile b < 10:\n     print b\n     a, b = b, a+b\n\n# Fibonacci series 2:\n# the sum of two elements defines the next\na, b = 0, 1   # Assignment succeeds: two variables on left and two values on right\nwhile b < 10:\n     print b\n     a, b = b, a+b\n\n```\n\n## References\n* Python Language Reference: [ Assignment statements](http://docs.python.org/2/reference/simple_stmts.html#grammar-token-assignment_stmt).\n* Python Tutorial: [ First steps towards programming](http://docs.python.org/2/tutorial/introduction.html#first-steps-towards-programming).\n"},"properties":{"tags":["quality","reliability","correctness"],"description":"Assigning multiple variables without ensuring that you define a\n              value for each variable causes an exception at runtime.","id":"py/mismatched-multiple-assignment","kind":"problem","name":"Mismatch in multiple assignment","precision":"very-high","problem.severity":"error","sub-severity":"low"}},{"id":"py/modification-of-locals","name":"py/modification-of-locals","shortDescription":{"text":"Modification of dictionary returned by locals()"},"fullDescription":{"text":"Modifications of the dictionary returned by locals() are not propagated to the local variables of a function."},"defaultConfiguration":{"enabled":true,"level":"warning"},"help":{"text":"# Modification of dictionary returned by locals()\nThe dictionary returned by `locals()` is not a view of the function's locals, but a copy. Therefore, modification of the dictionary returned from `locals()` will not modify the local variables of the function.\n\n\n## Recommendation\nIf the intention is to modify a local variable, then do so directly.\n\n\n## Example\nIn this example, rather than assigning to the variable `z` directly, the dictionary returned by `locals()` is modified.\n\n\n```python\n\ndef modifies_locals_sum(x, y):\n    locals()['z'] = x + y\n    #z will not be defined as modifications to locals() do not alter the local variables.\n    return z\n\ndef fixed_sum(x, y):\n    z = x + y\n    return z\n\n\n```\n\n## References\n* Python Language Reference: [The for statement](http://docs.python.org/2/reference/compound_stmts.html#the-for-statement).\n* Python Tutorial: [for statements](http://docs.python.org/2/tutorial/controlflow.html#for-statements).\n","markdown":"# Modification of dictionary returned by locals()\nThe dictionary returned by `locals()` is not a view of the function's locals, but a copy. Therefore, modification of the dictionary returned from `locals()` will not modify the local variables of the function.\n\n\n## Recommendation\nIf the intention is to modify a local variable, then do so directly.\n\n\n## Example\nIn this example, rather than assigning to the variable `z` directly, the dictionary returned by `locals()` is modified.\n\n\n```python\n\ndef modifies_locals_sum(x, y):\n    locals()['z'] = x + y\n    #z will not be defined as modifications to locals() do not alter the local variables.\n    return z\n\ndef fixed_sum(x, y):\n    z = x + y\n    return z\n\n\n```\n\n## References\n* Python Language Reference: [The for statement](http://docs.python.org/2/reference/compound_stmts.html#the-for-statement).\n* Python Tutorial: [for statements](http://docs.python.org/2/tutorial/controlflow.html#for-statements).\n"},"properties":{"tags":["quality","reliability","correctness"],"description":"Modifications of the dictionary returned by locals() are not propagated to the local variables of a function.","id":"py/modification-of-locals","kind":"problem","name":"Modification of dictionary returned by locals()","precision":"very-high","problem.severity":"warning","sub-severity":"low"}},{"id":"py/asserts-tuple","name":"py/asserts-tuple","shortDescription":{"text":"Asserting a tuple"},"fullDescription":{"text":"Using an assert statement to test a tuple provides no validity checking."},"defaultConfiguration":{"enabled":true,"level":"error"},"help":{"text":"# Asserting a tuple\nWhen you define an `assert` statement to test a tuple the test will either always succeed (if the tuple is non-empty) or always fail (if the tuple is empty).\n\nThis error usually occurs when the programmer writes ` assert (condition, message) ` instead of the correct form` assert condition, message `\n\n\n## Recommendation\nReview the code and determine the purpose of the `assert` statement:\n\n* If the \"tuple\" has been created in error, then remove the parentheses and correct the statement\n* If validation of a tuple is intended, then you should define an `assert` statement for each element of the tuple.\n\n## Example\nThe statement `assert (xxx, yyy)` attempts to test a \"tuple\" `(xxx, yyy)`. The original intention may be any of the alternatives listed below:\n\n\n```python\nassert xxx and yyy   # Alternative 1a. Check both expressions are true\n\nassert xxx, yyy      # Alternative 1b. Check 'xxx' is true, 'yyy' is the failure message.\n\ntuple = (xxx, yyy)   # Alternative 2. Check both elements of the tuple match expectations.\nassert tuple[0]==xxx\nassert tuple[1]==yyy\n\n```\nIf you want to define a validity check on the values of a tuple then these must be tested individually.\n\n\n## References\n* Python Language Reference: [The assert statement](http://docs.python.org/2.7/reference/simple_stmts.html#the-assert-statement).\n* Tutorials Point: [Assertions in Python](http://www.tutorialspoint.com/python/assertions_in_python.htm).\n* Common Weakness Enumeration: [CWE-670](https://cwe.mitre.org/data/definitions/670.html).\n","markdown":"# Asserting a tuple\nWhen you define an `assert` statement to test a tuple the test will either always succeed (if the tuple is non-empty) or always fail (if the tuple is empty).\n\nThis error usually occurs when the programmer writes ` assert (condition, message) ` instead of the correct form` assert condition, message `\n\n\n## Recommendation\nReview the code and determine the purpose of the `assert` statement:\n\n* If the \"tuple\" has been created in error, then remove the parentheses and correct the statement\n* If validation of a tuple is intended, then you should define an `assert` statement for each element of the tuple.\n\n## Example\nThe statement `assert (xxx, yyy)` attempts to test a \"tuple\" `(xxx, yyy)`. The original intention may be any of the alternatives listed below:\n\n\n```python\nassert xxx and yyy   # Alternative 1a. Check both expressions are true\n\nassert xxx, yyy      # Alternative 1b. Check 'xxx' is true, 'yyy' is the failure message.\n\ntuple = (xxx, yyy)   # Alternative 2. Check both elements of the tuple match expectations.\nassert tuple[0]==xxx\nassert tuple[1]==yyy\n\n```\nIf you want to define a validity check on the values of a tuple then these must be tested individually.\n\n\n## References\n* Python Language Reference: [The assert statement](http://docs.python.org/2.7/reference/simple_stmts.html#the-assert-statement).\n* Tutorials Point: [Assertions in Python](http://www.tutorialspoint.com/python/assertions_in_python.htm).\n* Common Weakness Enumeration: [CWE-670](https://cwe.mitre.org/data/definitions/670.html).\n"},"properties":{"tags":["quality","reliability","correctness","external/cwe/cwe-670"],"description":"Using an assert statement to test a tuple provides no validity checking.","id":"py/asserts-tuple","kind":"problem","name":"Asserting a tuple","precision":"very-high","problem.severity":"error","sub-severity":"low"}},{"id":"py/unnecessary-delete","name":"py/unnecessary-delete","shortDescription":{"text":"Unnecessary delete statement in function"},"fullDescription":{"text":"Using a 'delete' statement to delete a local variable is unnecessary, because the variable is deleted automatically when the function exits."},"defaultConfiguration":{"enabled":true,"level":"warning"},"help":{"text":"# Unnecessary delete statement in function\nPassing a local variable to a `del` statement results in that variable being removed from the local namespace. When exiting a function all local variables are deleted, so it is unnecessary to explicitly delete variables in such cases.\n\n\n## Recommendation\nRemove the `del` statement.\n\n\n## Example\nIn the function below, the variable `x` is assigned a value that is used for a calculation, and is then explicitly deleted before the function exits. In this case, the delete statement can be removed without changing the behavior of the function.\n\n\n```python\ndef unnecessary_delete():\n    x = get_some_object()\n    do_calculation(x)\n    del x                       # This del statement is unnecessary\n\n```\n\n## References\n* Python: [The 'del' statement](https://docs.python.org/2/reference/simple_stmts.html#the-del-statement).\n* Python/C API Reference Manual: [Reference counts](https://docs.python.org/2.0/api/refcounts.html).\n","markdown":"# Unnecessary delete statement in function\nPassing a local variable to a `del` statement results in that variable being removed from the local namespace. When exiting a function all local variables are deleted, so it is unnecessary to explicitly delete variables in such cases.\n\n\n## Recommendation\nRemove the `del` statement.\n\n\n## Example\nIn the function below, the variable `x` is assigned a value that is used for a calculation, and is then explicitly deleted before the function exits. In this case, the delete statement can be removed without changing the behavior of the function.\n\n\n```python\ndef unnecessary_delete():\n    x = get_some_object()\n    do_calculation(x)\n    del x                       # This del statement is unnecessary\n\n```\n\n## References\n* Python: [The 'del' statement](https://docs.python.org/2/reference/simple_stmts.html#the-del-statement).\n* Python/C API Reference Manual: [Reference counts](https://docs.python.org/2.0/api/refcounts.html).\n"},"properties":{"tags":["maintainability","useless-code"],"description":"Using a 'delete' statement to delete a local variable is\n              unnecessary, because the variable is deleted automatically when\n              the function exits.","id":"py/unnecessary-delete","kind":"problem","name":"Unnecessary delete statement in function","precision":"high","problem.severity":"warning","sub-severity":"low"}},{"id":"py/unused-import","name":"py/unused-import","shortDescription":{"text":"Unused import"},"fullDescription":{"text":"Import is not required as it is not used"},"defaultConfiguration":{"enabled":true,"level":"note"},"help":{"text":"# Unused import\nA module is imported (using the `import` statement) but that module is never used. This creates a dependency that does not need to exist and makes the code more difficult to read.\n\n\n## Recommendation\nDelete the import statement.\n\n\n## References\n* Python: [import statement](http://docs.python.org/reference/simple_stmts.html#import).\n","markdown":"# Unused import\nA module is imported (using the `import` statement) but that module is never used. This creates a dependency that does not need to exist and makes the code more difficult to read.\n\n\n## Recommendation\nDelete the import statement.\n\n\n## References\n* Python: [import statement](http://docs.python.org/reference/simple_stmts.html#import).\n"},"properties":{"tags":["quality","maintainability","useless-code"],"description":"Import is not required as it is not used","id":"py/unused-import","kind":"problem","name":"Unused import","precision":"very-high","problem.severity":"recommendation","sub-severity":"high"}},{"id":"py/syntax-error","name":"py/syntax-error","shortDescription":{"text":"Syntax error"},"fullDescription":{"text":"Syntax errors cause failures at runtime and prevent analysis of the code."},"defaultConfiguration":{"enabled":true,"level":"error"},"help":{"text":"# Syntax error\nSyntax errors prevent a module being evaluated and thus imported. An attempt to import a module with invalid syntax will fail; a `SyntaxError` will be raised.\n\nA common cause of syntax errors is the difference in syntax between Python 2 and Python 3. In particular, a syntax error may be alerted if a Python 3 file is assumed to be compatible with Python 2 (or vice versa). Explicitly specifying the expected Python version can help prevent this.\n\nThe existence of a syntax error in a module may suggest other problems as well. Either the module is never imported in practice and could be deleted or a `try` statement around the import is mistakenly discarding the `SyntaxError`.\n\n\n## Recommendation\nFixing the syntax error is the obvious fix. However, it is worth investigating why a module containing a syntax error was able to persist and address that problem as well.\n\nIf you suspect that the syntax error is caused by the analysis using the wrong version of Python, consider specifying the version explicitly. When you run code scanning using the CodeQL action, you can configure the Python version to use. For more information, see [Analyzing Python dependencies](https://docs.github.com/en/code-security/code-scanning/automatically-scanning-your-code-for-vulnerabilities-and-errors/configuring-code-scanning#analyzing-python-dependencies).\n\n\n## References\n* Python Tutorial: [SyntaxErrors.](http://docs.python.org/tutorial/errors.html#syntax-errors)\n","markdown":"# Syntax error\nSyntax errors prevent a module being evaluated and thus imported. An attempt to import a module with invalid syntax will fail; a `SyntaxError` will be raised.\n\nA common cause of syntax errors is the difference in syntax between Python 2 and Python 3. In particular, a syntax error may be alerted if a Python 3 file is assumed to be compatible with Python 2 (or vice versa). Explicitly specifying the expected Python version can help prevent this.\n\nThe existence of a syntax error in a module may suggest other problems as well. Either the module is never imported in practice and could be deleted or a `try` statement around the import is mistakenly discarding the `SyntaxError`.\n\n\n## Recommendation\nFixing the syntax error is the obvious fix. However, it is worth investigating why a module containing a syntax error was able to persist and address that problem as well.\n\nIf you suspect that the syntax error is caused by the analysis using the wrong version of Python, consider specifying the version explicitly. When you run code scanning using the CodeQL action, you can configure the Python version to use. For more information, see [Analyzing Python dependencies](https://docs.github.com/en/code-security/code-scanning/automatically-scanning-your-code-for-vulnerabilities-and-errors/configuring-code-scanning#analyzing-python-dependencies).\n\n\n## References\n* Python Tutorial: [SyntaxErrors.](http://docs.python.org/tutorial/errors.html#syntax-errors)\n"},"properties":{"tags":["quality","reliability","correctness"],"description":"Syntax errors cause failures at runtime and prevent analysis of the code.","id":"py/syntax-error","kind":"problem","name":"Syntax error","precision":"high","problem.severity":"error","sub-severity":"high"}},{"id":"py/polluting-import","name":"py/polluting-import","shortDescription":{"text":"'import *' may pollute namespace"},"fullDescription":{"text":"Importing a module using 'import *' may unintentionally pollute the global namespace if the module does not define `__all__`"},"defaultConfiguration":{"enabled":true,"level":"note"},"help":{"text":"# 'import *' may pollute namespace\nWhen you import a module using `from xxx import *` all public names defined in the module are imported and bound in the local namespace of the `import` statement. The public names are determined by checking the `__all__` variable for the module. If ` __all__` is not defined then all names within the module that do not start with an underscore character are imported. This pollutes the current namespace with names that are not part of the public API for the module.\n\n\n## Recommendation\nThere are two ways to address this problem:\n\n* where possible, modify the module being imported *from* and define `__all__ ` to restrict the names to be imported\n* otherwise, explicitly import the values that you need.\n\n## Example\nThe following simple example shows how `__all__` controls the public names for the module `finance`.\n\n\n```python\n# Example module - finance.py\n\n__all__ = ['tax1', 'tax2']  #defines the names to import when '*' is used\n\ntax1 = 5\ntax2 = 10\ndef cost(): return 'cost'\n\n# Imported into code using\n\nfrom finance import *\n\nprint tax1\nprint tax2\n```\nIf the `finance` module did not include a definition of `__all__`, then you could replace `from finance import *` with `from finance import tax1, tax2`.\n\n\n## References\n* Python Language Reference: [The import statement](http://docs.python.org/2/reference/simple_stmts.html#import).\n* Python Tutorial: [Modules](http://docs.python.org/2/tutorial/modules.html).\n","markdown":"# 'import *' may pollute namespace\nWhen you import a module using `from xxx import *` all public names defined in the module are imported and bound in the local namespace of the `import` statement. The public names are determined by checking the `__all__` variable for the module. If ` __all__` is not defined then all names within the module that do not start with an underscore character are imported. This pollutes the current namespace with names that are not part of the public API for the module.\n\n\n## Recommendation\nThere are two ways to address this problem:\n\n* where possible, modify the module being imported *from* and define `__all__ ` to restrict the names to be imported\n* otherwise, explicitly import the values that you need.\n\n## Example\nThe following simple example shows how `__all__` controls the public names for the module `finance`.\n\n\n```python\n# Example module - finance.py\n\n__all__ = ['tax1', 'tax2']  #defines the names to import when '*' is used\n\ntax1 = 5\ntax2 = 10\ndef cost(): return 'cost'\n\n# Imported into code using\n\nfrom finance import *\n\nprint tax1\nprint tax2\n```\nIf the `finance` module did not include a definition of `__all__`, then you could replace `from finance import *` with `from finance import tax1, tax2`.\n\n\n## References\n* Python Language Reference: [The import statement](http://docs.python.org/2/reference/simple_stmts.html#import).\n* Python Tutorial: [Modules](http://docs.python.org/2/tutorial/modules.html).\n"},"properties":{"tags":["quality","maintainability","readability"],"description":"Importing a module using 'import *' may unintentionally pollute the global\n              namespace if the module does not define `__all__`","id":"py/polluting-import","kind":"problem","name":"'import *' may pollute namespace","precision":"very-high","problem.severity":"recommendation","sub-severity":"high"}},{"id":"py/import-and-import-from","name":"py/import-and-import-from","shortDescription":{"text":"Module is imported with 'import' and 'import from'"},"fullDescription":{"text":"A module is imported with the \"import\" and \"import from\" statements"},"defaultConfiguration":{"enabled":true,"level":"note"},"help":{"text":"# Module is imported with 'import' and 'import from'\nImporting a module twice using the `import xxx` and `from xxx import yyy` is confusing.\n\n\n## Recommendation\nRemove the `from xxx import yyy` statement. Add `yyy = xxx.yyy` if required.\n\n\n## Example\n\n```python\nimport os\nfrom os import walk\n\n```\n\n## References\n* Python Language Reference: [The import statement](http://docs.python.org/2/reference/simple_stmts.html#import).\n","markdown":"# Module is imported with 'import' and 'import from'\nImporting a module twice using the `import xxx` and `from xxx import yyy` is confusing.\n\n\n## Recommendation\nRemove the `from xxx import yyy` statement. Add `yyy = xxx.yyy` if required.\n\n\n## Example\n\n```python\nimport os\nfrom os import walk\n\n```\n\n## References\n* Python Language Reference: [The import statement](http://docs.python.org/2/reference/simple_stmts.html#import).\n"},"properties":{"tags":["quality","maintainability","readability"],"description":"A module is imported with the \"import\" and \"import from\" statements","id":"py/import-and-import-from","kind":"problem","name":"Module is imported with 'import' and 'import from'","precision":"very-high","problem.severity":"recommendation","sub-severity":"low"}},{"id":"py/import-of-mutable-attribute","name":"py/import-of-mutable-attribute","shortDescription":{"text":"Importing value of mutable attribute"},"fullDescription":{"text":"Importing the value of a mutable attribute directly means that changes in global state will not be observed locally."},"defaultConfiguration":{"enabled":true,"level":"warning"},"help":{"text":"# Importing value of mutable attribute\nExplicitly importing an attribute from a module into the current namespace means that the value of that attribute will not be updated if the value in the original module changes.\n\nThis can mean that changes in global state are not observed locally, which may lead to inconsistencies and possible errors.\n\n\n## Recommendation\nInstead of using `from module import attr`, simply import the module using `import module` and replace all uses of `attr` with `module.attr`.\n\n\n## Example\nIn the first of the two modules shown below, `from sys import stdout` is used to import the `stdout` attribute, rather than using `import sys` to import the module. Then `stdout` is used in the `main()` function.\n\n\n```python\nfrom sys import stdout\n\ndef main():\n    stdout.write(\"Hello World!\")\n    \n\n```\nIn the second module, below, a function, `redirect_to_file` is defined to collect the output from `sys.stdout` and save it to a file. However, `redirect_to_file` will not work correctly when passed the `main()` function. This is because the `main()` function will not see the change to `sys.stdout`, as it uses its own version of `stdout` that was defined when the module was loaded.\n\n\n```python\nimport sys\n\ndef redirect_to_file(function, args, kwargs, filename):\n    with open(filename) as out:\n        orig_stdout = sys.stdout\n        sys.stdout = out\n        try:\n            function(*args, **kwargs)\n        finally:\n            sys.stdout = orig_stdout\n\n\n```\nThe problem can be fixed by rewriting the first module to import the `sys` module and write to `sys.stdout`, as shown below.\n\n\n```python\nimport sys\n\ndef main():\n    sys.stdout.write(\"Hello World!\")\n\n```\n\n## References\n* Python Language Reference: [The import statement](http://docs.python.org/2/reference/simple_stmts.html#import).\n* Python Tutorial: [Modules](http://docs.python.org/2/tutorial/modules.html).\n","markdown":"# Importing value of mutable attribute\nExplicitly importing an attribute from a module into the current namespace means that the value of that attribute will not be updated if the value in the original module changes.\n\nThis can mean that changes in global state are not observed locally, which may lead to inconsistencies and possible errors.\n\n\n## Recommendation\nInstead of using `from module import attr`, simply import the module using `import module` and replace all uses of `attr` with `module.attr`.\n\n\n## Example\nIn the first of the two modules shown below, `from sys import stdout` is used to import the `stdout` attribute, rather than using `import sys` to import the module. Then `stdout` is used in the `main()` function.\n\n\n```python\nfrom sys import stdout\n\ndef main():\n    stdout.write(\"Hello World!\")\n    \n\n```\nIn the second module, below, a function, `redirect_to_file` is defined to collect the output from `sys.stdout` and save it to a file. However, `redirect_to_file` will not work correctly when passed the `main()` function. This is because the `main()` function will not see the change to `sys.stdout`, as it uses its own version of `stdout` that was defined when the module was loaded.\n\n\n```python\nimport sys\n\ndef redirect_to_file(function, args, kwargs, filename):\n    with open(filename) as out:\n        orig_stdout = sys.stdout\n        sys.stdout = out\n        try:\n            function(*args, **kwargs)\n        finally:\n            sys.stdout = orig_stdout\n\n\n```\nThe problem can be fixed by rewriting the first module to import the `sys` module and write to `sys.stdout`, as shown below.\n\n\n```python\nimport sys\n\ndef main():\n    sys.stdout.write(\"Hello World!\")\n\n```\n\n## References\n* Python Language Reference: [The import statement](http://docs.python.org/2/reference/simple_stmts.html#import).\n* Python Tutorial: [Modules](http://docs.python.org/2/tutorial/modules.html).\n"},"properties":{"tags":["reliability","maintainability","modularity"],"description":"Importing the value of a mutable attribute directly means that changes in global state will not be observed locally.","id":"py/import-of-mutable-attribute","kind":"problem","name":"Importing value of mutable attribute","precision":"medium","problem.severity":"warning","sub-severity":"high"}},{"id":"py/encoding-error","name":"py/encoding-error","shortDescription":{"text":"Encoding error"},"fullDescription":{"text":"Encoding errors cause failures at runtime and prevent analysis of the code."},"defaultConfiguration":{"enabled":true,"level":"error"},"help":{"text":"# Encoding error\nEncoding errors prevent a module being evaluated and thus imported. An attempt to import a module with an invalid encoding will fail; a `SyntaxError` will be raised. Note that in Python 2, the default encoding is ASCII.\n\nThe existence of an encoding error in a module may suggest other problems as well. Either the module is never imported in practice and could be deleted or a `try` statement around the import is mistakenly discarding the `SyntaxError`.\n\n\n## Recommendation\nFixing the encoding error is the obvious fix. However, it is worth investigating why a module containing an encoding error was able to persist and address that problem as well.\n\nIf a different encoding should be used for the file, specify it explicitly by putting an encoding specification at the top of the file. For instance, to specify UTF-8 encoding, add the line `# coding=utf-8`.\n\n\n## References\n* Python PEPs: [PEP 263 — Defining Python Source Code Encodings.](https://www.python.org/dev/peps/pep-0263/)\n* Python Tutorial: [SyntaxErrors.](http://docs.python.org/tutorial/errors.html#syntax-errors)\n","markdown":"# Encoding error\nEncoding errors prevent a module being evaluated and thus imported. An attempt to import a module with an invalid encoding will fail; a `SyntaxError` will be raised. Note that in Python 2, the default encoding is ASCII.\n\nThe existence of an encoding error in a module may suggest other problems as well. Either the module is never imported in practice and could be deleted or a `try` statement around the import is mistakenly discarding the `SyntaxError`.\n\n\n## Recommendation\nFixing the encoding error is the obvious fix. However, it is worth investigating why a module containing an encoding error was able to persist and address that problem as well.\n\nIf a different encoding should be used for the file, specify it explicitly by putting an encoding specification at the top of the file. For instance, to specify UTF-8 encoding, add the line `# coding=utf-8`.\n\n\n## References\n* Python PEPs: [PEP 263 — Defining Python Source Code Encodings.](https://www.python.org/dev/peps/pep-0263/)\n* Python Tutorial: [SyntaxErrors.](http://docs.python.org/tutorial/errors.html#syntax-errors)\n"},"properties":{"tags":["quality","reliability","correctness"],"description":"Encoding errors cause failures at runtime and prevent analysis of the code.","id":"py/encoding-error","kind":"problem","name":"Encoding error","precision":"high","problem.severity":"error","sub-severity":"low"}},{"id":"py/repeated-import","name":"py/repeated-import","shortDescription":{"text":"Module is imported more than once"},"fullDescription":{"text":"Importing a module a second time has no effect and impairs readability"},"defaultConfiguration":{"enabled":true,"level":"note"},"help":{"text":"# Module is imported more than once\nImporting the same module more than once has no effect as each module is only loaded once. It also confuses readers of the code.\n\n\n## Recommendation\nRemove the second import.\n\n\n## Example\n\n```python\nimport module1\nimport module2\nimport module1 # Duplicate import\n\n```\n\n## References\n* Python: [import statement](http://docs.python.org/reference/simple_stmts.html#import).\n","markdown":"# Module is imported more than once\nImporting the same module more than once has no effect as each module is only loaded once. It also confuses readers of the code.\n\n\n## Recommendation\nRemove the second import.\n\n\n## Example\n\n```python\nimport module1\nimport module2\nimport module1 # Duplicate import\n\n```\n\n## References\n* Python: [import statement](http://docs.python.org/reference/simple_stmts.html#import).\n"},"properties":{"tags":["quality","maintainability","useless-code"],"description":"Importing a module a second time has no effect and impairs readability","id":"py/repeated-import","kind":"problem","name":"Module is imported more than once","precision":"very-high","problem.severity":"recommendation","sub-severity":"high"}},{"id":"py/cyclic-import","name":"py/cyclic-import","shortDescription":{"text":"Cyclic import"},"fullDescription":{"text":"Module forms part of an import cycle, thereby indirectly importing itself."},"defaultConfiguration":{"enabled":true,"level":"note"},"help":{"text":"# Cyclic import\nA cyclic import is an `import` which imports another module and that module imports (possibly indirectly) the module which contains the `import` statement.\n\nCyclic imports indicate that two modules are circularly dependent. This means that the modules cannot be tested independently, and it makes it harder to understand the architecture of the system.\n\n\n## Recommendation\nThe cycle may be broken by removing any one import. If only one function or method requires the import, then consider moving that to the other module and deleting the import. If the two modules are more intimately connected, then move the inter-dependent parts into a third module and have both the original modules import that.\n\n\n## References\n* Python Language Reference: [The import statement](http://docs.python.org/2/reference/simple_stmts.html#import).\n* Python: [Modules](http://docs.python.org/2/tutorial/modules.html).\n* Effbot: [Import Confusion](https://web.archive.org/web/20200917011425/https://effbot.org/zone/import-confusion.htm).\n","markdown":"# Cyclic import\nA cyclic import is an `import` which imports another module and that module imports (possibly indirectly) the module which contains the `import` statement.\n\nCyclic imports indicate that two modules are circularly dependent. This means that the modules cannot be tested independently, and it makes it harder to understand the architecture of the system.\n\n\n## Recommendation\nThe cycle may be broken by removing any one import. If only one function or method requires the import, then consider moving that to the other module and deleting the import. If the two modules are more intimately connected, then move the inter-dependent parts into a third module and have both the original modules import that.\n\n\n## References\n* Python Language Reference: [The import statement](http://docs.python.org/2/reference/simple_stmts.html#import).\n* Python: [Modules](http://docs.python.org/2/tutorial/modules.html).\n* Effbot: [Import Confusion](https://web.archive.org/web/20200917011425/https://effbot.org/zone/import-confusion.htm).\n"},"properties":{"tags":["reliability","maintainability","modularity"],"description":"Module forms part of an import cycle, thereby indirectly importing itself.","id":"py/cyclic-import","kind":"problem","name":"Cyclic import","precision":"high","problem.severity":"recommendation","sub-severity":"low"}},{"id":"py/import-own-module","name":"py/import-own-module","shortDescription":{"text":"Module imports itself"},"fullDescription":{"text":"A module imports itself"},"defaultConfiguration":{"enabled":true,"level":"note"},"help":{"text":"# Module imports itself\nThere is no need for a module to import itself. A module importing itself may lead to errors as the module may be in an incomplete state when imported by itself.\n\n\n## Recommendation\nRemove the import statement. Convert all expressions of the form `mod.name` where \"mod\" is the name of the current module to `name`.\n\n\n## Example\nIn this example the module, `ModuleImportsItself` imports itself and has an expression referencing the module it is in as well.\n\n\n```python\nimport ModuleImportsItself\n\ndef factorial(n):\n    if n <= 0:\n        return 1\n    return n * ModuleImportsItself.factorial(n - 1)\n```\nThe import can be removed and the reference can be corrected.\n\n\n```python\n\ndef factorial(n):\n    if n <= 0:\n        return 1\n    return n * factorial(n - 1)\n```\n\n## References\n* Python: [Modules](http://docs.python.org/2/tutorial/modules.html).\n","markdown":"# Module imports itself\nThere is no need for a module to import itself. A module importing itself may lead to errors as the module may be in an incomplete state when imported by itself.\n\n\n## Recommendation\nRemove the import statement. Convert all expressions of the form `mod.name` where \"mod\" is the name of the current module to `name`.\n\n\n## Example\nIn this example the module, `ModuleImportsItself` imports itself and has an expression referencing the module it is in as well.\n\n\n```python\nimport ModuleImportsItself\n\ndef factorial(n):\n    if n <= 0:\n        return 1\n    return n * ModuleImportsItself.factorial(n - 1)\n```\nThe import can be removed and the reference can be corrected.\n\n\n```python\n\ndef factorial(n):\n    if n <= 0:\n        return 1\n    return n * factorial(n - 1)\n```\n\n## References\n* Python: [Modules](http://docs.python.org/2/tutorial/modules.html).\n"},"properties":{"tags":["quality","maintainability","useless-code"],"description":"A module imports itself","id":"py/import-own-module","kind":"problem","name":"Module imports itself","precision":"very-high","problem.severity":"recommendation","sub-severity":"high"}},{"id":"py/unsafe-cyclic-import","name":"py/unsafe-cyclic-import","shortDescription":{"text":"Module-level cyclic import"},"fullDescription":{"text":"Module uses member of cyclically imported module, which can lead to failure at import time."},"defaultConfiguration":{"enabled":true,"level":"error"},"help":{"text":"# Module-level cyclic import\nA cyclic import is an `import` which imports another module and that module imports (possibly indirectly) the module which contains the `import` statement. If all imports in a cyclic import occur at module level, then a module will be imported when it is part way through its initialization. This may rest in surprising errors, as parts of the module being imported may not yet exist.\n\nIn addition to the possible errors, cyclic imports indicate that two modules are circularly dependent. This means that the modules cannot be tested independently, and it makes it harder to understand the architecture of the system.\n\n\n## Recommendation\nThe cycle may be broken by removing any one import. If only one function or method requires the import, then consider moving that to the other module and deleting the import. If the two modules are more intimately connected, then move the inter-dependent parts into a third module and have both the original modules import that.\n\n\n## References\n* Python Language Reference: [The import statement](http://docs.python.org/2/reference/simple_stmts.html#import).\n* Python: [Modules](http://docs.python.org/2/tutorial/modules.html).\n* Effbot: [Import Confusion](https://web.archive.org/web/20200917011425/https://effbot.org/zone/import-confusion.htm).\n","markdown":"# Module-level cyclic import\nA cyclic import is an `import` which imports another module and that module imports (possibly indirectly) the module which contains the `import` statement. If all imports in a cyclic import occur at module level, then a module will be imported when it is part way through its initialization. This may rest in surprising errors, as parts of the module being imported may not yet exist.\n\nIn addition to the possible errors, cyclic imports indicate that two modules are circularly dependent. This means that the modules cannot be tested independently, and it makes it harder to understand the architecture of the system.\n\n\n## Recommendation\nThe cycle may be broken by removing any one import. If only one function or method requires the import, then consider moving that to the other module and deleting the import. If the two modules are more intimately connected, then move the inter-dependent parts into a third module and have both the original modules import that.\n\n\n## References\n* Python Language Reference: [The import statement](http://docs.python.org/2/reference/simple_stmts.html#import).\n* Python: [Modules](http://docs.python.org/2/tutorial/modules.html).\n* Effbot: [Import Confusion](https://web.archive.org/web/20200917011425/https://effbot.org/zone/import-confusion.htm).\n"},"properties":{"tags":["reliability","correctness","types"],"comprehension":"0.5","description":"Module uses member of cyclically imported module, which can lead to failure at import time.","id":"py/unsafe-cyclic-import","kind":"problem","name":"Module-level cyclic import","precision":"high","problem.severity":"error","sub-severity":"low"}},{"id":"py/import-deprecated-module","name":"py/import-deprecated-module","shortDescription":{"text":"Import of deprecated module"},"fullDescription":{"text":"Import of a deprecated module"},"defaultConfiguration":{"enabled":true,"level":"warning"},"help":{"text":"# Import of deprecated module\nA module is deprecated when it cannot or will not be maintained indefinitely in the standard library. Deprecated modules may not receive security fixes or other important updates. See PEP 4 for a list of all deprecated modules.\n\n\n## Recommendation\nDo not import the deprecated module. Replace uses of it with uses of a better maintained module.\n\n\n## References\n* Python PEPs: [PEP 4 -- Deprecation of Standard Modules ](http://www.python.org/dev/peps/pep-0004/).\n* Common Weakness Enumeration: [CWE-477](https://cwe.mitre.org/data/definitions/477.html).\n","markdown":"# Import of deprecated module\nA module is deprecated when it cannot or will not be maintained indefinitely in the standard library. Deprecated modules may not receive security fixes or other important updates. See PEP 4 for a list of all deprecated modules.\n\n\n## Recommendation\nDo not import the deprecated module. Replace uses of it with uses of a better maintained module.\n\n\n## References\n* Python PEPs: [PEP 4 -- Deprecation of Standard Modules ](http://www.python.org/dev/peps/pep-0004/).\n* Common Weakness Enumeration: [CWE-477](https://cwe.mitre.org/data/definitions/477.html).\n"},"properties":{"tags":["maintainability","external/cwe/cwe-477"],"description":"Import of a deprecated module","id":"py/import-deprecated-module","kind":"problem","name":"Import of deprecated module","precision":"very-high","problem.severity":"warning","sub-severity":"high"}},{"id":"py/imprecise-assert","name":"py/imprecise-assert","shortDescription":{"text":"Imprecise assert"},"fullDescription":{"text":"Using 'assertTrue' or 'assertFalse' rather than a more specific assertion can give uninformative failure messages."},"defaultConfiguration":{"enabled":true,"level":"note"},"help":{"text":"# Imprecise assert\nThe class `unittest.TestCase` provides a range of assertion methods. As well as the general forms `assertTrue()` and `assertFalse()` more specific forms such as `assertGreaterEquals()` and `assertNotIn()` are provided. By using the more specific forms it is possible to get more precise and informative failure messages in the event of a test failing. This can speed up the debugging process.\n\n\n## Recommendation\nReplace all calls to `assertTrue()` and `assertFalse()` that do not provide a custom failure message with a more specific variant. Alternatively, provide a tailored failure message using the `assertTrue(condition, message)` form.\n\n\n## Example\nIn this example, `assertTrue()` and `assertFalse()` are used.\n\n\n```python\nfrom unittest import TestCase\n\nclass MyTest(TestCase):\n    \n    \n    def testInts(self):\n        self.assertTrue(1 == 1)\n        self.assertFalse(1 > 2)\n        self.assertTrue(1 in []) #This will fail\n\n```\nThis will make it more difficult to determine what has gone wrong when `self.assertTrue(1 in [])` fails. The failure message \"AssertionError: False is not true\" is not very helpful.\n\nA more useful error message can be generated by changing the asserts to the more specific forms as in the following example.\n\n\n```python\nfrom unittest import TestCase\n\nclass MyTest(TestCase):\n    \n    \n    def testInts(self):\n        self.assertEqual(1, 1)\n        self.assertLessEqual(1, 2)\n        self.assertIn(1, []) #This will fail\n\n```\nIn this case, the failure message \"AssertionError: 1 not found in \\[\\]\" is much more informative.\n\n\n## References\n* Python library reference: [TestCase.assertEqual](https://docs.python.org/library/unittest.html#unittest.TestCase.assertEqual).\n","markdown":"# Imprecise assert\nThe class `unittest.TestCase` provides a range of assertion methods. As well as the general forms `assertTrue()` and `assertFalse()` more specific forms such as `assertGreaterEquals()` and `assertNotIn()` are provided. By using the more specific forms it is possible to get more precise and informative failure messages in the event of a test failing. This can speed up the debugging process.\n\n\n## Recommendation\nReplace all calls to `assertTrue()` and `assertFalse()` that do not provide a custom failure message with a more specific variant. Alternatively, provide a tailored failure message using the `assertTrue(condition, message)` form.\n\n\n## Example\nIn this example, `assertTrue()` and `assertFalse()` are used.\n\n\n```python\nfrom unittest import TestCase\n\nclass MyTest(TestCase):\n    \n    \n    def testInts(self):\n        self.assertTrue(1 == 1)\n        self.assertFalse(1 > 2)\n        self.assertTrue(1 in []) #This will fail\n\n```\nThis will make it more difficult to determine what has gone wrong when `self.assertTrue(1 in [])` fails. The failure message \"AssertionError: False is not true\" is not very helpful.\n\nA more useful error message can be generated by changing the asserts to the more specific forms as in the following example.\n\n\n```python\nfrom unittest import TestCase\n\nclass MyTest(TestCase):\n    \n    \n    def testInts(self):\n        self.assertEqual(1, 1)\n        self.assertLessEqual(1, 2)\n        self.assertIn(1, []) #This will fail\n\n```\nIn this case, the failure message \"AssertionError: 1 not found in \\[\\]\" is much more informative.\n\n\n## References\n* Python library reference: [TestCase.assertEqual](https://docs.python.org/library/unittest.html#unittest.TestCase.assertEqual).\n"},"properties":{"tags":["quality","maintainability","readability"],"description":"Using 'assertTrue' or 'assertFalse' rather than a more specific assertion can give uninformative failure messages.","id":"py/imprecise-assert","kind":"problem","name":"Imprecise assert","precision":"very-high","problem.severity":"recommendation","sub-severity":"high"}},{"id":"py/multiple-definition","name":"py/multiple-definition","shortDescription":{"text":"Variable defined multiple times"},"fullDescription":{"text":"Assignment to a variable occurs multiple times without any intermediate use of that variable"},"defaultConfiguration":{"enabled":true,"level":"warning"},"help":{"text":"# Variable defined multiple times\nMultiple assignments to a single variable without an intervening usage makes the first assignment redundant. Its value is lost.\n\n\n## Recommendation\nEnsure that the second assignment is in fact correct. Then delete the first assignment (taking care not to delete right hand side if it has side effects).\n\n\n## Example\nIn this example, `x` is assigned the value of 42 but then the value is changed to 12 before `x` is used. This makes the first assignment useless.\n\n\n```python\nx = 42\nx = 12\nprint x\n```\n\n## References\n* Python: [Assignment statements](http://docs.python.org/reference/simple_stmts.html#assignment-statements).\n* Common Weakness Enumeration: [CWE-563](https://cwe.mitre.org/data/definitions/563.html).\n","markdown":"# Variable defined multiple times\nMultiple assignments to a single variable without an intervening usage makes the first assignment redundant. Its value is lost.\n\n\n## Recommendation\nEnsure that the second assignment is in fact correct. Then delete the first assignment (taking care not to delete right hand side if it has side effects).\n\n\n## Example\nIn this example, `x` is assigned the value of 42 but then the value is changed to 12 before `x` is used. This makes the first assignment useless.\n\n\n```python\nx = 42\nx = 12\nprint x\n```\n\n## References\n* Python: [Assignment statements](http://docs.python.org/reference/simple_stmts.html#assignment-statements).\n* Common Weakness Enumeration: [CWE-563](https://cwe.mitre.org/data/definitions/563.html).\n"},"properties":{"tags":["quality","maintainability","useless-code","external/cwe/cwe-563"],"description":"Assignment to a variable occurs multiple times without any intermediate use of that variable","id":"py/multiple-definition","kind":"problem","name":"Variable defined multiple times","precision":"very-high","problem.severity":"warning","sub-severity":"low"}},{"id":"py/unused-global-variable","name":"py/unused-global-variable","shortDescription":{"text":"Unused global variable"},"fullDescription":{"text":"Global variable is defined but not used"},"defaultConfiguration":{"enabled":true,"level":"note"},"help":{"text":"# Unused global variable\nA global (module-level) variable is defined (by an assignment) but never used and is not explicitly made public by inclusion in the `__all__` list.\n\nIt is sometimes necessary to have a variable which is not used. These unused variables should have distinctive names, to make it clear to readers of the code that they are deliberately not used. The most common conventions for indicating this are to name the variable `_` or to start the name of the variable with `unused` or `_unused`.\n\nThe query accepts the following names for variables that are intended to be unused:\n\n* Any name consisting entirely of underscores.\n* Any name containing `unused`.\n* The names `dummy` or `empty`.\n* Any \"special\" name of the form `__xxx__`.\nVariables that are defined in a group, for example `x, y = func()` are handled collectively. If they are all unused, then this is reported. Otherwise they are all treated as used.\n\n\n## Recommendation\nIf the variable is included for documentation purposes or is otherwise intentionally unused, then change its name to indicate that it is unused, otherwise delete the assignment (taking care not to delete right hand side if it has side effects).\n\n\n## Example\nIn this example, the `random_no` variable is never read but its assignment has a side effect. Because of this it is important to only remove the left hand side of the assignment in line 9.\n\n\n```python\nimport random\n\ndef write_random_to_file():\n    no = random.randint(1, 10)\n    with open(\"random.txt\", \"w\") as file:\n        file.write(str(no))\n    return no\n\nrandom_no = write_random_to_file()\n```\n\n## References\n* Python: [Assignment statements](http://docs.python.org/reference/simple_stmts.html#assignment-statements), [The import statement](http://docs.python.org/reference/simple_stmts.html#the-import-statement).\n* Python Tutorial: [Importing \\* from a package](http://docs.python.org/2/tutorial/modules.html#importing-from-a-package).\n* Common Weakness Enumeration: [CWE-563](https://cwe.mitre.org/data/definitions/563.html).\n","markdown":"# Unused global variable\nA global (module-level) variable is defined (by an assignment) but never used and is not explicitly made public by inclusion in the `__all__` list.\n\nIt is sometimes necessary to have a variable which is not used. These unused variables should have distinctive names, to make it clear to readers of the code that they are deliberately not used. The most common conventions for indicating this are to name the variable `_` or to start the name of the variable with `unused` or `_unused`.\n\nThe query accepts the following names for variables that are intended to be unused:\n\n* Any name consisting entirely of underscores.\n* Any name containing `unused`.\n* The names `dummy` or `empty`.\n* Any \"special\" name of the form `__xxx__`.\nVariables that are defined in a group, for example `x, y = func()` are handled collectively. If they are all unused, then this is reported. Otherwise they are all treated as used.\n\n\n## Recommendation\nIf the variable is included for documentation purposes or is otherwise intentionally unused, then change its name to indicate that it is unused, otherwise delete the assignment (taking care not to delete right hand side if it has side effects).\n\n\n## Example\nIn this example, the `random_no` variable is never read but its assignment has a side effect. Because of this it is important to only remove the left hand side of the assignment in line 9.\n\n\n```python\nimport random\n\ndef write_random_to_file():\n    no = random.randint(1, 10)\n    with open(\"random.txt\", \"w\") as file:\n        file.write(str(no))\n    return no\n\nrandom_no = write_random_to_file()\n```\n\n## References\n* Python: [Assignment statements](http://docs.python.org/reference/simple_stmts.html#assignment-statements), [The import statement](http://docs.python.org/reference/simple_stmts.html#the-import-statement).\n* Python Tutorial: [Importing \\* from a package](http://docs.python.org/2/tutorial/modules.html#importing-from-a-package).\n* Common Weakness Enumeration: [CWE-563](https://cwe.mitre.org/data/definitions/563.html).\n"},"properties":{"tags":["quality","maintainability","useless-code","external/cwe/cwe-563"],"description":"Global variable is defined but not used","id":"py/unused-global-variable","kind":"problem","name":"Unused global variable","precision":"high","problem.severity":"recommendation","sub-severity":"low"}},{"id":"py/unused-loop-variable","name":"py/unused-loop-variable","shortDescription":{"text":"Suspicious unused loop iteration variable"},"fullDescription":{"text":"A loop iteration variable is unused, which suggests an error."},"defaultConfiguration":{"enabled":true,"level":"error"},"help":{"text":"# Suspicious unused loop iteration variable\nA for loop iteration variable is not used in the body of the loop, and the loop does not count the number of items in the sequence. This is suspicious as there is rarely any reason to iterate over a sequence and not use the contents. Not using the loop variable can often indicate a logical error or typo.\n\n\n## Recommendation\nCarefully check that the loop variable should not be used. If the variable is genuinely not being used and the code is correct, then rename the variable to `_` or `unused` to indicate to readers of the code that it is intentionally unused.\n\n\n## Example\nIn this example, the `for` loop iteration variable `x` is never used. It appears that the original `test` function was used to test `TypeA` and was subsequently modified to test `TypeB` as well.\n\n\n```python\n\n#\ndef test():\n    for t in [TypeA, TypeB]:\n        x = TypeA()\n        run_test(x)\n\n```\nIt is likely that the change from `x = TypeA()` to `x = t()` was forgotten. The fixed version is shown below.\n\n\n```python\n\n#\ndef test():\n    for t in [TypeA, TypeB]:\n        x = t\n        run_test(x)\n\n```\n\n## References\n* Python Language Reference: [The for statement](https://docs.python.org/reference/compound_stmts.html#the-for-statement).\n* Python Tutorial: [For statements](https://docs.python.org/tutorial/controlflow.html#for-statements).\n","markdown":"# Suspicious unused loop iteration variable\nA for loop iteration variable is not used in the body of the loop, and the loop does not count the number of items in the sequence. This is suspicious as there is rarely any reason to iterate over a sequence and not use the contents. Not using the loop variable can often indicate a logical error or typo.\n\n\n## Recommendation\nCarefully check that the loop variable should not be used. If the variable is genuinely not being used and the code is correct, then rename the variable to `_` or `unused` to indicate to readers of the code that it is intentionally unused.\n\n\n## Example\nIn this example, the `for` loop iteration variable `x` is never used. It appears that the original `test` function was used to test `TypeA` and was subsequently modified to test `TypeB` as well.\n\n\n```python\n\n#\ndef test():\n    for t in [TypeA, TypeB]:\n        x = TypeA()\n        run_test(x)\n\n```\nIt is likely that the change from `x = TypeA()` to `x = t()` was forgotten. The fixed version is shown below.\n\n\n```python\n\n#\ndef test():\n    for t in [TypeA, TypeB]:\n        x = t\n        run_test(x)\n\n```\n\n## References\n* Python Language Reference: [The for statement](https://docs.python.org/reference/compound_stmts.html#the-for-statement).\n* Python Tutorial: [For statements](https://docs.python.org/tutorial/controlflow.html#for-statements).\n"},"properties":{"tags":["quality","reliability","correctness"],"description":"A loop iteration variable is unused, which suggests an error.","id":"py/unused-loop-variable","kind":"problem","name":"Suspicious unused loop iteration variable","precision":"high","problem.severity":"error","sub-severity":"low"}},{"id":"py/uninitialized-local-variable","name":"py/uninitialized-local-variable","shortDescription":{"text":"Potentially uninitialized local variable"},"fullDescription":{"text":"Using a local variable before it is initialized causes an UnboundLocalError."},"defaultConfiguration":{"enabled":true,"level":"error"},"help":{"text":"# Potentially uninitialized local variable\nThis local variable may be used before it is defined. If a variable is assigned to in a function and not explicitly declared `global` or `nonlocal` then it is assumed to be a local variable. If it is used before it is defined then an `UnboundLocalError` will be raised.\n\n\n## Recommendation\nReview the code and consider the intended scope of the variable. Determine whether the variable should be global or local in scope. If a global variable is required then add a `global` statement, or in Python 3 you can use a `nonlocal` statement if the variable occurs in an enclosing function. Otherwise, ensure that the variable is defined before it is used.\n\n\n## Example\nThe following code includes different functions that use variables. `test1()` fails with an `UnboundLocalError` because the local variable `var` is used before it is initialized.\n\n\n```python\ndef test():\n    var = 1 \n    def print_var():\n        print var      # Use variable from outer scope\n    print_var()\n    print var \n\n\ndef test1():\n    var = 2 \n    def print_var():\n        print var       # Attempt to use variable from local scope. \n        var = 3         # Since this is not initialized yet, this results\n    print_var()         # in an UnboundLocalError\n    print var \n\n\ndef test2():\n    var = 2 \n    def print_var():\n        var = 3         # Initialize local version of the variable\n        print var       # Use variable from local scope.\n    print_var()         # Note that this local variable \"shadows\" the variable from\n    print var           # outer scope which makes code more difficult to interpret.\n\n\ndef test3():\n    var = 4\n    def print_var():\n        nonlocal var    # Use non-local variable from outer scope.\n        print var\n    print_var()\n    print var\n```\n\n## References\n* Python Standard Library: [Built-in Exceptions: UnboundLocalError](http://docs.python.org/library/exceptions.html#exceptions.UnboundLocalError).\n* Python Frequently Asked Questions: [Why am I getting an UnboundLocalError when the variable has a value?](http://docs.python.org/2/faq/programming.html#why-am-i-getting-an-unboundlocalerror-when-the-variable-has-a-value).\n* Python Course: [Global and Local Variables](http://www.python-course.eu/global_vs_local_variables.php).\n* Python Language Reference: [The global statement](http://docs.python.org/2.7/reference/simple_stmts.html#index-54), [The nonlocal statement](http://docs.python.org/3.3/reference/simple_stmts.html#index-43).\n","markdown":"# Potentially uninitialized local variable\nThis local variable may be used before it is defined. If a variable is assigned to in a function and not explicitly declared `global` or `nonlocal` then it is assumed to be a local variable. If it is used before it is defined then an `UnboundLocalError` will be raised.\n\n\n## Recommendation\nReview the code and consider the intended scope of the variable. Determine whether the variable should be global or local in scope. If a global variable is required then add a `global` statement, or in Python 3 you can use a `nonlocal` statement if the variable occurs in an enclosing function. Otherwise, ensure that the variable is defined before it is used.\n\n\n## Example\nThe following code includes different functions that use variables. `test1()` fails with an `UnboundLocalError` because the local variable `var` is used before it is initialized.\n\n\n```python\ndef test():\n    var = 1 \n    def print_var():\n        print var      # Use variable from outer scope\n    print_var()\n    print var \n\n\ndef test1():\n    var = 2 \n    def print_var():\n        print var       # Attempt to use variable from local scope. \n        var = 3         # Since this is not initialized yet, this results\n    print_var()         # in an UnboundLocalError\n    print var \n\n\ndef test2():\n    var = 2 \n    def print_var():\n        var = 3         # Initialize local version of the variable\n        print var       # Use variable from local scope.\n    print_var()         # Note that this local variable \"shadows\" the variable from\n    print var           # outer scope which makes code more difficult to interpret.\n\n\ndef test3():\n    var = 4\n    def print_var():\n        nonlocal var    # Use non-local variable from outer scope.\n        print var\n    print_var()\n    print var\n```\n\n## References\n* Python Standard Library: [Built-in Exceptions: UnboundLocalError](http://docs.python.org/library/exceptions.html#exceptions.UnboundLocalError).\n* Python Frequently Asked Questions: [Why am I getting an UnboundLocalError when the variable has a value?](http://docs.python.org/2/faq/programming.html#why-am-i-getting-an-unboundlocalerror-when-the-variable-has-a-value).\n* Python Course: [Global and Local Variables](http://www.python-course.eu/global_vs_local_variables.php).\n* Python Language Reference: [The global statement](http://docs.python.org/2.7/reference/simple_stmts.html#index-54), [The nonlocal statement](http://docs.python.org/3.3/reference/simple_stmts.html#index-43).\n"},"properties":{"tags":["reliability","correctness"],"description":"Using a local variable before it is initialized causes an UnboundLocalError.","id":"py/uninitialized-local-variable","kind":"problem","name":"Potentially uninitialized local variable","precision":"medium","problem.severity":"error","sub-severity":"low"}},{"id":"py/undefined-placeholder-variable","name":"py/undefined-placeholder-variable","shortDescription":{"text":"Use of an undefined placeholder variable"},"fullDescription":{"text":"Using a variable before it is initialized causes an exception."},"defaultConfiguration":{"enabled":true,"level":"error"},"help":{"text":"# Use of an undefined placeholder variable\nThis place-holder variable may not be defined. If this code is executed and the variable is undefined then a `NameError` will occur.\n\n\n## Recommendation\nCheck that the name of the place-holder variable is not a typographic error. If the name is correct, either define a value for the variable, or import the module that defines the function or method that sets the value.\n\nIf another module initializes this variable before it is used, then the `NameError` may not occur. However, you can make the code more robust and clearer by setting the variable to a default value in its own module.\n\n\n## References\n* Python Standard Library: [NameError](https://docs.python.org/library/exceptions.html#exceptions.NameError).\n","markdown":"# Use of an undefined placeholder variable\nThis place-holder variable may not be defined. If this code is executed and the variable is undefined then a `NameError` will occur.\n\n\n## Recommendation\nCheck that the name of the place-holder variable is not a typographic error. If the name is correct, either define a value for the variable, or import the module that defines the function or method that sets the value.\n\nIf another module initializes this variable before it is used, then the `NameError` may not occur. However, you can make the code more robust and clearer by setting the variable to a default value in its own module.\n\n\n## References\n* Python Standard Library: [NameError](https://docs.python.org/library/exceptions.html#exceptions.NameError).\n"},"properties":{"tags":["reliability","correctness"],"description":"Using a variable before it is initialized causes an exception.","id":"py/undefined-placeholder-variable","kind":"problem","name":"Use of an undefined placeholder variable","precision":"medium","problem.severity":"error","sub-severity":"low"}},{"id":"py/loop-variable-capture","name":"py/loop-variable-capture","shortDescription":{"text":"Loop variable capture"},"fullDescription":{"text":"Capturing a loop variable is not the same as capturing its value, and can lead to unexpected behavior or bugs."},"defaultConfiguration":{"enabled":true,"level":"error"},"help":{"text":"# Loop variable capture\nIn Python, a nested function or lambda expression that captures a variable from its surrounding scope is a *late-binding* closure, meaning that the value of the variable is determined when the closure is called, not when it is created.\n\nCare must be taken when the captured variable is a loop variable. If the closure is called after the loop ends, it will use the value of the variable on the last iteration of the loop, rather than the value at the iteration at which it was created.\n\n\n## Recommendation\nEnsure that closures that capture loop variables aren't used outside of a single iteration of the loop. To capture the value of a loop variable at the time the closure is created, use a default parameter, or `functools.partial`.\n\n\n## Example\nIn the following (BAD) example, a `tasks` list is created, but each task captures the loop variable `i`, and reads the same value when run.\n\n\n```python\n# BAD: The loop variable `i` is captured.\ntasks = []\nfor i in range(5):\n    tasks.append(lambda: print(i))\n\n# This will print `4,4,4,4,4`, rather than `0,1,2,3,4` as likely intended.\nfor t in tasks:\n    t() \n```\nIn the following (GOOD) example, each closure has an `i` default parameter, shadowing the outer `i` variable, the default value of which is determined as the value of the loop variable `i` at the time the closure is created.\n\n\n```python\n# GOOD: A default parameter is used, so the variable `i` is not being captured.\ntasks = []\nfor i in range(5):\n    tasks.append(lambda i=i: print(i))\n\n# This will print `0,1,2,3,4``.\nfor t in tasks:\n    t() \n```\nIn the following (GOOD) example, `functools.partial` is used to partially evaluate the lambda expression with the value of `i`.\n\n\n```python\nimport functools\n# GOOD: `functools.partial` takes care of capturing the _value_ of `i`.\ntasks = []\nfor i in range(5):\n    tasks.append(functools.partial(lambda i: print(i), i))\n\n# This will print `0,1,2,3,4``.\nfor t in tasks:\n    t() \n```\n\n## References\n* The Hitchhiker's Guide to Python: [Late Binding Closures](http://docs.python-guide.org/en/latest/writing/gotchas/#late-binding-closures).\n* Python Language Reference: [Naming and binding](https://docs.python.org/reference/executionmodel.html#naming-and-binding).\n* Stack Overflow: [Creating functions (or lambdas) in a loop (or comprehension)](https://stackoverflow.com/questions/3431676/creating-functions-or-lambdas-in-a-loop-or-comprehension).\n* Python Language Reference: [functools.partial](https://docs.python.org/3/library/functools.html#functools.partial).\n","markdown":"# Loop variable capture\nIn Python, a nested function or lambda expression that captures a variable from its surrounding scope is a *late-binding* closure, meaning that the value of the variable is determined when the closure is called, not when it is created.\n\nCare must be taken when the captured variable is a loop variable. If the closure is called after the loop ends, it will use the value of the variable on the last iteration of the loop, rather than the value at the iteration at which it was created.\n\n\n## Recommendation\nEnsure that closures that capture loop variables aren't used outside of a single iteration of the loop. To capture the value of a loop variable at the time the closure is created, use a default parameter, or `functools.partial`.\n\n\n## Example\nIn the following (BAD) example, a `tasks` list is created, but each task captures the loop variable `i`, and reads the same value when run.\n\n\n```python\n# BAD: The loop variable `i` is captured.\ntasks = []\nfor i in range(5):\n    tasks.append(lambda: print(i))\n\n# This will print `4,4,4,4,4`, rather than `0,1,2,3,4` as likely intended.\nfor t in tasks:\n    t() \n```\nIn the following (GOOD) example, each closure has an `i` default parameter, shadowing the outer `i` variable, the default value of which is determined as the value of the loop variable `i` at the time the closure is created.\n\n\n```python\n# GOOD: A default parameter is used, so the variable `i` is not being captured.\ntasks = []\nfor i in range(5):\n    tasks.append(lambda i=i: print(i))\n\n# This will print `0,1,2,3,4``.\nfor t in tasks:\n    t() \n```\nIn the following (GOOD) example, `functools.partial` is used to partially evaluate the lambda expression with the value of `i`.\n\n\n```python\nimport functools\n# GOOD: `functools.partial` takes care of capturing the _value_ of `i`.\ntasks = []\nfor i in range(5):\n    tasks.append(functools.partial(lambda i: print(i), i))\n\n# This will print `0,1,2,3,4``.\nfor t in tasks:\n    t() \n```\n\n## References\n* The Hitchhiker's Guide to Python: [Late Binding Closures](http://docs.python-guide.org/en/latest/writing/gotchas/#late-binding-closures).\n* Python Language Reference: [Naming and binding](https://docs.python.org/reference/executionmodel.html#naming-and-binding).\n* Stack Overflow: [Creating functions (or lambdas) in a loop (or comprehension)](https://stackoverflow.com/questions/3431676/creating-functions-or-lambdas-in-a-loop-or-comprehension).\n* Python Language Reference: [functools.partial](https://docs.python.org/3/library/functools.html#functools.partial).\n"},"properties":{"tags":["quality","reliability","correctness"],"description":"Capturing a loop variable is not the same as capturing its value, and can lead to unexpected behavior or bugs.","id":"py/loop-variable-capture","kind":"path-problem","name":"Loop variable capture","precision":"high","problem.severity":"error","sub-severity":"low"}},{"id":"py/leaking-list-comprehension","name":"py/leaking-list-comprehension","shortDescription":{"text":"List comprehension variable used in enclosing scope"},"fullDescription":{"text":"Using the iteration variable of a list comprehension in the enclosing scope will result in different behavior between Python 2 and 3 and is confusing."},"defaultConfiguration":{"enabled":true,"level":"warning"},"help":{"text":"# List comprehension variable used in enclosing scope\nIn Python 2 list comprehensions are evaluated in the enclosing scope, which means that the iteration variable of a list comprehension is visible outside of the list comprehension. In Python 3 the iteration variable is no longer visible in the enclosing scope.\n\nCode that uses the value of a list comprehension iteration variable after the list comprehension has finished will behave differently under Python 2 and Python 3.\n\n\n## Recommendation\nExplicitly set the variable in the outer scope to the value that it would have held when run under Python 2. Then rename the list comprehension variable for additional clarity.\n\n\n## Example\nIn this example, `x` is initially assigned the value of 3. In Python 3, `x` will be unchanged as the list comprehension is evaluated in its own scope. In Python 2, evaluation of the list comprehension occurs in the scope of `two_or_three`, setting `x` to 2.\n\n\n```python\n\ndef two_or_three():\n    x = 3\n    [0 for x in range(3)]\n    return x # Will return 2 in Python 2 and 3 in Python 3.\n\nprint(two_or_three())\n```\nThe following example is the same code as above, but the list comprehension variable is renamed to ensure it does not overwrite `x`.\n\n\n```python\n\ndef just_three():\n    x = 3\n    [0 for y in range(3)]\n    return x # Will return always return 3.\n\nprint(just_three())\n```\n\n## References\n* Python Tutorial: [List Comprehensions](https://docs.python.org/2/tutorial/datastructures.html#list-comprehensions).\n* The History of Python: [From List Comprehensions to Generator Expressions](http://python-history.blogspot.co.uk/2010/06/from-list-comprehensions-to-generator.html).\n* Python Language Reference: [List displays](https://docs.python.org/2/reference/expressions.html#list-displays).\n","markdown":"# List comprehension variable used in enclosing scope\nIn Python 2 list comprehensions are evaluated in the enclosing scope, which means that the iteration variable of a list comprehension is visible outside of the list comprehension. In Python 3 the iteration variable is no longer visible in the enclosing scope.\n\nCode that uses the value of a list comprehension iteration variable after the list comprehension has finished will behave differently under Python 2 and Python 3.\n\n\n## Recommendation\nExplicitly set the variable in the outer scope to the value that it would have held when run under Python 2. Then rename the list comprehension variable for additional clarity.\n\n\n## Example\nIn this example, `x` is initially assigned the value of 3. In Python 3, `x` will be unchanged as the list comprehension is evaluated in its own scope. In Python 2, evaluation of the list comprehension occurs in the scope of `two_or_three`, setting `x` to 2.\n\n\n```python\n\ndef two_or_three():\n    x = 3\n    [0 for x in range(3)]\n    return x # Will return 2 in Python 2 and 3 in Python 3.\n\nprint(two_or_three())\n```\nThe following example is the same code as above, but the list comprehension variable is renamed to ensure it does not overwrite `x`.\n\n\n```python\n\ndef just_three():\n    x = 3\n    [0 for y in range(3)]\n    return x # Will return always return 3.\n\nprint(just_three())\n```\n\n## References\n* Python Tutorial: [List Comprehensions](https://docs.python.org/2/tutorial/datastructures.html#list-comprehensions).\n* The History of Python: [From List Comprehensions to Generator Expressions](http://python-history.blogspot.co.uk/2010/06/from-list-comprehensions-to-generator.html).\n* Python Language Reference: [List displays](https://docs.python.org/2/reference/expressions.html#list-displays).\n"},"properties":{"tags":["portability","correctness"],"description":"Using the iteration variable of a list comprehension in the enclosing scope will result in different behavior between Python 2 and 3 and is confusing.","id":"py/leaking-list-comprehension","kind":"problem","name":"List comprehension variable used in enclosing scope","precision":"very-high","problem.severity":"warning","sub-severity":"high"}},{"id":"py/redundant-global-declaration","name":"py/redundant-global-declaration","shortDescription":{"text":"Use of 'global' at module level"},"fullDescription":{"text":"Use of the 'global' statement at module level"},"defaultConfiguration":{"enabled":true,"level":"warning"},"help":{"text":"# Use of 'global' at module level\nThe `global` statement is used to specify that assignments to that name are assignments to the variable in the global (module) scope, rather than in the local scope. At the module level, this statement is redundant because the local scope and global scope are the same.\n\n\n## Recommendation\nRemove the `global` statement.\n\n\n## References\n* Python Language Reference: [The global statement](http://docs.python.org/reference/simple_stmts.html#the-global-statement).\n","markdown":"# Use of 'global' at module level\nThe `global` statement is used to specify that assignments to that name are assignments to the variable in the global (module) scope, rather than in the local scope. At the module level, this statement is redundant because the local scope and global scope are the same.\n\n\n## Recommendation\nRemove the `global` statement.\n\n\n## References\n* Python Language Reference: [The global statement](http://docs.python.org/reference/simple_stmts.html#the-global-statement).\n"},"properties":{"tags":["quality","maintainability","useless-code"],"description":"Use of the 'global' statement at module level","id":"py/redundant-global-declaration","kind":"problem","name":"Use of 'global' at module level","precision":"very-high","problem.severity":"warning","sub-severity":"low"}},{"id":"py/undefined-export","name":"py/undefined-export","shortDescription":{"text":"Explicit export is not defined"},"fullDescription":{"text":"Including an undefined attribute in `__all__` causes an exception when the module is imported using '*'"},"defaultConfiguration":{"enabled":true,"level":"error"},"help":{"text":"# Explicit export is not defined\nWhen a module is imported using `import *`, all attributes listed in `__all__` are imported. If `__all__` includes attributes that are not defined in the module then an exception is triggered. This usually indicates a typographic error in the attributes in `__all__` or in the name of the object.\n\n\n## Recommendation\nCorrect any typographic errors, either in the name of the object or in the string in `__all__`. If there are no typographic errors, either delete the name from `__all__` or add the object to the module.\n\n\n## Example\nIn the example, the function name `spam` has been misspelled in the `__all__` list. This will result in `spamm` being highlighted as an undefined export. Correcting the spelling will fix the defect.\n\n\n```python\n__all__ = ['spamm', 'troll', 'paywall']\n\ndef spam(): return 'Spam'\ndef troll(): return 'Troll'\ndef paywall(): return 'Pay wall'\n\n```\n\n## References\n* Python Language Reference: [The import statement](http://docs.python.org/2/reference/simple_stmts.html#import).\n* Python Tutorial: [Importing \\* from a Package](http://docs.python.org/2/tutorial/modules.html#importing-from-a-package).\n","markdown":"# Explicit export is not defined\nWhen a module is imported using `import *`, all attributes listed in `__all__` are imported. If `__all__` includes attributes that are not defined in the module then an exception is triggered. This usually indicates a typographic error in the attributes in `__all__` or in the name of the object.\n\n\n## Recommendation\nCorrect any typographic errors, either in the name of the object or in the string in `__all__`. If there are no typographic errors, either delete the name from `__all__` or add the object to the module.\n\n\n## Example\nIn the example, the function name `spam` has been misspelled in the `__all__` list. This will result in `spamm` being highlighted as an undefined export. Correcting the spelling will fix the defect.\n\n\n```python\n__all__ = ['spamm', 'troll', 'paywall']\n\ndef spam(): return 'Spam'\ndef troll(): return 'Troll'\ndef paywall(): return 'Pay wall'\n\n```\n\n## References\n* Python Language Reference: [The import statement](http://docs.python.org/2/reference/simple_stmts.html#import).\n* Python Tutorial: [Importing \\* from a Package](http://docs.python.org/2/tutorial/modules.html#importing-from-a-package).\n"},"properties":{"tags":["quality","reliability","correctness"],"description":"Including an undefined attribute in `__all__` causes an exception when\n              the module is imported using '*'","id":"py/undefined-export","kind":"problem","name":"Explicit export is not defined","precision":"high","problem.severity":"error","sub-severity":"low"}},{"id":"py/unused-local-variable","name":"py/unused-local-variable","shortDescription":{"text":"Unused local variable"},"fullDescription":{"text":"Local variable is defined but not used"},"defaultConfiguration":{"enabled":true,"level":"note"},"help":{"text":"# Unused local variable\nA local variable is defined (by an assignment) but never used.\n\nIt is sometimes necessary to have a variable which is not used. These unused variables should have distinctive names, to make it clear to readers of the code that they are deliberately not used. The most common conventions for indicating this are to name the variable `_` or to start the name of the variable with `unused` or `_unused`.\n\nThe query accepts the following names for variables that are intended to be unused:\n\n* Any name consisting entirely of underscores.\n* Any name containing `unused`.\n* The names `dummy` or `empty`.\n* Any \"special\" name of the form `__xxx__`.\nVariables that are defined in a group, for example `x, y = func()` are handled collectively. If they are all unused, then this is reported. Otherwise they are all treated as used.\n\n\n## Recommendation\nIf the variable is included for documentation purposes or is otherwise intentionally unused, then change its name to indicate that it is unused, otherwise delete the assignment (taking care not to delete right hand side if it has side effects).\n\n\n## Example\nIn this example, the `random_no` variable is never read but its assignment has a side effect. Because of this it is important to remove only the left hand side of the assignment in line 10.\n\n\n```python\nimport random\n\ndef write_random_to_file():\n    no = random.randint(1, 10)\n    with open(\"random.txt\", \"w\") as file:\n        file.write(str(no))\n    return no\n\ndef write_random():\n    random_no = write_random_to_file()\n    print \"A random number was written to random.txt\"\n```\n\n## References\n* Python: [Assignment statements](http://docs.python.org/2/reference/simple_stmts.html#assignment-statements).\n* Common Weakness Enumeration: [CWE-563](https://cwe.mitre.org/data/definitions/563.html).\n","markdown":"# Unused local variable\nA local variable is defined (by an assignment) but never used.\n\nIt is sometimes necessary to have a variable which is not used. These unused variables should have distinctive names, to make it clear to readers of the code that they are deliberately not used. The most common conventions for indicating this are to name the variable `_` or to start the name of the variable with `unused` or `_unused`.\n\nThe query accepts the following names for variables that are intended to be unused:\n\n* Any name consisting entirely of underscores.\n* Any name containing `unused`.\n* The names `dummy` or `empty`.\n* Any \"special\" name of the form `__xxx__`.\nVariables that are defined in a group, for example `x, y = func()` are handled collectively. If they are all unused, then this is reported. Otherwise they are all treated as used.\n\n\n## Recommendation\nIf the variable is included for documentation purposes or is otherwise intentionally unused, then change its name to indicate that it is unused, otherwise delete the assignment (taking care not to delete right hand side if it has side effects).\n\n\n## Example\nIn this example, the `random_no` variable is never read but its assignment has a side effect. Because of this it is important to remove only the left hand side of the assignment in line 10.\n\n\n```python\nimport random\n\ndef write_random_to_file():\n    no = random.randint(1, 10)\n    with open(\"random.txt\", \"w\") as file:\n        file.write(str(no))\n    return no\n\ndef write_random():\n    random_no = write_random_to_file()\n    print \"A random number was written to random.txt\"\n```\n\n## References\n* Python: [Assignment statements](http://docs.python.org/2/reference/simple_stmts.html#assignment-statements).\n* Common Weakness Enumeration: [CWE-563](https://cwe.mitre.org/data/definitions/563.html).\n"},"properties":{"tags":["quality","maintainability","useless-code","external/cwe/cwe-563"],"description":"Local variable is defined but not used","id":"py/unused-local-variable","kind":"problem","name":"Unused local variable","precision":"very-high","problem.severity":"recommendation","sub-severity":"high"}}],"locations":[{"uri":"file:///opt/hostedtoolcache/CodeQL/2.23.0/x64/codeql/qlpacks/codeql/python-queries/1.6.4/","description":{"text":"The QL pack root directory."},"properties":{"tags":["CodeQL/LocalPackRoot"]}},{"uri":"file:///opt/hostedtoolcache/CodeQL/2.23.0/x64/codeql/qlpacks/codeql/python-queries/1.6.4/qlpack.yml","description":{"text":"The QL pack definition file."},"properties":{"tags":["CodeQL/LocalPackDefinitionFile"]}}]},{"name":"codeql/python-all","semanticVersion":"4.0.14+28f02c07d7d744d761520fbfb354f96827a11f6c","locations":[{"uri":"file:///opt/hostedtoolcache/CodeQL/2.23.0/x64/codeql/qlpacks/codeql/python-queries/1.6.4/.codeql/libraries/codeql/python-all/4.0.14/","description":{"text":"The QL pack root directory."},"properties":{"tags":["CodeQL/LocalPackRoot"]}},{"uri":"file:///opt/hostedtoolcache/CodeQL/2.23.0/x64/codeql/qlpacks/codeql/python-queries/1.6.4/.codeql/libraries/codeql/python-all/4.0.14/qlpack.yml","description":{"text":"The QL pack definition file."},"properties":{"tags":["CodeQL/LocalPackDefinitionFile"]}}]},{"name":"codeql/threat-models","semanticVersion":"1.0.30+28f02c07d7d744d761520fbfb354f96827a11f6c","locations":[{"uri":"file:///opt/hostedtoolcache/CodeQL/2.23.0/x64/codeql/qlpacks/codeql/python-queries/1.6.4/.codeql/libraries/codeql/threat-models/1.0.30/","description":{"text":"The QL pack root directory."},"properties":{"tags":["CodeQL/LocalPackRoot"]}},{"uri":"file:///opt/hostedtoolcache/CodeQL/2.23.0/x64/codeql/qlpacks/codeql/python-queries/1.6.4/.codeql/libraries/codeql/threat-models/1.0.30/qlpack.yml","description":{"text":"The QL pack definition file."},"properties":{"tags":["CodeQL/LocalPackDefinitionFile"]}}]}]},"invocations":[{"toolExecutionNotifications":[{"locations":[{"physicalLocation":{"artifactLocation":{"uri":"main.py","uriBaseId":"%SRCROOT%","index":0}}}],"message":{"text":""},"level":"none","descriptor":{"id":"py/diagnostics/successfully-extracted-files","index":1,"toolComponent":{"index":0}},"properties":{"formattedMessage":{"text":""}}},{"locations":[{"physicalLocation":{"artifactLocation":{"uri":".github/workflows/codeql.yml","uriBaseId":"%SRCROOT%","index":1}}}],"message":{"text":""},"level":"none","descriptor":{"id":"py/diagnostics/successfully-extracted-files","index":1,"toolComponent":{"index":0}},"properties":{"formattedMessage":{"text":""}}},{"locations":[{"physicalLocation":{"artifactLocation":{"uri":"main.py","uriBaseId":"%SRCROOT%","index":0}}}],"message":{"text":""},"level":"none","descriptor":{"id":"cli/expected-extracted-files/python","index":0},"properties":{"formattedMessage":{"text":""}}},{"message":{"text":"On the Linux (amd64; 6.11.0-1018-azure) platform.","markdown":"On the Linux (amd64; 6.11.0-1018-azure) platform."},"level":"none","timeUtc":"2025-09-08T16:19:30.191793968Z","descriptor":{"id":"cli/platform","index":1},"properties":{"attributes":{"arch":"amd64","name":"Linux","version":"6.11.0-1018-azure"},"visibility":{"statusPage":false,"telemetry":true}}},{"message":{"text":""},"level":"none","timeUtc":"2025-09-08T16:19:23.154Z","descriptor":{"id":"codeql-action/bundle-download-telemetry","index":2},"properties":{"attributes":{"combinedDurationMs":4237,"compressionMethod":"zstd","streamExtraction":true,"toolsUrl":"https://github.com/github/codeql-action/releases/download/codeql-bundle-v2.23.0/codeql-bundle-linux64.tar.zst"},"visibility":{"statusPage":false,"telemetry":true}}}],"executionSuccessful":true}],"artifacts":[{"location":{"uri":"main.py","uriBaseId":"%SRCROOT%","index":0}},{"location":{"uri":".github/workflows/codeql.yml","uriBaseId":"%SRCROOT%","index":1}}],"results":[{"ruleId":"py/stack-trace-exposure","rule":{"id":"py/stack-trace-exposure","index":1,"toolComponent":{"index":0}},"message":{"text":"[Stack trace information](1) flows to this location and may be exposed to an external user."},"locations":[{"physicalLocation":{"artifactLocation":{"uri":"main.py","uriBaseId":"%SRCROOT%","index":0},"region":{"startLine":24,"startColumn":12,"endColumn":44}}}],"partialFingerprints":{"primaryLocationLineHash":"981c143f09c23678:1","primaryLocationStartColumnFingerprint":"7"},"codeFlows":[{"threadFlows":[{"locations":[{"location":{"physicalLocation":{"artifactLocation":{"uri":"main.py","uriBaseId":"%SRCROOT%","index":0},"region":{"startLine":22,"startColumn":25,"endColumn":26}},"message":{"text":"ControlFlowNode for e"}}},{"location":{"physicalLocation":{"artifactLocation":{"uri":"main.py","uriBaseId":"%SRCROOT%","index":0},"region":{"startLine":23,"startColumn":9,"endColumn":15}},"message":{"text":"ControlFlowNode for result"}}},{"location":{"physicalLocation":{"artifactLocation":{"uri":"main.py","uriBaseId":"%SRCROOT%","index":0},"region":{"startLine":24,"startColumn":12,"endColumn":44}},"message":{"text":"ControlFlowNode for Dict"}}}]}]}],"relatedLocations":[{"id":1,"physicalLocation":{"artifactLocation":{"uri":"main.py","uriBaseId":"%SRCROOT%","index":0},"region":{"startLine":22,"startColumn":25,"endColumn":26}},"message":{"text":"Stack trace information"}}]},{"ruleId":"py/stack-trace-exposure","rule":{"id":"py/stack-trace-exposure","index":1,"toolComponent":{"index":0}},"message":{"text":"[Stack trace information](1) flows to this location and may be exposed to an external user."},"locations":[{"physicalLocation":{"artifactLocation":{"uri":"main.py","uriBaseId":"%SRCROOT%","index":0},"region":{"startLine":50,"startColumn":16,"endColumn":49}}}],"partialFingerprints":{"primaryLocationLineHash":"5049acd3564e1c00:1","primaryLocationStartColumnFingerprint":"7"},"codeFlows":[{"threadFlows":[{"locations":[{"location":{"physicalLocation":{"artifactLocation":{"uri":"main.py","uriBaseId":"%SRCROOT%","index":0},"region":{"startLine":49,"startColumn":25,"endColumn":26}},"message":{"text":"ControlFlowNode for e"}}},{"location":{"physicalLocation":{"artifactLocation":{"uri":"main.py","uriBaseId":"%SRCROOT%","index":0},"region":{"startLine":50,"startColumn":16,"endColumn":49}},"message":{"text":"ControlFlowNode for Dict"}}}]}]}],"relatedLocations":[{"id":1,"physicalLocation":{"artifactLocation":{"uri":"main.py","uriBaseId":"%SRCROOT%","index":0},"region":{"startLine":49,"startColumn":25,"endColumn":26}},"message":{"text":"Stack trace information"}}]},{"ruleId":"py/code-injection","rule":{"id":"py/code-injection","index":13,"toolComponent":{"index":0}},"message":{"text":"This code execution depends on a [user-provided value](1)."},"locations":[{"physicalLocation":{"artifactLocation":{"uri":"main.py","uriBaseId":"%SRCROOT%","index":0},"region":{"startLine":21,"startColumn":23,"endColumn":27}}}],"partialFingerprints":{"primaryLocationLineHash":"3a92d6bc211fdd69:1","primaryLocationStartColumnFingerprint":"14"},"codeFlows":[{"threadFlows":[{"locations":[{"location":{"physicalLocation":{"artifactLocation":{"uri":"main.py","uriBaseId":"%SRCROOT%","index":0},"region":{"startLine":18,"startColumn":20,"endColumn":24}},"message":{"text":"ControlFlowNode for expr"}}},{"location":{"physicalLocation":{"artifactLocation":{"uri":"main.py","uriBaseId":"%SRCROOT%","index":0},"region":{"startLine":21,"startColumn":23,"endColumn":27}},"message":{"text":"ControlFlowNode for expr"}}}]}]}],"relatedLocations":[{"id":1,"physicalLocation":{"artifactLocation":{"uri":"main.py","uriBaseId":"%SRCROOT%","index":0},"region":{"startLine":18,"startColumn":20,"endColumn":24}},"message":{"text":"user-provided value"}}]},{"ruleId":"py/reflective-xss","rule":{"id":"py/reflective-xss","index":31,"toolComponent":{"index":0}},"message":{"text":"Cross-site scripting vulnerability due to a [user-provided value](1)."},"locations":[{"physicalLocation":{"artifactLocation":{"uri":"main.py","uriBaseId":"%SRCROOT%","index":0},"region":{"startLine":39,"startColumn":33,"endColumn":37}}}],"partialFingerprints":{"primaryLocationLineHash":"82c462c4db7f5ae8:1","primaryLocationStartColumnFingerprint":"28"},"codeFlows":[{"threadFlows":[{"locations":[{"location":{"physicalLocation":{"artifactLocation":{"uri":"main.py","uriBaseId":"%SRCROOT%","index":0},"region":{"startLine":29,"startColumn":27,"endColumn":31}},"message":{"text":"ControlFlowNode for name"}}},{"location":{"physicalLocation":{"artifactLocation":{"uri":"main.py","uriBaseId":"%SRCROOT%","index":0},"region":{"startLine":31,"startColumn":5,"endColumn":9}},"message":{"text":"ControlFlowNode for html"}}},{"location":{"physicalLocation":{"artifactLocation":{"uri":"main.py","uriBaseId":"%SRCROOT%","index":0},"region":{"startLine":39,"startColumn":33,"endColumn":37}},"message":{"text":"ControlFlowNode for html"}}}]}]}],"relatedLocations":[{"id":1,"physicalLocation":{"artifactLocation":{"uri":"main.py","uriBaseId":"%SRCROOT%","index":0},"region":{"startLine":29,"startColumn":27,"endColumn":31}},"message":{"text":"user-provided value"}}]},{"ruleId":"py/sql-injection","rule":{"id":"py/sql-injection","index":36,"toolComponent":{"index":0}},"message":{"text":"This SQL query depends on a [user-provided value](1).\nThis SQL query depends on a [user-provided value](2)."},"locations":[{"physicalLocation":{"artifactLocation":{"uri":"main.py","uriBaseId":"%SRCROOT%","index":0},"region":{"startLine":48,"startColumn":30,"endColumn":35}}}],"partialFingerprints":{"primaryLocationLineHash":"8b58462053cfa7ca:1","primaryLocationStartColumnFingerprint":"21"},"codeFlows":[{"threadFlows":[{"locations":[{"location":{"physicalLocation":{"artifactLocation":{"uri":"main.py","uriBaseId":"%SRCROOT%","index":0},"region":{"startLine":44,"startColumn":11,"endColumn":19}},"message":{"text":"ControlFlowNode for username"}}},{"location":{"physicalLocation":{"artifactLocation":{"uri":"main.py","uriBaseId":"%SRCROOT%","index":0},"region":{"startLine":46,"startColumn":5,"endColumn":10}},"message":{"text":"ControlFlowNode for query"}}},{"location":{"physicalLocation":{"artifactLocation":{"uri":"main.py","uriBaseId":"%SRCROOT%","index":0},"region":{"startLine":48,"startColumn":30,"endColumn":35}},"message":{"text":"ControlFlowNode for query"}}}]}]},{"threadFlows":[{"locations":[{"location":{"physicalLocation":{"artifactLocation":{"uri":"main.py","uriBaseId":"%SRCROOT%","index":0},"region":{"startLine":44,"startColumn":26,"endColumn":34}},"message":{"text":"ControlFlowNode for password"}}},{"location":{"physicalLocation":{"artifactLocation":{"uri":"main.py","uriBaseId":"%SRCROOT%","index":0},"region":{"startLine":46,"startColumn":5,"endColumn":10}},"message":{"text":"ControlFlowNode for query"}}},{"location":{"physicalLocation":{"artifactLocation":{"uri":"main.py","uriBaseId":"%SRCROOT%","index":0},"region":{"startLine":48,"startColumn":30,"endColumn":35}},"message":{"text":"ControlFlowNode for query"}}}]}]}],"relatedLocations":[{"id":1,"physicalLocation":{"artifactLocation":{"uri":"main.py","uriBaseId":"%SRCROOT%","index":0},"region":{"startLine":44,"startColumn":11,"endColumn":19}},"message":{"text":"user-provided value"}},{"id":2,"physicalLocation":{"artifactLocation":{"uri":"main.py","uriBaseId":"%SRCROOT%","index":0},"region":{"startLine":44,"startColumn":26,"endColumn":34}},"message":{"text":"user-provided value"}}]}],"automationDetails":{"id":"/language:python/"},"columnKind":"unicodeCodePoints","properties":{"semmle.formatSpecifier":"sarif-latest","metricResults":[{"rule":{"id":"py/summary/lines-of-code","index":46,"toolComponent":{"index":0}},"ruleId":"py/summary/lines-of-code","value":36},{"rule":{"id":"py/summary/lines-of-user-code","index":47,"toolComponent":{"index":0}},"ruleId":"py/summary/lines-of-user-code","value":36,"baseline":36}],"codeqlConfigSummary":{"disableDefaultQueries":false,"queries":[{"type":"builtinSuite","uses":"security-extended"},{"type":"builtinSuite","uses":"security-and-quality"}]},"jobRunUuid":"1beaa1a9-b4d0-4497-8884-a5f7e9076193"}}]}